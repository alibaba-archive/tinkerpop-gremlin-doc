<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=edge"><![endif]-->
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 1.5.8">
<meta name="author" content="阿里云GDB团队">
<title>Gremlin中文文档</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700">
<style>
/* Asciidoctor default stylesheet | MIT License | http://asciidoctor.org */
/* Uncomment @import statement below to use as custom stylesheet */
/*@import "https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700";*/
article,aside,details,figcaption,figure,footer,header,hgroup,main,nav,section,summary{display:block}
audio,canvas,video{display:inline-block}
audio:not([controls]){display:none;height:0}
script{display:none!important}
html{font-family:sans-serif;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}
a{background:transparent}
a:focus{outline:thin dotted}
a:active,a:hover{outline:0}
h1{font-size:2em;margin:.67em 0}
abbr[title]{border-bottom:1px dotted}
b,strong{font-weight:bold}
dfn{font-style:italic}
hr{-moz-box-sizing:content-box;box-sizing:content-box;height:0}
mark{background:#ff0;color:#000}
code,kbd,pre,samp{font-family:monospace;font-size:1em}
pre{white-space:pre-wrap}
q{quotes:"\201C" "\201D" "\2018" "\2019"}
small{font-size:80%}
sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}
sup{top:-.5em}
sub{bottom:-.25em}
img{border:0}
svg:not(:root){overflow:hidden}
figure{margin:0}
fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}
legend{border:0;padding:0}
button,input,select,textarea{font-family:inherit;font-size:100%;margin:0}
button,input{line-height:normal}
button,select{text-transform:none}
button,html input[type="button"],input[type="reset"],input[type="submit"]{-webkit-appearance:button;cursor:pointer}
button[disabled],html input[disabled]{cursor:default}
input[type="checkbox"],input[type="radio"]{box-sizing:border-box;padding:0}
button::-moz-focus-inner,input::-moz-focus-inner{border:0;padding:0}
textarea{overflow:auto;vertical-align:top}
table{border-collapse:collapse;border-spacing:0}
*,*::before,*::after{-moz-box-sizing:border-box;-webkit-box-sizing:border-box;box-sizing:border-box}
html,body{font-size:100%}
body{background:#fff;color:rgba(0,0,0,.8);padding:0;margin:0;font-family:"Noto Serif","DejaVu Serif",serif;font-weight:400;font-style:normal;line-height:1;position:relative;cursor:auto;tab-size:4;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased}
a:hover{cursor:pointer}
img,object,embed{max-width:100%;height:auto}
object,embed{height:100%}
img{-ms-interpolation-mode:bicubic}
.left{float:left!important}
.right{float:right!important}
.text-left{text-align:left!important}
.text-right{text-align:right!important}
.text-center{text-align:center!important}
.text-justify{text-align:justify!important}
.hide{display:none}
img,object,svg{display:inline-block;vertical-align:middle}
textarea{height:auto;min-height:50px}
select{width:100%}
.center{margin-left:auto;margin-right:auto}
.stretch{width:100%}
.subheader,.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{line-height:1.45;color:#7a2518;font-weight:400;margin-top:0;margin-bottom:.25em}
div,dl,dt,dd,ul,ol,li,h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6,pre,form,p,blockquote,th,td{margin:0;padding:0;direction:ltr}
a{color:#2156a5;text-decoration:underline;line-height:inherit}
a:hover,a:focus{color:#1d4b8f}
a img{border:none}
p{font-family:inherit;font-weight:400;font-size:1em;line-height:1.6;margin-bottom:1.25em;text-rendering:optimizeLegibility}
p aside{font-size:.875em;line-height:1.35;font-style:italic}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{font-family:"Open Sans","DejaVu Sans",sans-serif;font-weight:300;font-style:normal;color:#ba3925;text-rendering:optimizeLegibility;margin-top:1em;margin-bottom:.5em;line-height:1.0125em}
h1 small,h2 small,h3 small,#toctitle small,.sidebarblock>.content>.title small,h4 small,h5 small,h6 small{font-size:60%;color:#e99b8f;line-height:0}
h1{font-size:2.125em}
h2{font-size:1.6875em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.375em}
h4,h5{font-size:1.125em}
h6{font-size:1em}
hr{border:solid #dddddf;border-width:1px 0 0;clear:both;margin:1.25em 0 1.1875em;height:0}
em,i{font-style:italic;line-height:inherit}
strong,b{font-weight:bold;line-height:inherit}
small{font-size:60%;line-height:inherit}
code{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;font-weight:400;color:rgba(0,0,0,.9)}
ul,ol,dl{font-size:1em;line-height:1.6;margin-bottom:1.25em;list-style-position:outside;font-family:inherit}
ul,ol{margin-left:1.5em}
ul li ul,ul li ol{margin-left:1.25em;margin-bottom:0;font-size:1em}
ul.square li ul,ul.circle li ul,ul.disc li ul{list-style:inherit}
ul.square{list-style-type:square}
ul.circle{list-style-type:circle}
ul.disc{list-style-type:disc}
ol li ul,ol li ol{margin-left:1.25em;margin-bottom:0}
dl dt{margin-bottom:.3125em;font-weight:bold}
dl dd{margin-bottom:1.25em}
abbr,acronym{text-transform:uppercase;font-size:90%;color:rgba(0,0,0,.8);border-bottom:1px dotted #ddd;cursor:help}
abbr{text-transform:none}
blockquote{margin:0 0 1.25em;padding:.5625em 1.25em 0 1.1875em;border-left:1px solid #ddd}
blockquote cite{display:block;font-size:.9375em;color:rgba(0,0,0,.6)}
blockquote cite::before{content:"\2014 \0020"}
blockquote cite a,blockquote cite a:visited{color:rgba(0,0,0,.6)}
blockquote,blockquote p{line-height:1.6;color:rgba(0,0,0,.85)}
@media screen and (min-width:768px){h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2}
h1{font-size:2.75em}
h2{font-size:2.3125em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.6875em}
h4{font-size:1.4375em}}
table{background:#fff;margin-bottom:1.25em;border:solid 1px #dedede}
table thead,table tfoot{background:#f7f8f7}
table thead tr th,table thead tr td,table tfoot tr th,table tfoot tr td{padding:.5em .625em .625em;font-size:inherit;color:rgba(0,0,0,.8);text-align:left}
table tr th,table tr td{padding:.5625em .625em;font-size:inherit;color:rgba(0,0,0,.8)}
table tr.even,table tr.alt,table tr:nth-of-type(even){background:#f8f8f7}
table thead tr th,table tfoot tr th,table tbody tr td,table tr td,table tfoot tr td{display:table-cell;line-height:1.6}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2;word-spacing:-.05em}
h1 strong,h2 strong,h3 strong,#toctitle strong,.sidebarblock>.content>.title strong,h4 strong,h5 strong,h6 strong{font-weight:400}
.clearfix::before,.clearfix::after,.float-group::before,.float-group::after{content:" ";display:table}
.clearfix::after,.float-group::after{clear:both}
*:not(pre)>code{font-size:.9375em;font-style:normal!important;letter-spacing:0;padding:.1em .5ex;word-spacing:-.15em;background-color:#f7f7f8;-webkit-border-radius:4px;border-radius:4px;line-height:1.45;text-rendering:optimizeSpeed;word-wrap:break-word}
*:not(pre)>code.nobreak{word-wrap:normal}
*:not(pre)>code.nowrap{white-space:nowrap}
pre,pre>code{line-height:1.45;color:rgba(0,0,0,.9);font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;font-weight:400;text-rendering:optimizeSpeed}
em em{font-style:normal}
strong strong{font-weight:400}
.keyseq{color:rgba(51,51,51,.8)}
kbd{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;display:inline-block;color:rgba(0,0,0,.8);font-size:.65em;line-height:1.45;background-color:#f7f7f7;border:1px solid #ccc;-webkit-border-radius:3px;border-radius:3px;-webkit-box-shadow:0 1px 0 rgba(0,0,0,.2),0 0 0 .1em white inset;box-shadow:0 1px 0 rgba(0,0,0,.2),0 0 0 .1em #fff inset;margin:0 .15em;padding:.2em .5em;vertical-align:middle;position:relative;top:-.1em;white-space:nowrap}
.keyseq kbd:first-child{margin-left:0}
.keyseq kbd:last-child{margin-right:0}
.menuseq,.menuref{color:#000}
.menuseq b:not(.caret),.menuref{font-weight:inherit}
.menuseq{word-spacing:-.02em}
.menuseq b.caret{font-size:1.25em;line-height:.8}
.menuseq i.caret{font-weight:bold;text-align:center;width:.45em}
b.button::before,b.button::after{position:relative;top:-1px;font-weight:400}
b.button::before{content:"[";padding:0 3px 0 2px}
b.button::after{content:"]";padding:0 2px 0 3px}
p a>code:hover{color:rgba(0,0,0,.9)}
#header,#content,#footnotes,#footer{width:100%;margin-left:auto;margin-right:auto;margin-top:0;margin-bottom:0;max-width:62.5em;*zoom:1;position:relative;padding-left:.9375em;padding-right:.9375em}
#header::before,#header::after,#content::before,#content::after,#footnotes::before,#footnotes::after,#footer::before,#footer::after{content:" ";display:table}
#header::after,#content::after,#footnotes::after,#footer::after{clear:both}
#content{margin-top:1.25em}
#content::before{content:none}
#header>h1:first-child{color:rgba(0,0,0,.85);margin-top:2.25rem;margin-bottom:0}
#header>h1:first-child+#toc{margin-top:8px;border-top:1px solid #dddddf}
#header>h1:only-child,body.toc2 #header>h1:nth-last-child(2){border-bottom:1px solid #dddddf;padding-bottom:8px}
#header .details{border-bottom:1px solid #dddddf;line-height:1.45;padding-top:.25em;padding-bottom:.25em;padding-left:.25em;color:rgba(0,0,0,.6);display:-ms-flexbox;display:-webkit-flex;display:flex;-ms-flex-flow:row wrap;-webkit-flex-flow:row wrap;flex-flow:row wrap}
#header .details span:first-child{margin-left:-.125em}
#header .details span.email a{color:rgba(0,0,0,.85)}
#header .details br{display:none}
#header .details br+span::before{content:"\00a0\2013\00a0"}
#header .details br+span.author::before{content:"\00a0\22c5\00a0";color:rgba(0,0,0,.85)}
#header .details br+span#revremark::before{content:"\00a0|\00a0"}
#header #revnumber{text-transform:capitalize}
#header #revnumber::after{content:"\00a0"}
#content>h1:first-child:not([class]){color:rgba(0,0,0,.85);border-bottom:1px solid #dddddf;padding-bottom:8px;margin-top:0;padding-top:1rem;margin-bottom:1.25rem}
#toc{border-bottom:1px solid #e7e7e9;padding-bottom:.5em}
#toc>ul{margin-left:.125em}
#toc ul.sectlevel0>li>a{font-style:italic}
#toc ul.sectlevel0 ul.sectlevel1{margin:.5em 0}
#toc ul{font-family:"Open Sans","DejaVu Sans",sans-serif;list-style-type:none}
#toc li{line-height:1.3334;margin-top:.3334em}
#toc a{text-decoration:none}
#toc a:active{text-decoration:underline}
#toctitle{color:#7a2518;font-size:1.2em}
@media screen and (min-width:768px){#toctitle{font-size:1.375em}
body.toc2{padding-left:15em;padding-right:0}
#toc.toc2{margin-top:0!important;background-color:#f8f8f7;position:fixed;width:15em;left:0;top:0;border-right:1px solid #e7e7e9;border-top-width:0!important;border-bottom-width:0!important;z-index:1000;padding:1.25em 1em;height:100%;overflow:auto}
#toc.toc2 #toctitle{margin-top:0;margin-bottom:.8rem;font-size:1.2em}
#toc.toc2>ul{font-size:.9em;margin-bottom:0}
#toc.toc2 ul ul{margin-left:0;padding-left:1em}
#toc.toc2 ul.sectlevel0 ul.sectlevel1{padding-left:0;margin-top:.5em;margin-bottom:.5em}
body.toc2.toc-right{padding-left:0;padding-right:15em}
body.toc2.toc-right #toc.toc2{border-right-width:0;border-left:1px solid #e7e7e9;left:auto;right:0}}
@media screen and (min-width:1280px){body.toc2{padding-left:20em;padding-right:0}
#toc.toc2{width:20em}
#toc.toc2 #toctitle{font-size:1.375em}
#toc.toc2>ul{font-size:.95em}
#toc.toc2 ul ul{padding-left:1.25em}
body.toc2.toc-right{padding-left:0;padding-right:20em}}
#content #toc{border-style:solid;border-width:1px;border-color:#e0e0dc;margin-bottom:1.25em;padding:1.25em;background:#f8f8f7;-webkit-border-radius:4px;border-radius:4px}
#content #toc>:first-child{margin-top:0}
#content #toc>:last-child{margin-bottom:0}
#footer{max-width:100%;background-color:rgba(0,0,0,.8);padding:1.25em}
#footer-text{color:rgba(255,255,255,.8);line-height:1.44}
#content{margin-bottom:.625em}
.sect1{padding-bottom:.625em}
@media screen and (min-width:768px){#content{margin-bottom:1.25em}
.sect1{padding-bottom:1.25em}}
.sect1:last-child{padding-bottom:0}
.sect1+.sect1{border-top:1px solid #e7e7e9}
#content h1>a.anchor,h2>a.anchor,h3>a.anchor,#toctitle>a.anchor,.sidebarblock>.content>.title>a.anchor,h4>a.anchor,h5>a.anchor,h6>a.anchor{position:absolute;z-index:1001;width:1.5ex;margin-left:-1.5ex;display:block;text-decoration:none!important;visibility:hidden;text-align:center;font-weight:400}
#content h1>a.anchor::before,h2>a.anchor::before,h3>a.anchor::before,#toctitle>a.anchor::before,.sidebarblock>.content>.title>a.anchor::before,h4>a.anchor::before,h5>a.anchor::before,h6>a.anchor::before{content:"\00A7";font-size:.85em;display:block;padding-top:.1em}
#content h1:hover>a.anchor,#content h1>a.anchor:hover,h2:hover>a.anchor,h2>a.anchor:hover,h3:hover>a.anchor,#toctitle:hover>a.anchor,.sidebarblock>.content>.title:hover>a.anchor,h3>a.anchor:hover,#toctitle>a.anchor:hover,.sidebarblock>.content>.title>a.anchor:hover,h4:hover>a.anchor,h4>a.anchor:hover,h5:hover>a.anchor,h5>a.anchor:hover,h6:hover>a.anchor,h6>a.anchor:hover{visibility:visible}
#content h1>a.link,h2>a.link,h3>a.link,#toctitle>a.link,.sidebarblock>.content>.title>a.link,h4>a.link,h5>a.link,h6>a.link{color:#ba3925;text-decoration:none}
#content h1>a.link:hover,h2>a.link:hover,h3>a.link:hover,#toctitle>a.link:hover,.sidebarblock>.content>.title>a.link:hover,h4>a.link:hover,h5>a.link:hover,h6>a.link:hover{color:#a53221}
.audioblock,.imageblock,.literalblock,.listingblock,.stemblock,.videoblock{margin-bottom:1.25em}
.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{text-rendering:optimizeLegibility;text-align:left;font-family:"Noto Serif","DejaVu Serif",serif;font-size:1rem;font-style:italic}
table.tableblock.fit-content>caption.title{white-space:nowrap;width:0}
.paragraph.lead>p,#preamble>.sectionbody>[class="paragraph"]:first-of-type p{font-size:1.21875em;line-height:1.6;color:rgba(0,0,0,.85)}
table.tableblock #preamble>.sectionbody>[class="paragraph"]:first-of-type p{font-size:inherit}
.admonitionblock>table{border-collapse:separate;border:0;background:none;width:100%}
.admonitionblock>table td.icon{text-align:center;width:80px}
.admonitionblock>table td.icon img{max-width:none}
.admonitionblock>table td.icon .title{font-weight:bold;font-family:"Open Sans","DejaVu Sans",sans-serif;text-transform:uppercase}
.admonitionblock>table td.content{padding-left:1.125em;padding-right:1.25em;border-left:1px solid #dddddf;color:rgba(0,0,0,.6)}
.admonitionblock>table td.content>:last-child>:last-child{margin-bottom:0}
.exampleblock>.content{border-style:solid;border-width:1px;border-color:#e6e6e6;margin-bottom:1.25em;padding:1.25em;background:#fff;-webkit-border-radius:4px;border-radius:4px}
.exampleblock>.content>:first-child{margin-top:0}
.exampleblock>.content>:last-child{margin-bottom:0}
.sidebarblock{border-style:solid;border-width:1px;border-color:#e0e0dc;margin-bottom:1.25em;padding:1.25em;background:#f8f8f7;-webkit-border-radius:4px;border-radius:4px}
.sidebarblock>:first-child{margin-top:0}
.sidebarblock>:last-child{margin-bottom:0}
.sidebarblock>.content>.title{color:#7a2518;margin-top:0;text-align:center}
.exampleblock>.content>:last-child>:last-child,.exampleblock>.content .olist>ol>li:last-child>:last-child,.exampleblock>.content .ulist>ul>li:last-child>:last-child,.exampleblock>.content .qlist>ol>li:last-child>:last-child,.sidebarblock>.content>:last-child>:last-child,.sidebarblock>.content .olist>ol>li:last-child>:last-child,.sidebarblock>.content .ulist>ul>li:last-child>:last-child,.sidebarblock>.content .qlist>ol>li:last-child>:last-child{margin-bottom:0}
.literalblock pre,.listingblock pre:not(.highlight),.listingblock pre[class="highlight"],.listingblock pre[class^="highlight "],.listingblock pre.CodeRay,.listingblock pre.prettyprint{background:#f7f7f8}
.sidebarblock .literalblock pre,.sidebarblock .listingblock pre:not(.highlight),.sidebarblock .listingblock pre[class="highlight"],.sidebarblock .listingblock pre[class^="highlight "],.sidebarblock .listingblock pre.CodeRay,.sidebarblock .listingblock pre.prettyprint{background:#f2f1f1}
.literalblock pre,.literalblock pre[class],.listingblock pre,.listingblock pre[class]{-webkit-border-radius:4px;border-radius:4px;word-wrap:break-word;overflow-x:auto;padding:1em;font-size:.8125em}
@media screen and (min-width:768px){.literalblock pre,.literalblock pre[class],.listingblock pre,.listingblock pre[class]{font-size:.90625em}}
@media screen and (min-width:1280px){.literalblock pre,.literalblock pre[class],.listingblock pre,.listingblock pre[class]{font-size:1em}}
.literalblock pre.nowrap,.literalblock pre.nowrap pre,.listingblock pre.nowrap,.listingblock pre.nowrap pre{white-space:pre;word-wrap:normal}
.literalblock.output pre{color:#f7f7f8;background-color:rgba(0,0,0,.9)}
.listingblock pre.highlightjs{padding:0}
.listingblock pre.highlightjs>code{padding:1em;-webkit-border-radius:4px;border-radius:4px}
.listingblock pre.prettyprint{border-width:0}
.listingblock>.content{position:relative}
.listingblock code[data-lang]::before{display:none;content:attr(data-lang);position:absolute;font-size:.75em;top:.425rem;right:.5rem;line-height:1;text-transform:uppercase;color:#999}
.listingblock:hover code[data-lang]::before{display:block}
.listingblock.terminal pre .command::before{content:attr(data-prompt);padding-right:.5em;color:#999}
.listingblock.terminal pre .command:not([data-prompt])::before{content:"$"}
table.pyhltable{border-collapse:separate;border:0;margin-bottom:0;background:none}
table.pyhltable td{vertical-align:top;padding-top:0;padding-bottom:0;line-height:1.45}
table.pyhltable td.code{padding-left:.75em;padding-right:0}
pre.pygments .lineno,table.pyhltable td:not(.code){color:#999;padding-left:0;padding-right:.5em;border-right:1px solid #dddddf}
pre.pygments .lineno{display:inline-block;margin-right:.25em}
table.pyhltable .linenodiv{background:none!important;padding-right:0!important}
.quoteblock{margin:0 1em 1.25em 1.5em;display:table}
.quoteblock>.title{margin-left:-1.5em;margin-bottom:.75em}
.quoteblock blockquote,.quoteblock p{color:rgba(0,0,0,.85);font-size:1.15rem;line-height:1.75;word-spacing:.1em;letter-spacing:0;font-style:italic;text-align:justify}
.quoteblock blockquote{margin:0;padding:0;border:0}
.quoteblock blockquote::before{content:"\201c";float:left;font-size:2.75em;font-weight:bold;line-height:.6em;margin-left:-.6em;color:#7a2518;text-shadow:0 1px 2px rgba(0,0,0,.1)}
.quoteblock blockquote>.paragraph:last-child p{margin-bottom:0}
.quoteblock .attribution{margin-top:.75em;margin-right:.5ex;text-align:right}
.verseblock{margin:0 1em 1.25em}
.verseblock pre{font-family:"Open Sans","DejaVu Sans",sans;font-size:1.15rem;color:rgba(0,0,0,.85);font-weight:300;text-rendering:optimizeLegibility}
.verseblock pre strong{font-weight:400}
.verseblock .attribution{margin-top:1.25rem;margin-left:.5ex}
.quoteblock .attribution,.verseblock .attribution{font-size:.9375em;line-height:1.45;font-style:italic}
.quoteblock .attribution br,.verseblock .attribution br{display:none}
.quoteblock .attribution cite,.verseblock .attribution cite{display:block;letter-spacing:-.025em;color:rgba(0,0,0,.6)}
.quoteblock.abstract blockquote::before,.quoteblock.excerpt blockquote::before,.quoteblock .quoteblock blockquote::before{display:none}
.quoteblock.abstract blockquote,.quoteblock.abstract p,.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{line-height:1.6;word-spacing:0}
.quoteblock.abstract{margin:0 1em 1.25em;display:block}
.quoteblock.abstract>.title{margin:0 0 .375em;font-size:1.15em;text-align:center}
.quoteblock.excerpt,.quoteblock .quoteblock{margin:0 0 1.25em;padding:0 0 .25em 1em;border-left:.25em solid #dddddf}
.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{color:inherit;font-size:1.0625rem}
.quoteblock.excerpt .attribution,.quoteblock .quoteblock .attribution{color:inherit;text-align:left;margin-right:0}
table.tableblock{max-width:100%;border-collapse:separate}
p.tableblock:last-child{margin-bottom:0}
td.tableblock>.content{margin-bottom:-1.25em}
table.tableblock,th.tableblock,td.tableblock{border:0 solid #dedede}
table.grid-all>thead>tr>.tableblock,table.grid-all>tbody>tr>.tableblock{border-width:0 1px 1px 0}
table.grid-all>tfoot>tr>.tableblock{border-width:1px 1px 0 0}
table.grid-cols>*>tr>.tableblock{border-width:0 1px 0 0}
table.grid-rows>thead>tr>.tableblock,table.grid-rows>tbody>tr>.tableblock{border-width:0 0 1px}
table.grid-rows>tfoot>tr>.tableblock{border-width:1px 0 0}
table.grid-all>*>tr>.tableblock:last-child,table.grid-cols>*>tr>.tableblock:last-child{border-right-width:0}
table.grid-all>tbody>tr:last-child>.tableblock,table.grid-all>thead:last-child>tr>.tableblock,table.grid-rows>tbody>tr:last-child>.tableblock,table.grid-rows>thead:last-child>tr>.tableblock{border-bottom-width:0}
table.frame-all{border-width:1px}
table.frame-sides{border-width:0 1px}
table.frame-topbot,table.frame-ends{border-width:1px 0}
table.stripes-all tr,table.stripes-odd tr:nth-of-type(odd){background:#f8f8f7}
table.stripes-none tr,table.stripes-odd tr:nth-of-type(even){background:none}
th.halign-left,td.halign-left{text-align:left}
th.halign-right,td.halign-right{text-align:right}
th.halign-center,td.halign-center{text-align:center}
th.valign-top,td.valign-top{vertical-align:top}
th.valign-bottom,td.valign-bottom{vertical-align:bottom}
th.valign-middle,td.valign-middle{vertical-align:middle}
table thead th,table tfoot th{font-weight:bold}
tbody tr th{display:table-cell;line-height:1.6;background:#f7f8f7}
tbody tr th,tbody tr th p,tfoot tr th,tfoot tr th p{color:rgba(0,0,0,.8);font-weight:bold}
p.tableblock>code:only-child{background:none;padding:0}
p.tableblock{font-size:1em}
td>div.verse{white-space:pre}
ol{margin-left:1.75em}
ul li ol{margin-left:1.5em}
dl dd{margin-left:1.125em}
dl dd:last-child,dl dd:last-child>:last-child{margin-bottom:0}
ol>li p,ul>li p,ul dd,ol dd,.olist .olist,.ulist .ulist,.ulist .olist,.olist .ulist{margin-bottom:.625em}
ul.checklist,ul.none,ol.none,ul.no-bullet,ol.no-bullet,ol.unnumbered,ul.unstyled,ol.unstyled{list-style-type:none}
ul.no-bullet,ol.no-bullet,ol.unnumbered{margin-left:.625em}
ul.unstyled,ol.unstyled{margin-left:0}
ul.checklist{margin-left:.625em}
ul.checklist li>p:first-child>.fa-square-o:first-child,ul.checklist li>p:first-child>.fa-check-square-o:first-child{width:1.25em;font-size:.8em;position:relative;bottom:.125em}
ul.checklist li>p:first-child>input[type="checkbox"]:first-child{margin-right:.25em}
ul.inline{display:-ms-flexbox;display:-webkit-box;display:flex;-ms-flex-flow:row wrap;-webkit-flex-flow:row wrap;flex-flow:row wrap;list-style:none;margin:0 0 .625em -1.25em}
ul.inline>li{margin-left:1.25em}
.unstyled dl dt{font-weight:400;font-style:normal}
ol.arabic{list-style-type:decimal}
ol.decimal{list-style-type:decimal-leading-zero}
ol.loweralpha{list-style-type:lower-alpha}
ol.upperalpha{list-style-type:upper-alpha}
ol.lowerroman{list-style-type:lower-roman}
ol.upperroman{list-style-type:upper-roman}
ol.lowergreek{list-style-type:lower-greek}
.hdlist>table,.colist>table{border:0;background:none}
.hdlist>table>tbody>tr,.colist>table>tbody>tr{background:none}
td.hdlist1,td.hdlist2{vertical-align:top;padding:0 .625em}
td.hdlist1{font-weight:bold;padding-bottom:1.25em}
.literalblock+.colist,.listingblock+.colist{margin-top:-.5em}
.colist td:not([class]):first-child{padding:.4em .75em 0;line-height:1;vertical-align:top}
.colist td:not([class]):first-child img{max-width:none}
.colist td:not([class]):last-child{padding:.25em 0}
.thumb,.th{line-height:0;display:inline-block;border:solid 4px #fff;-webkit-box-shadow:0 0 0 1px #ddd;box-shadow:0 0 0 1px #ddd}
.imageblock.left{margin:.25em .625em 1.25em 0}
.imageblock.right{margin:.25em 0 1.25em .625em}
.imageblock>.title{margin-bottom:0}
.imageblock.thumb,.imageblock.th{border-width:6px}
.imageblock.thumb>.title,.imageblock.th>.title{padding:0 .125em}
.image.left,.image.right{margin-top:.25em;margin-bottom:.25em;display:inline-block;line-height:0}
.image.left{margin-right:.625em}
.image.right{margin-left:.625em}
a.image{text-decoration:none;display:inline-block}
a.image object{pointer-events:none}
sup.footnote,sup.footnoteref{font-size:.875em;position:static;vertical-align:super}
sup.footnote a,sup.footnoteref a{text-decoration:none}
sup.footnote a:active,sup.footnoteref a:active{text-decoration:underline}
#footnotes{padding-top:.75em;padding-bottom:.75em;margin-bottom:.625em}
#footnotes hr{width:20%;min-width:6.25em;margin:-.25em 0 .75em;border-width:1px 0 0}
#footnotes .footnote{padding:0 .375em 0 .225em;line-height:1.3334;font-size:.875em;margin-left:1.2em;margin-bottom:.2em}
#footnotes .footnote a:first-of-type{font-weight:bold;text-decoration:none;margin-left:-1.05em}
#footnotes .footnote:last-of-type{margin-bottom:0}
#content #footnotes{margin-top:-.625em;margin-bottom:0;padding:.75em 0}
.gist .file-data>table{border:0;background:#fff;width:100%;margin-bottom:0}
.gist .file-data>table td.line-data{width:99%}
div.unbreakable{page-break-inside:avoid}
.big{font-size:larger}
.small{font-size:smaller}
.underline{text-decoration:underline}
.overline{text-decoration:overline}
.line-through{text-decoration:line-through}
.aqua{color:#00bfbf}
.aqua-background{background-color:#00fafa}
.black{color:#000}
.black-background{background-color:#000}
.blue{color:#0000bf}
.blue-background{background-color:#0000fa}
.fuchsia{color:#bf00bf}
.fuchsia-background{background-color:#fa00fa}
.gray{color:#606060}
.gray-background{background-color:#7d7d7d}
.green{color:#006000}
.green-background{background-color:#007d00}
.lime{color:#00bf00}
.lime-background{background-color:#00fa00}
.maroon{color:#600000}
.maroon-background{background-color:#7d0000}
.navy{color:#000060}
.navy-background{background-color:#00007d}
.olive{color:#606000}
.olive-background{background-color:#7d7d00}
.purple{color:#600060}
.purple-background{background-color:#7d007d}
.red{color:#bf0000}
.red-background{background-color:#fa0000}
.silver{color:#909090}
.silver-background{background-color:#bcbcbc}
.teal{color:#006060}
.teal-background{background-color:#007d7d}
.white{color:#bfbfbf}
.white-background{background-color:#fafafa}
.yellow{color:#bfbf00}
.yellow-background{background-color:#fafa00}
span.icon>.fa{cursor:default}
a span.icon>.fa{cursor:inherit}
.admonitionblock td.icon [class^="fa icon-"]{font-size:2.5em;text-shadow:1px 1px 2px rgba(0,0,0,.5);cursor:default}
.admonitionblock td.icon .icon-note::before{content:"\f05a";color:#19407c}
.admonitionblock td.icon .icon-tip::before{content:"\f0eb";text-shadow:1px 1px 2px rgba(155,155,0,.8);color:#111}
.admonitionblock td.icon .icon-warning::before{content:"\f071";color:#bf6900}
.admonitionblock td.icon .icon-caution::before{content:"\f06d";color:#bf3400}
.admonitionblock td.icon .icon-important::before{content:"\f06a";color:#bf0000}
.conum[data-value]{display:inline-block;color:#fff!important;background-color:rgba(0,0,0,.8);-webkit-border-radius:100px;border-radius:100px;text-align:center;font-size:.75em;width:1.67em;height:1.67em;line-height:1.67em;font-family:"Open Sans","DejaVu Sans",sans-serif;font-style:normal;font-weight:bold}
.conum[data-value] *{color:#fff!important}
.conum[data-value]+b{display:none}
.conum[data-value]::after{content:attr(data-value)}
pre .conum[data-value]{position:relative;top:-.125em}
b.conum *{color:inherit!important}
.conum:not([data-value]):empty{display:none}
dt,th.tableblock,td.content,div.footnote{text-rendering:optimizeLegibility}
h1,h2,p,td.content,span.alt{letter-spacing:-.01em}
p strong,td.content strong,div.footnote strong{letter-spacing:-.005em}
p,blockquote,dt,td.content,span.alt{font-size:1.0625rem}
p{margin-bottom:1.25rem}
.sidebarblock p,.sidebarblock dt,.sidebarblock td.content,p.tableblock{font-size:1em}
.exampleblock>.content{background-color:#fffef7;border-color:#e0e0dc;-webkit-box-shadow:0 1px 4px #e0e0dc;box-shadow:0 1px 4px #e0e0dc}
.print-only{display:none!important}
@page{margin:1.25cm .75cm}
@media print{*{-webkit-box-shadow:none!important;box-shadow:none!important;text-shadow:none!important}
html{font-size:80%}
a{color:inherit!important;text-decoration:underline!important}
a.bare,a[href^="#"],a[href^="mailto:"]{text-decoration:none!important}
a[href^="http:"]:not(.bare)::after,a[href^="https:"]:not(.bare)::after{content:"(" attr(href) ")";display:inline-block;font-size:.875em;padding-left:.25em}
abbr[title]::after{content:" (" attr(title) ")"}
pre,blockquote,tr,img,object,svg{page-break-inside:avoid}
thead{display:table-header-group}
svg{max-width:100%}
p,blockquote,dt,td.content{font-size:1em;orphans:3;widows:3}
h2,h3,#toctitle,.sidebarblock>.content>.title{page-break-after:avoid}
#toc,.sidebarblock,.exampleblock>.content{background:none!important}
#toc{border-bottom:1px solid #dddddf!important;padding-bottom:0!important}
body.book #header{text-align:center}
body.book #header>h1:first-child{border:0!important;margin:2.5em 0 1em}
body.book #header .details{border:0!important;display:block;padding:0!important}
body.book #header .details span:first-child{margin-left:0!important}
body.book #header .details br{display:block}
body.book #header .details br+span::before{content:none!important}
body.book #toc{border:0!important;text-align:left!important;padding:0!important;margin:0!important}
body.book #toc,body.book #preamble,body.book h1.sect0,body.book .sect1>h2{page-break-before:always}
.listingblock code[data-lang]::before{display:block}
#footer{padding:0 .9375em}
.hide-on-print{display:none!important}
.print-only{display:block!important}
.hide-for-print{display:none!important}
.show-for-print{display:inherit!important}}
@media print,amzn-kf8{#header>h1:first-child{margin-top:1.25rem}
.sect1{padding:0!important}
.sect1+.sect1{border:0}
#footer{background:none}
#footer-text{color:rgba(0,0,0,.6);font-size:.9em}}
@media amzn-kf8{#header,#content,#footnotes,#footer{padding:0}}
</style>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
<style>
/* Stylesheet for CodeRay to match GitHub theme | MIT License | http://foundation.zurb.com */
/*pre.CodeRay {background-color:#f7f7f8;}*/
.CodeRay .line-numbers{border-right:1px solid #d8d8d8;padding:0 0.5em 0 .25em}
.CodeRay span.line-numbers{display:inline-block;margin-right:.5em;color:rgba(0,0,0,.3)}
.CodeRay .line-numbers strong{color:rgba(0,0,0,.4)}
table.CodeRay{border-collapse:separate;border-spacing:0;margin-bottom:0;border:0;background:none}
table.CodeRay td{vertical-align: top;line-height:1.45}
table.CodeRay td.line-numbers{text-align:right}
table.CodeRay td.line-numbers>pre{padding:0;color:rgba(0,0,0,.3)}
table.CodeRay td.code{padding:0 0 0 .5em}
table.CodeRay td.code>pre{padding:0}
.CodeRay .debug{color:#fff !important;background:#000080 !important}
.CodeRay .annotation{color:#007}
.CodeRay .attribute-name{color:#000080}
.CodeRay .attribute-value{color:#700}
.CodeRay .binary{color:#509}
.CodeRay .comment{color:#998;font-style:italic}
.CodeRay .char{color:#04d}
.CodeRay .char .content{color:#04d}
.CodeRay .char .delimiter{color:#039}
.CodeRay .class{color:#458;font-weight:bold}
.CodeRay .complex{color:#a08}
.CodeRay .constant,.CodeRay .predefined-constant{color:#008080}
.CodeRay .color{color:#099}
.CodeRay .class-variable{color:#369}
.CodeRay .decorator{color:#b0b}
.CodeRay .definition{color:#099}
.CodeRay .delimiter{color:#000}
.CodeRay .doc{color:#970}
.CodeRay .doctype{color:#34b}
.CodeRay .doc-string{color:#d42}
.CodeRay .escape{color:#666}
.CodeRay .entity{color:#800}
.CodeRay .error{color:#808}
.CodeRay .exception{color:inherit}
.CodeRay .filename{color:#099}
.CodeRay .function{color:#900;font-weight:bold}
.CodeRay .global-variable{color:#008080}
.CodeRay .hex{color:#058}
.CodeRay .integer,.CodeRay .float{color:#099}
.CodeRay .include{color:#555}
.CodeRay .inline{color:#000}
.CodeRay .inline .inline{background:#ccc}
.CodeRay .inline .inline .inline{background:#bbb}
.CodeRay .inline .inline-delimiter{color:#d14}
.CodeRay .inline-delimiter{color:#d14}
.CodeRay .important{color:#555;font-weight:bold}
.CodeRay .interpreted{color:#b2b}
.CodeRay .instance-variable{color:#008080}
.CodeRay .label{color:#970}
.CodeRay .local-variable{color:#963}
.CodeRay .octal{color:#40e}
.CodeRay .predefined{color:#369}
.CodeRay .preprocessor{color:#579}
.CodeRay .pseudo-class{color:#555}
.CodeRay .directive{font-weight:bold}
.CodeRay .type{font-weight:bold}
.CodeRay .predefined-type{color:inherit}
.CodeRay .reserved,.CodeRay .keyword {color:#000;font-weight:bold}
.CodeRay .key{color:#808}
.CodeRay .key .delimiter{color:#606}
.CodeRay .key .char{color:#80f}
.CodeRay .value{color:#088}
.CodeRay .regexp .delimiter{color:#808}
.CodeRay .regexp .content{color:#808}
.CodeRay .regexp .modifier{color:#808}
.CodeRay .regexp .char{color:#d14}
.CodeRay .regexp .function{color:#404;font-weight:bold}
.CodeRay .string{color:#d20}
.CodeRay .string .string .string{background:#ffd0d0}
.CodeRay .string .content{color:#d14}
.CodeRay .string .char{color:#d14}
.CodeRay .string .delimiter{color:#d14}
.CodeRay .shell{color:#d14}
.CodeRay .shell .delimiter{color:#d14}
.CodeRay .symbol{color:#990073}
.CodeRay .symbol .content{color:#a60}
.CodeRay .symbol .delimiter{color:#630}
.CodeRay .tag{color:#008080}
.CodeRay .tag-special{color:#d70}
.CodeRay .variable{color:#036}
.CodeRay .insert{background:#afa}
.CodeRay .delete{background:#faa}
.CodeRay .change{color:#aaf;background:#007}
.CodeRay .head{color:#f8f;background:#505}
.CodeRay .insert .insert{color:#080}
.CodeRay .delete .delete{color:#800}
.CodeRay .change .change{color:#66f}
.CodeRay .head .head{color:#f4f}
</style>
</head>
<body class="book toc2 toc-left">
<div id="header">
<h1>Gremlin中文文档</h1>
<div class="details">
<span id="author" class="author">阿里云GDB团队</span><br>
</div>
<div id="toc" class="toc2">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel0">
<li><a href="#traversal">图的遍历（Traversal）</a>
<ul class="sectlevel1">
<li><a href="#graph-traversal-steps">单步（Traversal-steps）</a>
<ul class="sectlevel2">
<li><a href="#general-steps">通用单步（抽象）</a></li>
<li><a href="#terminal-steps">结束性单步</a></li>
<li><a href="#addedge-step">AddEdge Step</a></li>
<li><a href="#addvertex-step">AddVertex Step</a></li>
<li><a href="#addproperty-step">AddProperty Step</a></li>
<li><a href="#aggregate-step">Aggregate Step</a></li>
<li><a href="#and-step">And Step</a></li>
<li><a href="#as-step">As Step</a></li>
<li><a href="#barrier-step">Barrier Step</a></li>
<li><a href="#by-step">By Step</a></li>
<li><a href="#cap-step">Cap Step</a></li>
<li><a href="#choose-step">Choose Step</a></li>
<li><a href="#coalesce-step">Coalesce Step</a></li>
<li><a href="#coin-step">Coin Step</a></li>
<li><a href="#connectedcomponent-step">ConnectedComponent Step</a></li>
<li><a href="#constant-step">Constant Step</a></li>
<li><a href="#count-step">Count Step</a></li>
<li><a href="#cyclicpath-step">CyclicPath Step</a></li>
<li><a href="#dedup-step">Dedup Step</a></li>
<li><a href="#drop-step">Drop Step</a></li>
<li><a href="#emit-step">Emit Step</a></li>
<li><a href="#explain-step">Explain Step</a></li>
<li><a href="#fold-step">Fold Step</a></li>
<li><a href="#from-step">From Step</a></li>
<li><a href="#graph-step">Graph Step</a></li>
<li><a href="#group-step">Group Step</a></li>
<li><a href="#groupcount-step">GroupCount Step</a></li>
<li><a href="#has-step">Has Step</a></li>
<li><a href="#id-step">Id Step</a></li>
<li><a href="#identity-step">Identity Step</a></li>
<li><a href="#index-step">Index Step</a></li>
<li><a href="#inject-step">Inject Step</a></li>
<li><a href="#io-step">IO Step</a></li>
<li><a href="#is-step">Is Step</a></li>
<li><a href="#key-step">Key Step</a></li>
<li><a href="#label-step">Label Step</a></li>
<li><a href="#limit-step">Limit Step</a></li>
<li><a href="#local-step">Local Step</a></li>
<li><a href="#loops-step">Loops Step</a></li>
<li><a href="#match-step">Match Step</a></li>
<li><a href="#math-step">Math Step</a></li>
<li><a href="#max-step">Max Step</a></li>
<li><a href="#mean-step">Mean Step</a></li>
<li><a href="#min-step">Min Step</a></li>
<li><a href="#none-step">None Step</a></li>
<li><a href="#not-step">Not Step</a></li>
<li><a href="#option-step">Option Step</a></li>
<li><a href="#optional-step">Optional Step</a></li>
<li><a href="#or-step">Or Step</a></li>
<li><a href="#order-step">Order Step</a></li>
<li><a href="#pagerank-step">PageRank Step</a></li>
<li><a href="#path-step">Path Step</a></li>
<li><a href="#peerpressure-step">PeerPressure Step</a></li>
<li><a href="#profile-step">Profile Step</a></li>
<li><a href="#project-step">Project Step</a></li>
<li><a href="#program-step">Program Step</a></li>
<li><a href="#properties-step">Properties Step</a></li>
<li><a href="#propertymap-step">PropertyMap Step</a></li>
<li><a href="#range-step">Range Step</a></li>
<li><a href="#repeat-step">Repeat Step</a></li>
<li><a href="#sack-step">Sack Step</a></li>
<li><a href="#sample-step">Sample Step</a></li>
<li><a href="#select-step">Select Step</a></li>
<li><a href="#shortestpath-step">ShortestPath step</a></li>
<li><a href="#simplepath-step">SimplePath Step</a></li>
<li><a href="#skip-step">Skip Step</a></li>
<li><a href="#store-step">Store Step</a></li>
<li><a href="#subgraph-step">Subgraph Step</a></li>
<li><a href="#sum-step">Sum Step</a></li>
<li><a href="#tail-step">Tail Step</a></li>
<li><a href="#timelimit-step">TimeLimit Step</a></li>
<li><a href="#to-step">To Step</a></li>
<li><a href="#tree-step">Tree Step</a></li>
<li><a href="#unfold-step">Unfold Step</a></li>
<li><a href="#union-step">Union Step</a></li>
<li><a href="#until-step">Until Step</a></li>
<li><a href="#value-step">Value Step</a></li>
<li><a href="#valuemap-step">ValueMap Step</a></li>
<li><a href="#values-step">Values Step</a></li>
<li><a href="#vertex-steps">Vertex Steps</a></li>
<li><a href="#where-step">Where Step</a></li>
<li><a href="#with-step">With Step</a></li>
</ul>
</li>
<li><a href="#a-note-on-predicates">Predicates介绍</a></li>
<li><a href="#a-note-on-barrier-steps">Barrier的解释</a></li>
<li><a href="#a-note-on-scopes">关于Scopes的说明</a></li>
<li><a href="#a-note-on-lambdas">Lambdas说明</a></li>
<li><a href="#traversalstrategy">TraversalStrategy</a>
<ul class="sectlevel2">
<li><a href="#elementidstrategy">ElementIdStrategy</a></li>
<li><a href="#eventstrategy">EventStrategy</a></li>
<li><a href="#partitionstrategy">PartitionStrategy</a></li>
<li><a href="#readonlystrategy">ReadOnlyStrategy</a></li>
<li><a href="#subgraphstrategy">SubgraphStrategy</a></li>
</ul>
</li>
<li><a href="#dsl">Domain Specific Languages</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="content">
<h1 id="traversal" class="sect0"><a class="anchor" href="#traversal"></a>图的遍历（Traversal）</h1>
<div class="openblock partintro">
<div class="content">
<div class="imageblock">
<div class="content">
<img src="./images/gremlin-running.png" alt="gremlin running" width="125">
</div>
</div>
<div class="paragraph">
<p>在顶层设计上，`Traversal&lt;S,E&gt;`是`Iterator&lt;E&gt;`接口的实现类，`S`和`E`代表着出发点和结束。图的遍历（Traversal）有四种基本类型：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><code>Step&lt;S,E&gt;</code>：单步(Step)。一个从开始（<code>S</code>）向结束（<code>E</code>）遍历过程中的一个独立的函数，一次图的遍历由很多单步游走连接而成</p>
</li>
<li>
<p><code>TraversalStrategy</code>：拦截器（interceptor）方法，用户更换遍历的执行步骤（比如，拦截并重写查询的方式）</p>
</li>
<li>
<p><code>TraversalSideEffects</code>：一个键值对（key/value pairs），用于存储图的遍历中的全局信息</p>
</li>
<li>
<p><code>Traverser&lt;T&gt;</code>：在当前遍历中生成的类型为`T`的对象</p>
</li>
</ol>
</div>
<div class="paragraph">
<p><code>GraphTraversal&lt;S,E&gt;</code> 是图遍历的一个经典实现，它继承自 <code>Traversal&lt;S,E&gt;</code> 类。
<code>GraphTraversal</code> 提供了一个图内部数据（包含顶点，边等）组织方式的深层次解释和实现，和由此而来的图的遍历 <a href="http://en.wikipedia.org/wiki/Domain-specific_language">DSL</a></p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
在TinkerPop的实现里，大量单步（<code>Step</code>）的实现已经可以满足DSL使用者的绝大多数的需要。
DSL使用者也可以充分利用这些已经实现好的单步，来优化遍历策略或者将其作为优化策略的装饰类，来调整图遍历的策略顺序。
值得注意的是，如果新的“单步”被引入，整个图的遍历策略可能会工作的不正常，或者不正确
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="graph-traversal-steps"><a class="anchor" href="#graph-traversal-steps"></a>单步（Traversal-steps）</h2>
<div class="sectionbody">
<div class="imageblock">
<div class="content">
<img src="./images/step-types.png" alt="step types" width="650">
</div>
</div>
<div class="paragraph">
<p><code>GraphTraversalSource</code>（遍历实现）生成一个 <code>GraphTraversal &lt;S，E&gt;</code> 。
同样作为匿名 <code>__</code>（另外一种Traversal的实现，空实现）也可以生成一个 <code>GraphTraversal &lt;S，E&gt;</code> 。
一次图的遍历是由一组单步组成的。
所有 <code>GraphTraversal</code> 提供的单步都可以认为继承自上图的几种基本类型。
Tinkerpop提供的所有单步可以在 <a href="http://tinkerpop.apache.org/javadocs/3.4.1/core/org/apache/tinkerpop/gremlin/process/traversal/dsl/graph/GraphTraversal.html">GraphTraversal JavaDoc</a> 查到。
以下的章节将使用<a href="#gremlin-console">Gremlin Console</a>，展示GraphTraversal提供的标准单步，</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
开始一个最基本的图的遍历已经在<a href="#the-graph-process">The Graph Process</a> 这章描述了，
也可以在<a href="http://tinkerpop.apache.org/docs/current/tutorials/getting-started/">Getting Started</a> 查到
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
简单点的话，可以直接引入： <code>+import static org.apache.tinkerpop.gremlin.process.traversal.dsl.graph.__.*+</code> ，
这样，匿名的遍历就可以直接写 <code>inE()</code>，不用再调用 <code>+__.inE()+</code> 这样了。
但是需要注意有些语言里关键字的冲突，如在Groovy中，<code>in</code> 和 <code>as</code> 是关键字，所以就得使用复杂语义 <code>+__.in()+</code> 和 <code>+__.as()+</code>。
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
【中文添加，方便读者理解】<code>GraphTraversal &lt;S，E&gt;</code> 是一个接口类，提供了所有单步的接口。
而每一个接口又大都返回一个 <code>GraphTraversal &lt;S，E&gt;</code>，这样就可以把整个遍历连接起来。
这更像是一个流处理的流程，熟悉函数式程序设计也可以按此思考方式掌握
</td>
</tr>
</table>
</div>
<div class="sect2">
<h3 id="general-steps"><a class="anchor" href="#general-steps"></a>通用单步（抽象）</h3>
<div class="paragraph">
<p>一共有5种通用的单步（general-step），每个都有遍历功能或者使用lambda的表现形式（Traversal Representation后称为 <code>形式遍历</code>  ）。其他的单步都是这些 <code>形式遍历</code> 的扩展，见后文</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 45.4545%;">
<col style="width: 54.5455%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Step</th>
<th class="tableblock halign-left valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>map(Traversal&lt;S, E&gt;)</code>  <code>map(Function&lt;Traverser&lt;S&gt;, E&gt;)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">映射（map）遍历到类型为 <code>E</code> 的对象，用于下步处理</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>flatMap(Traversal&lt;S, E&gt;)</code>  <code>flatMap(Function&lt;Traverser&lt;S&gt;, Iterator&lt;E&gt;&gt;)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">映射（map）遍历到类型为 <code>E</code> 的迭代器（Iterator），流式的传递到下一步</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>filter(Traversal&lt;?, ?&gt;)</code>  <code>filter(Predicate&lt;Traverser&lt;S&gt;&gt;)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">映射（map）遍历为true或者false，其中如果结果是false的，就不会传递到下一步</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>sideEffect(Traversal&lt;S, S&gt;)</code>  <code>sideEffect(Consumer&lt;Traverser&lt;S&gt;&gt;)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">在遍历上做一些操作，并且传递到下一步</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>branch(Traversal&lt;S, M&gt;)</code>  <code>branch(Function&lt;Traverser&lt;S&gt;,M&gt;)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">将遍历分拆成多个遍历，这些遍历都以按照 <code>M</code> 标记（token）被索引到</p></td>
</tr>
</tbody>
</table>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
文中Lambda（单步中使用lambda）的展示是以教育和引导为目的，主要用于解释Gremlin语言的基础构造。
在实践中，应当在遍历的描述和遍历的验证策略中避免使用Lambda。当然除非显式的声明"turned off"，Lambda是仍旧生效的。
关于更多的Lambda在使用中的问题，请阅读 <a href="#a-note-on-lambdas">A Note on Lambdas</a> 章节
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
【中文添加，方便读者理解】<code>形式遍历</code> （Traversal Representation）就是一种单步的规则的抽象，更类似函数式编程中functor的概念。
在一般的单步中，很多都可以传入一个Lambda或者functor（如Predictable），或者依赖一个迭代器（Iterator），非常类似高阶函数。
在Tinkerpop后面的提供的很多 <code>单步</code> 都属于 一种或者多种 <code>形式遍历</code>。可以认为是功能上的一种归纳或者抽象。
但在tinkerpop具体实现中并不是依赖接口继承关系的。之所以引入 <code>形式遍历</code> 这个名词是作为习语帮助理解
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code>Traverser&lt;S&gt;</code> 对象提供：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>当前遍历 <code>S</code> 对象（开始）&#8201;&#8212;&#8201;<code>Traverser.get()</code></p>
</li>
<li>
<p>当前遍历器遍历过的路径&#8201;&#8212;&#8201;<code>Traverser.path()</code></p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p>辅助理解：获取指定历史路径&#8201;&#8212;&#8201;<code>Traverser.path(String) == Traverser.path().get(String)</code></p>
</li>
</ol>
</div>
</li>
<li>
<p>获取遍历器当前循环的次数&#8201;&#8212;&#8201;<code>Traverser.loops()</code></p>
</li>
<li>
<p>遍历器中维护的对象的个数&#8201;&#8212;&#8201;<code>Traverser.bulk()</code></p>
</li>
<li>
<p>遍历器相关联的局部数据结构&#8201;&#8212;&#8201;<code>Traverser.sack()</code></p>
</li>
<li>
<p>遍历器相关联的side-effects&#8201;&#8212;&#8201;<code>Traverser.sideEffects()</code>.</p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p>辅助理解：获取一个指定的side-effect&#8201;&#8212;&#8201;<code>Traverser.path(String) == Traverser.path().get(String)</code></p>
</li>
</ol>
</div>
</li>
</ol>
</div>
<div class="imageblock">
<div class="content">
<img src="./images/map-lambda.png" alt="map lambda" width="150">
</div>
</div>
<div class="listingblock">
<div class="content">
<pre>g.V(1).out().values('name') <i class="conum" data-value="1"></i><b>(1)</b>
g.V(1).out().map {it.get().value('name')} <i class="conum" data-value="2"></i><b>(2)</b>
g.V(1).out().map(values('name')) <i class="conum" data-value="3"></i><b>(3)</b></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>一次从顶点1向外向（从顶点1沿外向边进行一步游走）的获取相邻接点name的遍历</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>相同的操作，使用Lambda来获取name属性值</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>使用 <code>map()</code> 的相同操作的 <code>形式遍历</code></td>
</tr>
</table>
</div>
<div class="imageblock">
<div class="content">
<img src="./images/filter-lambda.png" alt="filter lambda" width="160">
</div>
</div>
<div class="listingblock">
<div class="content">
<pre>g.V().filter {it.get().label() == 'person'} <i class="conum" data-value="1"></i><b>(1)</b>
g.V().filter(label().is('person')) <i class="conum" data-value="2"></i><b>(2)</b>
g.V().hasLabel('person') <i class="conum" data-value="3"></i><b>(3)</b></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>一个过滤器（filter）操作，过滤条件是顶点的标签是"person"</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>相同的操作，使用 <code>filter()</code> 作为 <code>形式遍历</code></td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>更加特殊的 <code>has()</code> 单步： 是 <code>filter()</code> 加上一个描述性谓词的实现</td>
</tr>
</table>
</div>
<div class="imageblock">
<div class="content">
<img src="./images/side-effect-lambda.png" alt="side effect lambda" width="175">
</div>
</div>
<div class="listingblock">
<div class="content">
<pre>g.V().hasLabel('person').sideEffect(System.out.&amp;println) <i class="conum" data-value="1"></i><b>(1)</b>
g.V().sideEffect(outE().count().store("o")).
      sideEffect(inE().count().store("i")).cap("o","i") <i class="conum" data-value="2"></i><b>(2)</b></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>任何进入 <code>sideEffect()</code> 并到下一步的间隔中，其他的事情（副作用）可能发生</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>对于每个顶点计算 <code>入度</code>（in-degree，入边的数目） 和 <code>出度</code>（out-degree，出边的数目），这两个统计数字的 <code>sideEffect()</code> 都赋给了相同的顶点</td>
</tr>
</table>
</div>
<div class="imageblock">
<div class="content">
<img src="./images/branch-lambda.png" alt="branch lambda" width="180">
</div>
</div>
<div class="listingblock">
<div class="content">
<pre>g.V().branch {it.get().value('name')}.
      option('marko', values('age')).
      option(none, values('name')) <i class="conum" data-value="1"></i><b>(1)</b>
g.V().branch(values('name')).
      option('marko', values('age')).
      option(none, values('name')) <i class="conum" data-value="2"></i><b>(2)</b>
g.V().choose(has('name','marko'),
             values('age'),
             values('name')) <i class="conum" data-value="3"></i><b>(3)</b></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>遍历图，如果顶点name是"marko"，得到他的age，否则获取其他顶点的name</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>相同的操作，但是使用 <code>branch()</code> 这个 <code>形式遍历</code></td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>更特殊的true/false判断：<code>choose()</code> 单步是一个具体的 <code>branch()</code> 的实现</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="terminal-steps"><a class="anchor" href="#terminal-steps"></a>结束性单步</h3>
<div class="paragraph">
<p>一般来说, 每一个单步接受一个遍历对象，返回执行后的遍历对象结果，所以下一个单步操作同样使用这个遍历结果，再次返回一个遍历结果。
这样图的遍历过程就能如<a href="https://en.wikipedia.org/wiki/Fluent_interface">流式接口</a>, <a href="https://en.wikipedia.org/wiki/Monoid">幺半群运算</a>这样的方式持续进行下去。
但是，有一些单步操作不返回遍历对象，而是执行遍历并返回一个结果（类型不同或者不可迭代，所以遍历没法继续，从而终止）。
这些特殊的单步游就叫做 <code>结束性单步</code> （Terminal Steps），以下是一些例子</p>
</div>
<div class="listingblock">
<div class="content">
<pre>g.V().out('created').hasNext() <i class="conum" data-value="1"></i><b>(1)</b>
g.V().out('created').next() <i class="conum" data-value="2"></i><b>(2)</b>
g.V().out('created').next(2) <i class="conum" data-value="3"></i><b>(3)</b>
g.V().out('nothing').tryNext() <i class="conum" data-value="4"></i><b>(4)</b>
g.V().out('created').toList() <i class="conum" data-value="5"></i><b>(5)</b>
g.V().out('created').toSet() <i class="conum" data-value="6"></i><b>(6)</b>
g.V().out('created').toBulkSet() <i class="conum" data-value="7"></i><b>(7)</b>
results = ['blah',3]
g.V().out('created').fill(results) <i class="conum" data-value="8"></i><b>(8)</b>
g.addV('person').iterate() <i class="conum" data-value="9"></i><b>(9)</b></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><code>hasNext()</code> 判断结果是否可用（<code>gremlin-javascript</code> 不支持）</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td><code>next()</code> 将返回下一个结果</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td><code>next(n)</code> 将返回后面 <code>n</code> 个结果返回一个List（<code>gremlin-javascript</code> 和 Gremlin.NET 不支持）</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td><code>tryNext()</code> 返回一个 <code>Optional</code>；因此，它是一个 <code>hasNext()</code>/<code>next()</code> 的组合 （只支持 JVM 相关的语言）</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td><code>toList()</code> 返回所有的结果到一个List中</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td><code>toSet()</code> 返回所有结果到一个Set里，因此具备排重功能（<code>gremlin-javascript</code> 不支持）</td>
</tr>
<tr>
<td><i class="conum" data-value="7"></i><b>7</b></td>
<td><code>toBulkSet()</code> 返回所有结果到一个带权重的集合（Weighted Set）里，具备同权重的排重功能，不同权重的相同元素将被保留（只支持 JVM 相关的语言）</td>
</tr>
<tr>
<td><i class="conum" data-value="8"></i><b>8</b></td>
<td><code>fill(collection)</code> 将所有的返回结果放到一个提供的Collection中，当结果完全后返回此collection（只支持 JVM 相关的语言）</td>
</tr>
<tr>
<td><i class="conum" data-value="9"></i><b>9</b></td>
<td><code>iterate()</code> 并不完全符合 <code>结束性单步</code> 不返回（可迭代）结果的定义，
因为它返回一个遍历的执行——而它的表象更像是 <code>结束性单步</code> ：进行一次遍历迭代，生成“副作用”而非真正返回值</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code>promise()</code> 也是一个 <code>结束性单步</code>，它只用来执行到<a href="#connecting-gremlin-server">Gremlin Server</a> 或者 <a href="#connecting-rgp">RGPs</a>的远端遍历。
它承诺（promise）在当前遍历 <code>Traversal</code> 的执行在将来（future）会完成</p>
</div>
<div class="paragraph">
<p>最后，<a href="#explain-step"><code>explain()</code></a> 单步也是一个 <code>结束性单步</code>，请看后续章节描述</p>
</div>
</div>
<div class="sect2">
<h3 id="addedge-step"><a class="anchor" href="#addedge-step"></a>AddEdge Step</h3>
<div class="paragraph">
<p><a href="http://en.wikipedia.org/wiki/Automated_reasoning">自动推理</a> 实际上是将数据中隐式的关系显式化的过程。
在图里面，所谓（数据）已经显式的东西就是图中的对象，比如顶点和边。图中“隐式”的关系体现在图的遍历执行过程中。
换句话说，图的遍历过程揭示的意义（关系），由本遍历定义（的操作）来决定。
举例说明：拿“协同开发者”（co-developer）的定义来说，两个工作在一个工程项目的人就可以称为“协同开发者”。
这个定义就可以定义一个遍历过程来表示（用图遍历语句就可以关联两个人是“协同开发者”co-developer的关系），
同样，这种“协同开发者”的定义同样可以被继承和演绎（到更高抽象层面）。
再多说一句，通过 <code>addE()</code> 这个操作，就可以把这个过去隐式的关系显性化。</p>
</div>
<div class="paragraph">
<p><code>addE()</code> 这个单步可能属于(<strong>map</strong>/<strong>sideEffect</strong>) 两种 <code>形式遍历</code> 之一 ，后续文档用 <code>addE()</code> (<strong>map</strong>/<strong>sideEffect</strong>) 表示</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
【中文添加，方便读者理解】<code>Traversal</code> 本身在tinkerpop文档里非常抽象，Traversal本身直面翻译代表着遍历，和图的遍历。
首先来讲，Traversal“遍历”并不是在图中从头到尾走一遍，它具体代表了在图中游走或者操作的一串流程。
比如 <code>Traverser&lt;S&gt;, E&gt;</code> 就比较清楚的代表了S到E的一个遍历器。
因为 <code>addE()</code> 这个单步，本身属于图中流程和游走的一部分，按规则添加一条边，返回一个Traversal串式链接给后续Traversal使用。
Tinkerpop文档中的 <code>Traversal</code> 更加广义，需要注意
</td>
</tr>
</table>
</div>
<div class="imageblock">
<div class="content">
<img src="./images/addedge-step.png" alt="addedge step" width="450">
</div>
</div>
<div class="listingblock">
<div class="content">
<pre>g.V(1).as('a').out('created').in('created').where(neq('a')).
  addE('co-developer').from('a').property('year',2009) <i class="conum" data-value="1"></i><b>(1)</b>
g.V(3,4,5).aggregate('x').has('name','josh').as('a').
  select('x').unfold().hasLabel('software').addE('createdBy').to('a') <i class="conum" data-value="2"></i><b>(2)</b>
g.V().as('a').out('created').addE('createdBy').to('a').property('acl','public') <i class="conum" data-value="3"></i><b>(3)</b>
g.V(1).as('a').out('knows').
  addE('livesNear').from('a').property('year',2009).
  inV().inE('livesNear').values('year') <i class="conum" data-value="4"></i><b>(4)</b>
g.V().match(
        __.as('a').out('knows').as('b'),
        __.as('a').out('created').as('c'),
        __.as('b').out('created').as('c')).
      addE('friendlyCollaborator').from('a').to('b').
        property(id,23).property('project',select('c').values('name')) <i class="conum" data-value="5"></i><b>(5)</b>
g.E(23).valueMap()
marko = g.V().has('name','marko').next()
peter = g.V().has('name','peter').next()
g.V(marko).addE('knows').to(peter) <i class="conum" data-value="6"></i><b>(6)</b>
g.addE('knows').from(marko).to(peter) <i class="conum" data-value="7"></i><b>(7)</b></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>在marko和他的同伴中间，增加一条带着年份属性（year-property）的“co-developer”边（注意是双向的）</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>接下来从lop和ripple顶点增加createdBy的入向边到josh顶点</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>向所有的created的边，增加一条createdBy的反向边</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>新创建的边是一个可遍历对象</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>遍历过程中任意两个绑定可以用 <code>from()</code>&#8594;<code>to()</code> 来连接,  <code>id</code> 可以用于让用户传入相应的id</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>直接使用引用顶点的方式，从marko到peter添加一条边</td>
</tr>
<tr>
<td><i class="conum" data-value="7"></i><b>7</b></td>
<td>直接使用引用顶点的方式，从marko到peter添加一条边</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><strong>更多参考</strong></p>
</div>
<div class="paragraph">
<p><a href="http://tinkerpop.apache.org/javadocs/3.4.1/core/org/apache/tinkerpop/gremlin/process/traversal/dsl/graph/GraphTraversal.html#addE-java.lang.String-"><code>addE(String)</code></a>,
<a href="http://tinkerpop.apache.org/javadocs/3.4.1/core/org/apache/tinkerpop/gremlin/process/traversal/dsl/graph/GraphTraversal.html#addE-org.apache.tinkerpop.gremlin.process.traversal.Traversal-"><code>addE(Traversal)</code></a></p>
</div>
</div>
<div class="sect2">
<h3 id="addvertex-step"><a class="anchor" href="#addvertex-step"></a>AddVertex Step</h3>
<div class="paragraph">
<p><code>addV()</code> (<strong>map</strong>/<strong>sideEffect</strong>) 用于给图添加顶点。每传入一个对象，就会创建一个顶点。
另外，<code>GraphTraversalSource</code> 的实现中维护着 <code>addV()</code> 方法.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>g.addV('person').property('name','stephen')
g.V().values('name')
g.V().outE('knows').addV().property('name','nothing')
g.V().has('name','nothing')
g.V().has('name','nothing').bothE()</pre>
</div>
</div>
<div class="paragraph">
<p><strong>更多参考</strong></p>
</div>
<div class="paragraph">
<p><a href="http://tinkerpop.apache.org/javadocs/3.4.1/core/org/apache/tinkerpop/gremlin/process/traversal/dsl/graph/GraphTraversal.html#addV--"><code>addV()</code></a>,
<a href="http://tinkerpop.apache.org/javadocs/3.4.1/core/org/apache/tinkerpop/gremlin/process/traversal/dsl/graph/GraphTraversal.html#addV-java.lang.String-"><code>addV(String)</code></a>,
<a href="http://tinkerpop.apache.org/javadocs/3.4.1/core/org/apache/tinkerpop/gremlin/process/traversal/dsl/graph/GraphTraversal.html#addV-org.apache.tinkerpop.gremlin.process.traversal.Traversal-"><code>addV(Traversal)</code></a></p>
</div>
</div>
<div class="sect2">
<h3 id="addproperty-step"><a class="anchor" href="#addproperty-step"></a>AddProperty Step</h3>
<div class="paragraph">
<p><code>property()</code> (<strong>sideEffect</strong>) 单步用于给图的基本元素添加属性。
与 <code>addV()</code> 和 <code>addE()</code> 不同，<code>property()</code> 一定是sideEffect的一个单步，它并不返回创建的属性，而是返回流式传入给他的元素。
（所以是在遍历中做了一些操作，再把遍历传给后面的单步，属于sideEffect 这个形式遍历）。
另外，如果 <code>addV()</code> 或者 <code>addE()</code> 单步紧接着 <code>property()</code> 单步，这些单步会被“折叠”到顶点和边的创建阶段，同时创建所有的属性</p>
</div>
<div class="listingblock">
<div class="content">
<pre>g.V(1).property('country','usa')
g.V(1).property('city','santa fe').property('state','new mexico').valueMap()
g.V(1).property(list,'age',35)  <i class="conum" data-value="1"></i><b>(1)</b>
g.V(1).valueMap()
g.V(1).property('friendWeight',outE('knows').values('weight').sum(),'acl','private') <i class="conum" data-value="2"></i><b>(2)</b>
g.V(1).properties('friendWeight').valueMap() <i class="conum" data-value="3"></i><b>(3)</b></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>对顶点来说，可以进行属性标定： <a href="#vertex-properties">vertex properties</a>.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>在遍历中，可以选择属性的value，key也可以</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>对顶点来说，<code>property()</code> 单步可以添加元数据属性（meta-properties）</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><strong>更多参考</strong></p>
</div>
<div class="paragraph">
<p><a href="http://tinkerpop.apache.org/javadocs/3.4.1/core/org/apache/tinkerpop/gremlin/process/traversal/dsl/graph/GraphTraversal.html#property-java.lang.Object-java.lang.Object-java.lang.Object&#8230;&#8203;-"><code>property(Object, Object, Object...)</code></a>,
<a href="http://tinkerpop.apache.org/javadocs/3.4.1/core/org/apache/tinkerpop/gremlin/process/traversal/dsl/graph/GraphTraversal.html#property-org.apache.tinkerpop.gremlin.structure.VertexProperty.Cardinality-java.lang.Object-java.lang.Object-java.lang.Object&#8230;&#8203;-"><code>property(Cardinality, Object, Object, Object...)</code></a>,
<a href="http://tinkerpop.apache.org/javadocs/3.4.1/core/org/apache/tinkerpop/gremlin/structure/VertexProperty.Cardinality.html"><code>Cardinality</code></a></p>
</div>
</div>
<div class="sect2">
<h3 id="aggregate-step"><a class="anchor" href="#aggregate-step"></a>Aggregate Step</h3>
<div class="imageblock">
<div class="content">
<img src="./images/aggregate-step.png" alt="aggregate step" width="800">
</div>
</div>
<div class="paragraph">
<p><code>aggregate()</code>(<strong>sideEffect</strong>) 单步用于在遍历过程中一个特殊点上，将所有对象聚合成一个collection 。
直到所有之前的对象都被充分聚合完成，之后的遍历将没有对象的持续流入，此单步属于 <a href="http://en.wikipedia.org/wiki/Eager_evaluation">贪婪求值法</a> 。
这正好与 <a href="#store-step"><code>store()</code></a> 单步填充collection的 <a href="http://en.wikipedia.org/wiki/Lazy_evaluation">惰性求值</a> 的方式相反。
贪婪求值的特性对于一些场景十分关键，比如在某个特殊点上有将所有数据（聚合）进行下一步计算的需要。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>g.V(1).out('created') <i class="conum" data-value="1"></i><b>(1)</b>
g.V(1).out('created').aggregate('x') <i class="conum" data-value="2"></i><b>(2)</b>
g.V(1).out('created').aggregate('x').in('created') <i class="conum" data-value="3"></i><b>(3)</b>
g.V(1).out('created').aggregate('x').in('created').out('created') <i class="conum" data-value="4"></i><b>(4)</b>
g.V(1).out('created').aggregate('x').in('created').out('created').
       where(without('x')).values('name') <i class="conum" data-value="5"></i><b>(5)</b></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>marko created了什么？</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>将所有他created的聚合到x中</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>marko的协作者有谁？</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>marko的协作者created了什么东西？</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>marko的协作者created了什么marko自己没有created的东西？</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>在 <a href="http://en.wikipedia.org/wiki/Recommender_system">推荐系统中</a>，上述模式就经常被用到：</p>
</div>
<div class="literalblock">
<div class="content">
<pre>"用户A关注（like）什么？谁还关注这些东西？哪些是别人关注但是A还没关注的？"</pre>
</div>
</div>
<div class="paragraph">
<p>最后说一下，<code>aggregate()</code> 单步可以被 <code>by()</code> 这个调整单步来调整输出</p>
</div>
<div class="listingblock">
<div class="content">
<pre>g.V().out('knows').aggregate('x').cap('x')
g.V().out('knows').aggregate('x').by('name').cap('x')</pre>
</div>
</div>
<div class="paragraph">
<p><strong>更多参考</strong></p>
</div>
<div class="paragraph">
<p><a href="http://tinkerpop.apache.org/javadocs/3.4.1/core/org/apache/tinkerpop/gremlin/process/traversal/dsl/graph/GraphTraversal.html#aggregate-java.lang.String-"><code>aggregate(String)</code></a></p>
</div>
</div>
<div class="sect2">
<h3 id="and-step"><a class="anchor" href="#and-step"></a>And Step</h3>
<div class="paragraph">
<p><code>and()</code> (<strong>filter</strong>) 单步用于保证所有提供的遍历过程都产生结果，请对比看 <a href="#or-step"><code>or()</code></a> 的语义</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Python"></i>
</td>
<td class="content">
<div class="paragraph">
<p><code>and</code> 在Python中是保留字，所以在Gremlin要使用 <code>and_()</code></p>
</div>
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre>g.V().and(
   outE('knows'),
   values('age').is(lt(30))).
     values('name')</pre>
</div>
</div>
<div class="paragraph">
<p><code>and()</code> 单步可以传入不定长个数的遍历，但在这些遍历中，至少一个产生输出后才能让原来的遍历进入下一单步。</p>
</div>
<div class="paragraph">
<p>本身也可以当成 <a href="http://en.wikipedia.org/wiki/Infix_notation">中缀表示法</a> 的型式来使用</p>
</div>
<div class="listingblock">
<div class="content">
<pre>g.V().where(outE('created').and().outE('knows')).values('name')</pre>
</div>
</div>
<div class="paragraph">
<p><strong>更多参考</strong></p>
</div>
<div class="paragraph">
<p><a href="http://tinkerpop.apache.org/javadocs/3.4.1/core/org/apache/tinkerpop/gremlin/process/traversal/dsl/graph/GraphTraversal.html#and-org.apache.tinkerpop.gremlin.process.traversal.Traversal&#8230;&#8203;-"><code>and(Traversal...)</code></a></p>
</div>
</div>
<div class="sect2">
<h3 id="as-step"><a class="anchor" href="#as-step"></a>As Step</h3>
<div class="paragraph">
<p><code>as()</code> 单步并不是一个真正的单步执行操作，它更像是一个“调整步”（step modulator），类似<a href="#by-step"><code>by()</code></a> 和 <a href="#option-step"><code>option()</code></a>。
使用 <code>as()</code> 可以为一个单步提供标签，从而让后面的诸多单步和数据结构访问到。——比如 <a href="#select-step"><code>select()</code></a>， <a href="#match-step"><code>match()</code></a>, 和路径.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Groovy"></i>
</td>
<td class="content">
<div class="paragraph">
<p><code>as</code> 是Groovy的保留字，因此在Gremlin语法匿名遍历时需要使用 <code>__.as()</code>.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Python"></i>
</td>
<td class="content">
<div class="paragraph">
<p><code>as</code> 是Python的保留字，因此在Gremlin语法使用中要使用 <code>as_()</code></p>
</div>
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre>g.V().as('a').out('created').as('b').select('a','b')            <i class="conum" data-value="1"></i><b>(1)</b>
g.V().as('a').out('created').as('b').select('a','b').by('name') <i class="conum" data-value="2"></i><b>(2)</b></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>在路径中选取带有"a" 和 "b"标签的对象</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>在路径中选取带有"a" 和 "b"标签的对象，并且对于每个对象，投射name的值</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>一个单步可以有任意多个标签与其相关联。这在后面多步操作中通过标签引用这相同的一步很有用</p>
</div>
<div class="listingblock">
<div class="content">
<pre>g.V().hasLabel('software').as('a','b','c').
   select('a','b','c').
     by('name').
     by('lang').
     by(__.in('created').values('name').fold())</pre>
</div>
</div>
<div class="paragraph">
<p><strong>更多参考</strong></p>
</div>
<div class="paragraph">
<p><a href="http://tinkerpop.apache.org/javadocs/3.4.1/core/org/apache/tinkerpop/gremlin/process/traversal/dsl/graph/GraphTraversal.html#as-java.lang.String-java.lang.String&#8230;&#8203;-"><code>as(String,String...)</code></a></p>
</div>
</div>
<div class="sect2">
<h3 id="barrier-step"><a class="anchor" href="#barrier-step"></a>Barrier Step</h3>
<div class="paragraph">
<p><code>barrier()</code>(<strong>barrier</strong>) 单步将惰性（lazy）遍历的管道队列（pipeline）接到一个批量同步（bulk-synchronous）管道队列上。
这一步在以下场景下很有用：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>所有在 <code>barrier()</code> 前的要执行完后，才开始执行 <code>barrier()</code> 后面的，例如排序</p>
</li>
<li>
<p>相同的元素（elements）在执行中可能被多次涉及。因此，就可以“拖住”一个遍历，这样就可以做遍历的批量优化，诸如此例</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre>g.V().sideEffect{println "first: ${it}"}.sideEffect{println "second: ${it}"}.iterate()
g.V().sideEffect{println "first: ${it}"}.barrier().sideEffect{println "second: ${it}"}.iterate()</pre>
</div>
</div>
<div class="paragraph">
<p>“批量优化”背后的原理很简单。如果有一百万个在顶点1的遍历器，就需要计算一百万次 <code>both()</code> 单步。
然而，把这一百万次遍历映射为一个遍历器使用 <code>Traverser.bulk()</code> 一次就可以了。
批量优化的示例对于“大图”来说显著。因此下面的例子使用 <a href="#grateful-dead">Grateful Dead graph</a> （字面翻译为优雅渐亡图，指查询快速有效收敛）</p>
</div>
<div class="listingblock">
<div class="content">
<pre>graph = TinkerGraph.open()
g = graph.traversal()
g.io('data/grateful-dead.xml').read().iterate()
g = graph.traversal().withoutStrategies(LazyBarrierStrategy) <i class="conum" data-value="1"></i><b>(1)</b>
clockWithResult(1){g.V().both().both().both().count().next()} <i class="conum" data-value="2"></i><b>(2)</b>
clockWithResult(1){g.V().repeat(both()).times(3).count().next()} <i class="conum" data-value="3"></i><b>(3)</b>
clockWithResult(1){g.V().both().barrier().both().barrier().both().barrier().count().next()} <i class="conum" data-value="4"></i><b>(4)</b></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>显式的删除生成进行批量优化的 <code>LazyBarrierStrategy</code></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>一个非批量的遍历，每个遍历流程都被执行了</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>每一个进入的遍历都在批量递归</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>隐式的诸多遍历都没有被执行，只有一个批量的递归</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>如果 <code>barrier()</code> 被传入了一个数字参数（<code>n</code>），则barrier在这些遍历流程流入下一个单步前，只存放 <code>n</code> 个的独一无二（unique）的遍历过程。
这对于前面提到的批量优化的场景非常有用，可以减少由于高并行度遍历导致内存用光（Out-Of-Memory）的风险</p>
</div>
<div class="paragraph">
<p><code>LazyBarrierStrategy</code> 会在迭代过程中适当的地方插入 <code>barrier()</code> 来获得批量优化</p>
</div>
<div class="listingblock">
<div class="content">
<pre>graph = TinkerGraph.open()
g = graph.traversal()  <i class="conum" data-value="1"></i><b>(1)</b>
g.io('data/grateful-dead.xml').read().iterate()
clockWithResult(1){g.V().both().both().both().count().next()}
g.V().both().both().both().count().iterate().toString()  <i class="conum" data-value="2"></i><b>(2)</b></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><code>LazyBarrierStrategy</code> 是一个默认的策略，因此不需要显式的去激活它</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td><code>LazyBarrierStrategy</code> 激活后, <code>barrier()</code> 会在合适的地方自动被插入</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><strong>更多参考</strong></p>
</div>
<div class="paragraph">
<p><a href="http://tinkerpop.apache.org/javadocs/3.4.1/core/org/apache/tinkerpop/gremlin/process/traversal/dsl/graph/GraphTraversal.html#barrier--"><code>barrier()</code></a>,
<a href="http://tinkerpop.apache.org/javadocs/3.4.1/core/org/apache/tinkerpop/gremlin/process/traversal/dsl/graph/GraphTraversal.html#barrier-java.util.function.Consumer-"><code>barrier(Consumer)</code></a>,
<a href="http://tinkerpop.apache.org/javadocs/3.4.1/core/org/apache/tinkerpop/gremlin/process/traversal/dsl/graph/GraphTraversal.html#barrier-int-"><code>barrier(int)</code></a></p>
</div>
</div>
<div class="sect2">
<h3 id="by-step"><a class="anchor" href="#by-step"></a>By Step</h3>
<div class="paragraph">
<p><code>by()</code> 单步并不是一个真正的单步执行操作，它是一个“调整步”（step modulator），类似<a href="#as-step"><code>as()</code></a> 和 <a href="#option-step"><code>option()</code></a>。
如果一个单步可以接受遍历，函数（functions），比较器（comparators）等，
<code>by()</code> 就是用来告诉单步，这些（遍历，函数，比较器&#8230;&#8203;）是怎样被添加的。
最通用的形式就是 <code>step().by()...by()</code>。有一些单步只能够接受一个 <code>by()</code> ，也有一些单步可以接受任意个 <code>by()</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre>g.V().group().by(bothE().count()) <i class="conum" data-value="1"></i><b>(1)</b>
g.V().group().by(bothE().count()).by('name') <i class="conum" data-value="2"></i><b>(2)</b>
g.V().group().by(bothE().count()).by(count())  <i class="conum" data-value="3"></i><b>(3)</b></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><code>by(outE().count())</code> 将以元素的边的个数来分组，是一个遍历过程  (<strong>traversal</strong>).</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td><code>by('name')</code> 将获取这些已经分组好的元素的名字，是一个元素属性的投射 (<strong>element property projection</strong>).</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td><code>by(count())</code> 将计算每个分组中元素的个数，是一个遍历过程 (<strong>traversal</strong>).</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>下面的这些单步操作都支持 <code>by()</code> 调整（modulation）。注意每个调整的语义都需要一步一步理解，或者到解释它们的章节去了解</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#dedup-step"><code>dedup()</code></a>： 将结果按照 <code>by()</code> <code>调整步</code>（modulation）来去重</p>
</li>
<li>
<p><a href="#cyclicpath-step"><code>cyclicPath()</code></a>： 按照 <code>by()</code> 来过滤保留循环路径</p>
</li>
<li>
<p><a href="#simplepath-step"><code>simplePath()</code></a>： 按照 <code>by()</code> 来过滤保留简单路径（非循环路径即成为简单路径）</p>
</li>
<li>
<p><a href="#sample-step"><code>sample()</code></a>：按照 <code>by()</code> 返回的value来采样</p>
</li>
<li>
<p><a href="#where-step"><code>where()</code></a>： 按照 <code>by()</code> 给出的测试条件来判断分支</p>
</li>
<li>
<p><a href="#groupcount-step"><code>groupCount()</code></a>： 按照 <code>by()</code> 给出的结果当做分组的键（key）来计算分组的个数</p>
</li>
<li>
<p><a href="#group-step"><code>group()</code></a>： 根据 <code>by()</code> 来创建分组的键和值</p>
</li>
<li>
<p><a href="#order-step"><code>order()</code></a>： 将对象按照 <code>by()</code> 给的结果进行排序</p>
</li>
<li>
<p><a href="#path-step"><code>path()</code></a>： 按照 <code>by()</code> 给出的元素路径来获取遍历器的路径</p>
</li>
<li>
<p><a href="#project-step"><code>project()</code></a>： 根据 <code>by()</code> 提供的各种条件来映射（project）一组当前的对象（map）</p>
</li>
<li>
<p><a href="#select-step"><code>select()</code></a>： 根据 <code>by()</code> 来选择和转换路径元素（path elements）</p>
</li>
<li>
<p><a href="#tree-step"><code>tree()</code></a>: 获取一颗按照 <code>by()</code> 对象的遍历树</p>
</li>
<li>
<p><a href="#aggregate-step"><code>aggregate()</code></a>：聚合对象到一个集合中，仅存储 <code>by()</code> 的传入（的条件）</p>
</li>
<li>
<p><a href="#store-step"><code>store()</code></a>： 存储对象到一个集合中，仅存储 <code>by()</code> 的传入（的条件）</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>更多参考</strong></p>
</div>
<div class="paragraph">
<p><a href="http://tinkerpop.apache.org/javadocs/3.4.1/core/org/apache/tinkerpop/gremlin/process/traversal/dsl/graph/GraphTraversal.html#by--"><code>by()</code></a>,
<a href="http://tinkerpop.apache.org/javadocs/3.4.1/core/org/apache/tinkerpop/gremlin/process/traversal/dsl/graph/GraphTraversal.html#by-java.util.Comparator-"><code>by(Comparator)</code></a>,
<a href="http://tinkerpop.apache.org/javadocs/3.4.1/core/org/apache/tinkerpop/gremlin/process/traversal/dsl/graph/GraphTraversal.html#by-java.util.function.Function-java.util.Comparator-"><code>by(Function,Comparator)</code></a>,
<a href="http://tinkerpop.apache.org/javadocs/3.4.1/core/org/apache/tinkerpop/gremlin/process/traversal/dsl/graph/GraphTraversal.html#by-java.util.function.Function-"><code>by(Function)</code></a>,
<a href="http://tinkerpop.apache.org/javadocs/3.4.1/core/org/apache/tinkerpop/gremlin/process/traversal/dsl/graph/GraphTraversal.html#by-org.apache.tinkerpop.gremlin.process.traversal.Order-"><code>by(Order)</code></a>,
<a href="http://tinkerpop.apache.org/javadocs/3.4.1/core/org/apache/tinkerpop/gremlin/process/traversal/dsl/graph/GraphTraversal.html#by-java.lang.String-"><code>by(String)</code></a>,
<a href="http://tinkerpop.apache.org/javadocs/3.4.1/core/org/apache/tinkerpop/gremlin/process/traversal/dsl/graph/GraphTraversal.html#by-java.lang.String-java.util.Comparator-"><code>by(String,Comparator)</code></a>,
<a href="http://tinkerpop.apache.org/javadocs/3.4.1/core/org/apache/tinkerpop/gremlin/process/traversal/dsl/graph/GraphTraversal.html#by-org.apache.tinkerpop.gremlin.structure.T-"><code>by(T)</code></a>,
<a href="http://tinkerpop.apache.org/javadocs/3.4.1/core/org/apache/tinkerpop/gremlin/process/traversal/dsl/graph/GraphTraversal.html#by-org.apache.tinkerpop.gremlin.process.traversal.Traversal-"><code>by(Traversal)</code></a>,
<a href="http://tinkerpop.apache.org/javadocs/3.4.1/core/org/apache/tinkerpop/gremlin/process/traversal/dsl/graph/GraphTraversal.html#by-org.apache.tinkerpop.gremlin.process.traversal.Traversal-java.util.Comparator-"><code>by(Traversal,Comparator)</code></a>,
<a href="http://tinkerpop.apache.org/javadocs/3.4.1/core/org/apache/tinkerpop/gremlin/structure/T.html"><code>T</code></a>,
<a href="http://tinkerpop.apache.org/javadocs/3.4.1/core/org/apache/tinkerpop/gremlin/process/traversal/Order.html"><code>Order</code></a></p>
</div>
</div>
<div class="sect2">
<h3 id="cap-step"><a class="anchor" href="#cap-step"></a>Cap Step</h3>
<div class="paragraph">
<p><code>cap()</code> (<strong>barrier</strong>) 迭代遍历本身，并且按照提供的key来存储引发的sideEffect。
（这样理解比较容易：很多迭代本身是会引发sideEffects的，而cap则只把sideEffects存到一个以key索引的对象里）
如果cap提供了多个keys，那么就把发生的sideEffects存到 <code>Map&lt;String,Object&gt;</code> 结构里。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>g.V().groupCount('a').by(label).cap('a')      <i class="conum" data-value="1"></i><b>(1)</b>
g.V().groupCount('a').by(label).groupCount('b').by(outE().count()).cap('a','b')   <i class="conum" data-value="2"></i><b>(2)</b></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>按照label来分组并统计顶点的个数，将所生成的“按label的分组个数”这个sideEffect存到以a为键的对象里。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>和1一样，同时将按照边数目分组顶点这个sideEffect存到b里（注意有两次groupCount，引发两次带有sideEffect的单步）</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><strong>更多参考</strong></p>
</div>
<div class="paragraph">
<p><a href="http://tinkerpop.apache.org/javadocs/3.4.1/core/org/apache/tinkerpop/gremlin/process/traversal/dsl/graph/GraphTraversal.html#cap-java.lang.String-java.lang.String&#8230;&#8203;-"><code>cap(String,String...)</code></a></p>
</div>
</div>
<div class="sect2">
<h3 id="choose-step"><a class="anchor" href="#choose-step"></a>Choose Step</h3>
<div class="imageblock">
<div class="content">
<img src="./images/choose-step.png" alt="choose step" width="700">
</div>
</div>
<div class="paragraph">
<p><code>choose()</code>(<strong>branch</strong>) 单步提供了遍历中的择路。
使用 <code>choose()</code> 就可以实现 if/then/else 这样的语义，甚至更复杂的情况</p>
</div>
<div class="listingblock">
<div class="content">
<pre>g.V().hasLabel('person').
      choose(values('age').is(lte(30)),
        __.in(),
        __.out()).values('name') <i class="conum" data-value="1"></i><b>(1)</b>
g.V().hasLabel('person').
      choose(values('age')).
        option(27, __.in()).
        option(32, __.out()).values('name') <i class="conum" data-value="2"></i><b>(2)</b></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>如果遍历中有元素符合要求，就执行 <code>in</code> ，否则执行 <code>out</code> （一个基于true/false的择路）</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>在遍历中判断结果当做一个key，使用它判断择路（同样也是基于true/false的择路）</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>如果false的分支没有指定，那么choose就是一个if/then的语义</p>
</div>
<div class="listingblock">
<div class="content">
<pre>g.V().choose(hasLabel('person'), out('created')).values('name') <i class="conum" data-value="1"></i><b>(1)</b>
g.V().choose(hasLabel('person'), out('created'), identity()).values('name') <i class="conum" data-value="2"></i><b>(2)</b></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>如果顶点是一个person，则发送到它created的顶点，否则就发送顶点本身</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>If/then/else 在false分支使用一个 <code>identity()</code> 就相当于没有false分支的 if/then 语义</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>请注意 <code>choose()</code> 可以接受任意个参数的选择项，也可以接受选择函数使用的匿名遍历</p>
</div>
<div class="listingblock">
<div class="content">
<pre>g.V().hasLabel('person').
      choose(values('name')).
        option('marko', values('age')).
        option('josh', values('name')).
        option('vadas', valueMap()).
        option('peter', label())</pre>
</div>
</div>
<div class="paragraph">
<p><code>choose()</code> 单步可以利用 <code>Pick.none</code> （什么都不选）这个选项来匹配。
如果在各个选项都精确匹配不上，那么 <code>none</code> 这个选项就可以匹配上了</p>
</div>
<div class="listingblock">
<div class="content">
<pre>g.V().hasLabel('person').
      choose(values('name')).
        option('marko', values('age')).
        option(none, values('name'))</pre>
</div>
</div>
<div class="paragraph">
<p><strong>更多参考</strong></p>
</div>
<div class="paragraph">
<p><a href="http://tinkerpop.apache.org/javadocs/3.4.1/core/org/apache/tinkerpop/gremlin/process/traversal/dsl/graph/GraphTraversal.html#choose-java.util.function.Function-"><code>choose(Function)</code></a>,
<a href="http://tinkerpop.apache.org/javadocs/3.4.1/core/org/apache/tinkerpop/gremlin/process/traversal/dsl/graph/GraphTraversal.html#choose-java.util.function.Predicate-org.apache.tinkerpop.gremlin.process.traversal.Traversal-"><code>choose(Predicate,Traversal)</code></a>,
<a href="http://tinkerpop.apache.org/javadocs/3.4.1/core/org/apache/tinkerpop/gremlin/process/traversal/dsl/graph/GraphTraversal.html#choose-java.util.function.Predicate-org.apache.tinkerpop.gremlin.process.traversal.Traversal-org.apache.tinkerpop.gremlin.process.traversal.Traversal-"><code>choose(Predicate,Traversal,Traversal)</code></a>,
<a href="http://tinkerpop.apache.org/javadocs/3.4.1/core/org/apache/tinkerpop/gremlin/process/traversal/dsl/graph/GraphTraversal.html#choose-org.apache.tinkerpop.gremlin.process.traversal.Traversal-org.apache.tinkerpop.gremlin.process.traversal.Traversal-"><code>choose(Traversal,Traversal)</code></a>,
<a href="http://tinkerpop.apache.org/javadocs/3.4.1/core/org/apache/tinkerpop/gremlin/process/traversal/dsl/graph/GraphTraversal.html#choose-org.apache.tinkerpop.gremlin.process.traversal.Traversal-org.apache.tinkerpop.gremlin.process.traversal.Traversal-org.apache.tinkerpop.gremlin.process.traversal.Traversal-"><code>choose(Traversal,Traversal,Traversal)</code></a>,
<a href="http://tinkerpop.apache.org/javadocs/3.4.1/core/org/apache/tinkerpop/gremlin/process/traversal/dsl/graph/GraphTraversal.html#choose-org.apache.tinkerpop.gremlin.process.traversal.Traversal-"><code>choose(Traversal)</code></a></p>
</div>
</div>
<div class="sect2">
<h3 id="coalesce-step"><a class="anchor" href="#coalesce-step"></a>Coalesce Step</h3>
<div class="paragraph">
<p><code>coalesce()</code> 单步按顺序执行并对提供的多个遍历做评估，返回第一个能够返回最少一个元素的遍历（在提供的多个遍历中成功的第一个）。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>g.V(1).coalesce(outE('knows'), outE('created')).inV().path().by('name').by(label)
g.V(1).coalesce(outE('created'), outE('knows')).inV().path().by('name').by(label)
g.V(1).property('nickname', 'okram')
g.V().hasLabel('person').coalesce(values('nickname'), values('name'))</pre>
</div>
</div>
<div class="paragraph">
<p><strong>更多参考</strong></p>
</div>
<div class="paragraph">
<p><a href="http://tinkerpop.apache.org/javadocs/3.4.1/core/org/apache/tinkerpop/gremlin/process/traversal/dsl/graph/GraphTraversal.html#coalesce-org.apache.tinkerpop.gremlin.process.traversal.Traversal&#8230;&#8203;-"><code>coalesce(Traversal...)</code></a></p>
</div>
</div>
<div class="sect2">
<h3 id="coin-step"><a class="anchor" href="#coin-step"></a>Coin Step</h3>
<div class="paragraph">
<p>要想随机的过滤掉一些遍历，使用 <code>coin()</code> (<strong>filter</strong>) 单步就可以。参数是double类型，意思是扔硬币（"coin toss"）的概率（获取正面）。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>g.V().coin(0.5)
g.V().coin(0.0)
g.V().coin(1.0)</pre>
</div>
</div>
<div class="paragraph">
<p><strong>更多参考</strong></p>
</div>
<div class="paragraph">
<p><a href="http://tinkerpop.apache.org/javadocs/3.4.1/core/org/apache/tinkerpop/gremlin/process/traversal/dsl/graph/GraphTraversal.html#coin-double-"><code>coin(double)</code></a></p>
</div>
</div>
<div class="sect2">
<h3 id="connectedcomponent-step"><a class="anchor" href="#connectedcomponent-step"></a>ConnectedComponent Step</h3>
<div class="paragraph">
<p><code>connectedComponent()</code> 单步执行一次计算来识别图中的 <a href="https://en.wikipedia.org/wiki/Connected_component_(graph_theory)">图元件</a> 实例。
当单步完成，每个顶点将被打上一个“元件标签（component identifier）”用于标识它属于哪个图元件</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<code>connectedComponent()</code> 单步是一个 <code>VertexComputing</code> 的步骤，所以它只有在支持 <code>GraphComputer</code> (OLAP) 的系统中使用
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre>g = graph.traversal().withComputer()
g.V().
  connectedComponent().
    with(ConnectedComponent.propertyName, 'component').
  project('name','component').
    by('name').
    by('component')
g.V().hasLabel('person').
  connectedComponent().
    with(ConnectedComponent.propertyName, 'component').
    with(ConnectedComponent.edges, outE('knows')).
  project('name','component').
    by('name').
    by('component')</pre>
</div>
</div>
<div class="paragraph">
<p>使用上要注意 <code>with()</code> 这个调整步，它用于来给算法增加配置选项。
它需要在 <code>ConnectedComponent</code> 这个类中获取配置的keys，并且会被自动的导入到Gremlin控制台上</p>
</div>
<div class="paragraph">
<p><strong>更多参考</strong></p>
</div>
<div class="paragraph">
<p><a href="http://tinkerpop.apache.org/javadocs/3.4.1/core/org/apache/tinkerpop/gremlin/process/traversal/dsl/graph/GraphTraversal.html#connectedComponent--"><code>connectedComponent()</code></a></p>
</div>
</div>
<div class="sect2">
<h3 id="constant-step"><a class="anchor" href="#constant-step"></a>Constant Step</h3>
<div class="paragraph">
<p><code>constant()</code> (<strong>map</strong>) 单步直接为遍历产生一个“立即值”（constant value），
这个在条件性选择单步时特别有用，比如<a href="#choose-step"><code>choose()</code>-step</a> 或者 <a href="#coalesce-step"><code>coalesce()</code>-step</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre>g.V().choose(hasLabel('person'),
    values('name'),
    constant('inhuman')) <i class="conum" data-value="1"></i><b>(1)</b>
g.V().coalesce(
    hasLabel('person').values('name'),
    constant('inhuman')) <i class="conum" data-value="2"></i><b>(2)</b></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>显示顶点是person的name，对于其他顶点，显示"inhuman"</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>和1一样（除非有一个person的顶点没有name）</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><strong>更多参考</strong></p>
</div>
<div class="paragraph">
<p><a href="http://tinkerpop.apache.org/javadocs/3.4.1/core/org/apache/tinkerpop/gremlin/process/traversal/dsl/graph/GraphTraversal.html#constant-E2-"><code>constant(Object)</code></a></p>
</div>
</div>
<div class="sect2">
<h3 id="count-step"><a class="anchor" href="#count-step"></a>Count Step</h3>
<div class="imageblock">
<div class="content">
<img src="./images/count-step.png" alt="count step" width="195">
</div>
</div>
<div class="paragraph">
<p><code>count()</code> (<strong>map</strong>) 单步在当前遍历器流中计算总数 （比如批量计数）</p>
</div>
<div class="listingblock">
<div class="content">
<pre>g.V().count()
g.V().hasLabel('person').count()
g.V().hasLabel('person').outE('created').count().path()  <i class="conum" data-value="1"></i><b>(1)</b>
g.V().hasLabel('person').outE('created').count().map {it.get() * 10}.path() <i class="conum" data-value="2"></i><b>(2)</b></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><code>count()</code> 单步是一个 <a href="#a-note-on-barrier-steps">reducing barrier step</a> ，这意味着所有单步之前的遍历器都被“折叠”（fold）到一个新遍历器中</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>在 <code>count()</code> 单步后的遍历都是由 <code>count()</code> 发起的</td>
</tr>
</table>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<code>count(local)</code> 计数当前的局部对象（而不是整个遍历中的流式对象）
这对 <code>Collection</code> 和 <code>Map</code> 类型的对象也生效。其他对象就返回个数1
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><strong>更多参考</strong></p>
</div>
<div class="paragraph">
<p><a href="http://tinkerpop.apache.org/javadocs/3.4.1/core/org/apache/tinkerpop/gremlin/process/traversal/dsl/graph/GraphTraversal.html#count--"><code>count()</code></a>,
<a href="http://tinkerpop.apache.org/javadocs/3.4.1/core/org/apache/tinkerpop/gremlin/process/traversal/dsl/graph/GraphTraversal.html#count-org.apache.tinkerpop.gremlin.process.traversal.Scope-"><code>count(Scope)</code></a>,
<a href="http://tinkerpop.apache.org/javadocs/3.4.1/core/org/apache/tinkerpop/gremlin/process/traversal/Scope.html"><code>Scope</code></a></p>
</div>
</div>
<div class="sect2">
<h3 id="cyclicpath-step"><a class="anchor" href="#cyclicpath-step"></a>CyclicPath Step</h3>
<div class="imageblock">
<div class="content">
<img src="./images/cyclicpath-step.png" alt="cyclicpath step" width="400">
</div>
</div>
<div class="paragraph">
<p>每一个遍历器都维护了它的在图中的游走历史——比如，它的<a href="#path-data-structure">路径</a>。
如果遍历的重复游走很重要的话，那么就可以使用 <code>cyclic()</code> (<strong>filter</strong>) 单步。
这个单步分析遍历器运行到当前的历史路径，如果有回环，遍历器就运算一下，把这些给过滤出来。
如果期望输出没有回环（non-cyclic）的，请查看<a href="#simplepath-step"><code>simplePath()</code></a></p>
</div>
<div class="listingblock">
<div class="content">
<pre>g.V(1).both().both()
g.V(1).both().both().cyclicPath()
g.V(1).both().both().cyclicPath().path()
g.V(1).as('a').out('created').as('b').
  in('created').as('c').
  cyclicPath().
  path()
g.V(1).as('a').out('created').as('b').
  in('created').as('c').
  cyclicPath().from('a').to('b').
  path()</pre>
</div>
</div>
<div class="paragraph">
<p><strong>更多参考</strong></p>
</div>
<div class="paragraph">
<p><a href="http://tinkerpop.apache.org/javadocs/3.4.1/core/org/apache/tinkerpop/gremlin/process/traversal/dsl/graph/GraphTraversal.html#cyclicPath--"><code>cyclicPath()</code></a></p>
</div>
</div>
<div class="sect2">
<h3 id="dedup-step"><a class="anchor" href="#dedup-step"></a>Dedup Step</h3>
<div class="paragraph">
<p><code>dedup()</code> (<strong>filter</strong>) 单步可以用来在整个遍历流中去重。
注意如果一个遍历的批量如果大于1，那么它在发出前就被设置成1了</p>
</div>
<div class="listingblock">
<div class="content">
<pre>g.V().values('lang')
g.V().values('lang').dedup()
g.V(1).repeat(bothE('created').dedup().otherV()).emit().path() <i class="conum" data-value="1"></i><b>(1)</b></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>遍历所有 <code>created</code> 的边，但只会访问一次</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>如果 <code>dedup()</code> 依赖了 <code>by</code> 这个协调步，那么对象先被做相应的处理，然后决定是否可见</p>
</div>
<div class="listingblock">
<div class="content">
<pre>g.V().valueMap('name').with(WithOptions.tokens)
g.V().dedup().by(label).values('name')</pre>
</div>
</div>
<div class="paragraph">
<p>最后，如果向 <code>dedup()</code> 传了一串字符串（array of strings）那么它将保证这些去重操作不仅作用于当前遍历对象，
而是作用在整个遍历器的历史路径（的多个遍历对象）上</p>
</div>
<div class="listingblock">
<div class="content">
<pre>g.V().as('a').out('created').as('b').in('created').as('c').select('a','b','c')
g.V().as('a').out('created').as('b').in('created').as('c').dedup('a','b').select('a','b','c') <i class="conum" data-value="1"></i><b>(1)</b></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>If the current <code>a</code> and <code>b</code> combination has been seen previously, then filter the traverser.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><strong>更多参考</strong></p>
</div>
<div class="paragraph">
<p><a href="http://tinkerpop.apache.org/javadocs/3.4.1/core/org/apache/tinkerpop/gremlin/process/traversal/dsl/graph/GraphTraversal.html#dedup-org.apache.tinkerpop.gremlin.process.traversal.Scope-java.lang.String&#8230;&#8203;-"><code>dedup(Scope,String...)</code></a>,
<a href="http://tinkerpop.apache.org/javadocs/3.4.1/core/org/apache/tinkerpop/gremlin/process/traversal/dsl/graph/GraphTraversal.html#dedup-java.lang.String&#8230;&#8203;-"><code>dedup(String...)</code></a>,
<a href="http://tinkerpop.apache.org/javadocs/3.4.1/core/org/apache/tinkerpop/gremlin/process/traversal/Scope.html"><code>Scope</code></a></p>
</div>
</div>
<div class="sect2">
<h3 id="drop-step"><a class="anchor" href="#drop-step"></a>Drop Step</h3>
<div class="paragraph">
<p><code>drop()</code> (<strong>filter</strong>/<strong>sideEffect</strong>) 单步用于在图上删除元素和属性。
它本身也是一个过滤性（filter）的单步操作，因为它并不引入外部对象</p>
</div>
<div class="listingblock">
<div class="content">
<pre>g.V().outE().drop()
g.E()
g.V().properties('name').drop()
g.V().valueMap()
g.V().drop()
g.V()</pre>
</div>
</div>
<div class="paragraph">
<p><strong>更多参考</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="http://tinkerpop.apache.org/javadocs/3.4.1/core/org/apache/tinkerpop/gremlin/process/traversal/dsl/graph/GraphTraversal.html#drop--"><code>drop()</code></a></p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="emit-step"><a class="anchor" href="#emit-step"></a>Emit Step</h3>
<div class="paragraph">
<p><code>emit</code> 也不是一个真正意义上的单步，它是 <code>&lt;&lt;repeat-step,repeat()&gt;&gt;</code> 的协调步。（查看更多 <code>emit()</code> 的信息）</p>
</div>
<div class="paragraph">
<p><strong>更多参考</strong></p>
</div>
<div class="paragraph">
<p><a href="http://tinkerpop.apache.org/javadocs/3.4.1/core/org/apache/tinkerpop/gremlin/process/traversal/dsl/graph/GraphTraversal.html#emit--"><code>emit()</code></a>,
<a href="http://tinkerpop.apache.org/javadocs/3.4.1/core/org/apache/tinkerpop/gremlin/process/traversal/dsl/graph/GraphTraversal.html#emit-java.util.function.Predicate-"><code>emit(Predicate)</code></a>,
<a href="http://tinkerpop.apache.org/javadocs/3.4.1/core/org/apache/tinkerpop/gremlin/process/traversal/dsl/graph/GraphTraversal.html#emit-org.apache.tinkerpop.gremlin.process.traversal.Traversal-"><code>emit(Traversal)</code></a></p>
</div>
</div>
<div class="sect2">
<h3 id="explain-step"><a class="anchor" href="#explain-step"></a>Explain Step</h3>
<div class="paragraph">
<p><code>explain()</code> (<strong>terminal</strong>) 是一个 <code>结束性单步</code>，它返回一个 <code>TraversalExplanation</code> 结构。
一个“遍历的解释”详细的描述了遍历（先于 <code>explain()</code>）是怎样根据给定的<a href="#traversalstrategy">traversal strategies</a>（遍历策略）解析的。
<code>TraversalExplanation</code> 有一个 <code>toString()</code> 方法，生成一个三栏的陈述：第一栏是应用的遍历规则，
第二栏是遍历规则的分类：[D]ecoration，[O]ptimization，[P]rovider optimization，[F]inalization和[V]erification。
最后一栏是应用策略后，遍历器的当前状态。“最终遍历”是整个执行计划的结果</p>
</div>
<div class="listingblock">
<div class="content">
<pre>g.V().hasLabel('person').outE().identity().inV().count().is(gt(5)).explain()</pre>
</div>
</div>
<div class="paragraph">
<p>查看更多遍历的特征分析（profiling）信息，请阅读<a href="#profile-step"><code>profile()</code></a> 这个单步</p>
</div>
</div>
<div class="sect2">
<h3 id="fold-step"><a class="anchor" href="#fold-step"></a>Fold Step</h3>
<div class="paragraph">
<p>有些场景下，遍历流需要一个“栅栏”来聚合所有的对象，
然后对这个聚合的对象使用一个函数进行计算
<code>fold()</code> 单步就是这样一个特殊的例子，请查阅 <a href="#unfold-step"><code>unfold()</code></a> 看相反的操作</p>
</div>
<div class="listingblock">
<div class="content">
<pre>g.V(1).out('knows').values('name')
g.V(1).out('knows').values('name').fold() <i class="conum" data-value="1"></i><b>(1)</b>
g.V(1).out('knows').values('name').fold().next().getClass() <i class="conum" data-value="2"></i><b>(2)</b>
g.V(1).out('knows').values('name').fold(0) {a,b -&gt; a + b.length()} <i class="conum" data-value="3"></i><b>(3)</b>
g.V().values('age').fold(0) {a,b -&gt; a + b} <i class="conum" data-value="4"></i><b>(4)</b>
g.V().values('age').fold(0, sum) <i class="conum" data-value="5"></i><b>(5)</b>
g.V().values('age').sum() <i class="conum" data-value="6"></i><b>(6)</b></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>一个无参数的 <code>fold()</code> 将聚合所有的对象到一个链表里（list），然后发送到遍历器下一个单步</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>检验一下返回链表的类型</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td><code>fold()</code> 能够接受两个参数，一个是种子值，一个是做reduce的bi-function。（"vadas" 有5个字母 + "josh" 有4个).</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>图中所有人age的和</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>和前面一样，不过是使用内建的bi-function</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>和前面一样，不过使用了<a href="#sum-step"><code>sum()</code> 单步</a></td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
【中文添加，方便读者理解】由于tinkerpop的每一个单步非常像函数式编程，在很多操作中，
可以直接传递一个functor或者lambda进行运算衔接。上文中reduce和BiFunction可以参考Java8的FunctionalInterface来理解
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><strong>更多参考</strong></p>
</div>
<div class="paragraph">
<p><a href="http://tinkerpop.apache.org/javadocs/3.4.1/core/org/apache/tinkerpop/gremlin/process/traversal/dsl/graph/GraphTraversal.html#fold--"><code>fold()</code></a>,
<a href="http://tinkerpop.apache.org/javadocs/3.4.1/core/org/apache/tinkerpop/gremlin/process/traversal/dsl/graph/GraphTraversal.html#fold-E2-java.util.function.BiFunction-"><code>fold(Object,BiFunction)</code></a></p>
</div>
</div>
<div class="sect2">
<h3 id="from-step"><a class="anchor" href="#from-step"></a>From Step</h3>
<div class="paragraph">
<p><code>from()</code> 单步也不是一个真正意义上的单步，和<a href="#as-step"><code>as()</code></a>、<a href="#by-step"><code>by()</code></a>一样，也是一个 <code>调整步</code>。
如果一个单步能够接受遍历（traversals）或者字符串（strings），那么 <code>from()</code> 就是告诉他们从哪添加的。
通用的模式就是 <code>step().from()</code>。 同样可以看<a href="#to-step"><code>to()</code></a>调整步</p>
</div>
<div class="paragraph">
<p>可以接受 <code>from()</code> 的单步操作有：<a href="#simplepath-step"><code>simplePath()</code></a>，<a href="#cyclicpath-step"><code>cyclicPath()</code></a>，<a href="#path-step"><code>path()</code></a>，和<a href="#addedge-step"><code>addE()</code></a></p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Javascript"></i>
</td>
<td class="content">
<div class="paragraph">
<p><code>from</code> 在Javascript是关键字，所以引用Gremlin时使用 <code>from_()</code></p>
</div>
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Python"></i>
</td>
<td class="content">
<div class="paragraph">
<p><code>from</code> 在Python是保留字，所以引用Gremlin时使用 <code>from_()</code></p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><strong>更多参考</strong></p>
</div>
<div class="paragraph">
<p><a href="http://tinkerpop.apache.org/javadocs/3.4.1/core/org/apache/tinkerpop/gremlin/process/traversal/dsl/graph/GraphTraversal.html#from-java.lang.String-"><code>from(String)</code></a>,
<a href="http://tinkerpop.apache.org/javadocs/3.4.1/core/org/apache/tinkerpop/gremlin/process/traversal/dsl/graph/GraphTraversal.html#from-org.apache.tinkerpop.gremlin.process.traversal.Traversal-"><code>from(Traversal)</code></a>,
<a href="http://tinkerpop.apache.org/javadocs/3.4.1/core/org/apache/tinkerpop/gremlin/process/traversal/dsl/graph/GraphTraversal.html#from-org.apache.tinkerpop.gremlin.structure.Vertex-"><code>from(Vertex)</code></a></p>
</div>
</div>
<div class="sect2">
<h3 id="graph-step"><a class="anchor" href="#graph-step"></a>Graph Step</h3>
<div class="paragraph">
<p><code>V()</code> 单步一般用来发起一个 <code>GraphTraversal</code>，也可以用于中间遍历（mid-traversal）</p>
</div>
<div class="listingblock">
<div class="content">
<pre>g.V().has('name', within('marko', 'vadas', 'josh')).as('person').
  V().has('name', within('lop', 'ripple')).addE('uses').from('person')</pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
中间遍历`V()` 是否能够使用使用索引，依赖于：a) 是否有合适的索引 b) 特殊实现的图系统师是否提供这个功能
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre>g.V().has('name', within('marko', 'vadas', 'josh')).as('person').
  V().has('name', within('lop', 'ripple')).addE('uses').from('person').toString() <i class="conum" data-value="1"></i><b>(1)</b>
g.V().has('name', within('marko', 'vadas', 'josh')).as('person').
  V().has('name', within('lop', 'ripple')).addE('uses').from('person').iterate().toString() <i class="conum" data-value="2"></i><b>(2)</b></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>一般来说，<code>V()</code> 单步将遍历所有的顶点。 但同时，图策略可以将能够满足 <code>HasContainer</code> 过滤条件的放到 <code>Graph-Step</code> 单步中，就可以使用索引来快速查找</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>在具体的图系统中，是否中间遍历 <code>V()</code> 支持快速索引与否，是不能简单的通过在当前迭代中使用 <code>toString()</code> 输出的结果来判断的。
但如果有 <code>has</code> 这样的条件使用在了 <code>V()</code> 单步中，如果索引存在，它就会被使用（即使部分索引）</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><strong>更多参考</strong></p>
</div>
<div class="paragraph">
<p><a href="http://tinkerpop.apache.org/javadocs/3.4.1/core/org/apache/tinkerpop/gremlin/process/traversal/dsl/graph/GraphTraversal.html#V-java.lang.Object&#8230;&#8203;-"><code>V(Object...)</code></a></p>
</div>
</div>
<div class="sect2">
<h3 id="group-step"><a class="anchor" href="#group-step"></a>Group Step</h3>
<div class="paragraph">
<p>当遍历器在执行（执行图遍历所在的子图）时，有时候“副作用”是需要进行计算的。
即当前遍历器的位置或者已执行的路径都不是最后计算的结果，而仅仅是这个遍历的一种另外的表示形式。
<code>group()</code> (<strong>map</strong>/<strong>sideEffect</strong>) 单步就是一种sideEffect单步，它能够按照某函数将对象组织并分组。
然后接下来，被组织的分组（一个链表）就可以进行reduce操作。下面是一个例子</p>
</div>
<div class="listingblock">
<div class="content">
<pre>g.V().group().by(label) <i class="conum" data-value="1"></i><b>(1)</b>
g.V().group().by(label).by('name') <i class="conum" data-value="2"></i><b>(2)</b>
g.V().group().by(label).by(count()) <i class="conum" data-value="3"></i><b>(3)</b></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>将顶点按它们各自的label分组</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>将顶点分组后，获取他们的name</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>看下每个分组的大小是多少？</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code>group()</code> 一共有两个可以用 <code>by()</code> 投射（projection）的参数:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>键投射：使用什么样的方式来归类对象？（一个能用于生成Key的功能）</p>
</li>
<li>
<p>值投射：存放在链表中的对象，使用了分组中什么能力？</p>
</li>
</ol>
</div>
<div class="paragraph">
<p><strong>更多参考</strong></p>
</div>
<div class="paragraph">
<p><a href="http://tinkerpop.apache.org/javadocs/3.4.1/core/org/apache/tinkerpop/gremlin/process/traversal/dsl/graph/GraphTraversal.html#group--"><code>group()</code></a>,
<a href="http://tinkerpop.apache.org/javadocs/3.4.1/core/org/apache/tinkerpop/gremlin/process/traversal/dsl/graph/GraphTraversal.html#group-java.lang.String-"><code>group(String)</code></a></p>
</div>
</div>
<div class="sect2">
<h3 id="groupcount-step"><a class="anchor" href="#groupcount-step"></a>GroupCount Step</h3>
<div class="paragraph">
<p><code>groupCount()</code> (<strong>map</strong>/<strong>sideEffect</strong>) 单步可以用于在特定的点上按需查看聚合对象的个数</p>
</div>
<div class="literalblock">
<div class="content">
<pre>"图中age的分布情况是什么？"</pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre>g.V().hasLabel('person').values('age').groupCount()
g.V().hasLabel('person').groupCount().by('age') <i class="conum" data-value="1"></i><b>(1)</b></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>也可以在分组前，使用<a href="#by-step"><code>by()</code></a> 投射的方法来将分组要流入的对象</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>例中有一个人32岁，一个人35岁，一个27岁，一个29岁</p>
</div>
<div class="literalblock">
<div class="content">
<pre>"进行图的游走，并对每个名字的第二个字母的个数进行统计"</pre>
</div>
</div>
<div class="imageblock">
<div class="content">
<img src="./images/groupcount-step.png" alt="groupcount step" width="420">
</div>
</div>
<div class="listingblock">
<div class="content">
<pre>g.V().repeat(both().groupCount('m').by(label)).times(10).cap('m')</pre>
</div>
</div>
<div class="paragraph">
<p>上面的实例非常有趣，实际上它深刻的展示了 <code>groupCount()</code> 怎样使用一个string类型的变量来引用其内部的 <code>Map&lt;Object,Long&gt;</code>。
考虑到 <code>groupCount()</code> 一个sideEffect类型的 <code>通用单步</code> ，它传入的对象适用于接收对象流的输出。
<code>groupCount()</code> 内部，对象计数器递增（按object对象）</p>
</div>
<div class="paragraph">
<p><strong>更多参考</strong></p>
</div>
<div class="paragraph">
<p><a href="http://tinkerpop.apache.org/javadocs/3.4.1/core/org/apache/tinkerpop/gremlin/process/traversal/dsl/graph/GraphTraversal.html#groupCount--"><code>groupCount()</code></a>,
<a href="http://tinkerpop.apache.org/javadocs/3.4.1/core/org/apache/tinkerpop/gremlin/process/traversal/dsl/graph/GraphTraversal.html#groupCount-java.lang.String-"><code>groupCount(String)</code></a></p>
</div>
</div>
<div class="sect2">
<h3 id="has-step"><a class="anchor" href="#has-step"></a>Has Step</h3>
<div class="imageblock">
<div class="content">
<img src="./images/has-step.png" alt="has step" width="670">
</div>
</div>
<div class="paragraph">
<p>使用 <code>has()</code> (<strong>filter</strong>) 单步就可以来筛选过滤边，顶点和顶点的属性。
<code>has()</code> 本身也有一些变形使用，包含：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>has(key,value)</code>：如果遍历器里的元素没有提供key/value属性，直接删除遍历器</p>
</li>
<li>
<p><code>has(label, key, value)</code>：如果遍历器中的元素没有指定的label和key/value属性，直接删除遍历器</p>
</li>
<li>
<p><code>has(key,predicate)</code>：如果遍历器中的元素的key/value不能满足bi-predicate（二元谓词函子），则删除遍历器。对于predicates更多信息，请查看<a href="#a-note-on-predicates">A Note on Predicates</a></p>
</li>
<li>
<p><code>hasLabel(labels...)</code>：如果遍历器中的元素没有任何一个传入的label，那就删除遍历器</p>
</li>
<li>
<p><code>hasId(ids...)</code>：如果遍历器中的元素没有任何一个传入的ids，那就删除遍历器</p>
</li>
<li>
<p><code>hasKey(keys...)</code>：如果遍历器属性中没有所有提供的keys，那就删除遍历器</p>
</li>
<li>
<p><code>hasValue(values...)</code>：如果遍历器属性中没有所有提供的values，那就删除遍历器</p>
</li>
<li>
<p><code>has(key)</code>：如果遍历器中没有元素具有所提供的key，那就删除遍历器</p>
</li>
<li>
<p><code>hasNot(key)</code>：如果遍历器中有元素具有所提供的key，那就删除遍历器</p>
</li>
<li>
<p><code>has(key, traversal)</code>: 如果遍历（内部的traversal）中属性没有按照key生成结果，则删除遍历器</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre>g.V().hasLabel('person')
g.V().hasLabel('person').out().has('name',within('vadas','josh'))
g.V().hasLabel('person').out().has('name',within('vadas','josh')).
      outE().hasLabel('created')
g.V().has('age',inside(20,30)).values('age') <i class="conum" data-value="1"></i><b>(1)</b>
g.V().has('age',outside(20,30)).values('age') <i class="conum" data-value="2"></i><b>(2)</b>
g.V().has('name',within('josh','marko')).valueMap() <i class="conum" data-value="3"></i><b>(3)</b>
g.V().has('name',without('josh','marko')).valueMap() <i class="conum" data-value="4"></i><b>(4)</b>
g.V().has('name',not(within('josh','marko'))).valueMap() <i class="conum" data-value="5"></i><b>(5)</b>
g.V().properties().hasKey('age').value() <i class="conum" data-value="6"></i><b>(6)</b>
g.V().hasNot('age').values('name') <i class="conum" data-value="7"></i><b>(7)</b></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>找到所有age在20（不包含）到30（不包含）中间的顶点。换句话说，age必须在大于20，且小于30</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>找到所有age不在20（包含）和30（包含）中间的顶点。换句话说，age必须在小于20，或者大于30</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>找到所有name精确匹配 <code>[josh,marko]</code> 集合内（josh和marko）的顶点，并且以键值对方式显示这些顶点</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>找到所有name不在集合 <code>[josh,marko]</code> 内的顶点，并且以键值对方式显示这些顶点</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>一个相同的例子，用 <code>not</code> 修饰 <code>within</code> 来生成 <code>without</code> 语义</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>找到图中所有age的属性，并且获取他们的value</td>
</tr>
<tr>
<td><i class="conum" data-value="7"></i><b>7</b></td>
<td>找到所有不含age属性的顶点，并且获取他们的name</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>TinkerPop并不提供正则表达式的predicate运算，尽管一些使用Tinkerpop的实现可能提供了一些部分匹配的语义扩展</p>
</div>
<div class="paragraph">
<p><strong>更多参考</strong></p>
</div>
<div class="paragraph">
<p><a href="http://tinkerpop.apache.org/javadocs/3.4.1/core/org/apache/tinkerpop/gremlin/process/traversal/dsl/graph/GraphTraversal.html#has-java.lang.String-"><code>has(String)</code></a>,
<a href="http://tinkerpop.apache.org/javadocs/3.4.1/core/org/apache/tinkerpop/gremlin/process/traversal/dsl/graph/GraphTraversal.html#has-java.lang.String-java.lang.Object-"><code>has(String,Object)</code></a>,
<a href="http://tinkerpop.apache.org/javadocs/3.4.1/core/org/apache/tinkerpop/gremlin/process/traversal/dsl/graph/GraphTraversal.html#has-java.lang.String-org.apache.tinkerpop.gremlin.process.traversal.P-"><code>has(String,P)</code></a>,
<a href="http://tinkerpop.apache.org/javadocs/3.4.1/core/org/apache/tinkerpop/gremlin/process/traversal/dsl/graph/GraphTraversal.html#has-java.lang.String-java.lang.String-java.lang.Object-"><code>has(String,String,Object)</code></a>,
<a href="http://tinkerpop.apache.org/javadocs/3.4.1/core/org/apache/tinkerpop/gremlin/process/traversal/dsl/graph/GraphTraversal.html#has-java.lang.String-java.lang.String-org.apache.tinkerpop.gremlin.process.traversal.P-"><code>has(String,String,P)</code></a>,
<a href="http://tinkerpop.apache.org/javadocs/3.4.1/core/org/apache/tinkerpop/gremlin/process/traversal/dsl/graph/GraphTraversal.html#has-java.lang.String-org.apache.tinkerpop.gremlin.process.traversal.Traversal-"><code>has(String,Traversal)</code></a>,
<a href="http://tinkerpop.apache.org/javadocs/3.4.1/core/org/apache/tinkerpop/gremlin/process/traversal/dsl/graph/GraphTraversal.html#has-org.apache.tinkerpop.gremlin.structure.T-java.lang.Object-"><code>has(T,Object)</code></a>,
<a href="http://tinkerpop.apache.org/javadocs/3.4.1/core/org/apache/tinkerpop/gremlin/process/traversal/dsl/graph/GraphTraversal.html#has-org.apache.tinkerpop.gremlin.structure.T-org.apache.tinkerpop.gremlin.process.traversal.P-"><code>has(T,P)</code></a>,
<a href="http://tinkerpop.apache.org/javadocs/3.4.1/core/org/apache/tinkerpop/gremlin/process/traversal/dsl/graph/GraphTraversal.html#has-org.apache.tinkerpop.gremlin.structure.T-org.apache.tinkerpop.gremlin.process.traversal.Traversal-"><code>has(T,Traversal)</code></a>,
<a href="http://tinkerpop.apache.org/javadocs/3.4.1/core/org/apache/tinkerpop/gremlin/process/traversal/dsl/graph/GraphTraversal.html#hasId-java.lang.Object-java.lang.Object&#8230;&#8203;-"><code>hasId(Object,Object...)</code></a>,
<a href="http://tinkerpop.apache.org/javadocs/3.4.1/core/org/apache/tinkerpop/gremlin/process/traversal/dsl/graph/GraphTraversal.html#hasId-org.apache.tinkerpop.gremlin.process.traversal.P-"><code>hasId(P)</code></a>,
<a href="http://tinkerpop.apache.org/javadocs/3.4.1/core/org/apache/tinkerpop/gremlin/process/traversal/dsl/graph/GraphTraversal.html#hasKey-org.apache.tinkerpop.gremlin.process.traversal.P-"><code>hasKey(P)</code></a>,
<a href="http://tinkerpop.apache.org/javadocs/3.4.1/core/org/apache/tinkerpop/gremlin/process/traversal/dsl/graph/GraphTraversal.html#hasKey-java.lang.String-java.lang.String&#8230;&#8203;-"><code>hasKey(String,String...)</code></a>,
<a href="http://tinkerpop.apache.org/javadocs/3.4.1/core/org/apache/tinkerpop/gremlin/process/traversal/dsl/graph/GraphTraversal.html#hasLabel-org.apache.tinkerpop.gremlin.process.traversal.P-"><code>hasLabel(P)</code></a>,
<a href="http://tinkerpop.apache.org/javadocs/3.4.1/core/org/apache/tinkerpop/gremlin/process/traversal/dsl/graph/GraphTraversal.html#hasLabel-java.lang.String-java.lang.String&#8230;&#8203;-"><code>hasLabel(String,String...)</code></a>,
<a href="http://tinkerpop.apache.org/javadocs/3.4.1/core/org/apache/tinkerpop/gremlin/process/traversal/dsl/graph/GraphTraversal.html#hasNot-java.lang.String-"><code>hasNot(String)</code></a>,
<a href="http://tinkerpop.apache.org/javadocs/3.4.1/core/org/apache/tinkerpop/gremlin/process/traversal/dsl/graph/GraphTraversal.html#hasValue-java.lang.Object-java.lang.Object&#8230;&#8203;-"><code>hasValue(Object,Object...)</code></a>,
<a href="http://tinkerpop.apache.org/javadocs/3.4.1/core/org/apache/tinkerpop/gremlin/process/traversal/dsl/graph/GraphTraversal.html#hasValue-org.apache.tinkerpop.gremlin.process.traversal.P-"><code>hasValue(P)</code></a>,
<a href="http://tinkerpop.apache.org/javadocs/3.4.1/core/org/apache/tinkerpop/gremlin/process/traversal/P.html"><code>P</code></a>,
<a href="http://tinkerpop.apache.org/javadocs/3.4.1/core/org/apache/tinkerpop/gremlin/structure/T.html"><code>T</code></a></p>
</div>
</div>
<div class="sect2">
<h3 id="id-step"><a class="anchor" href="#id-step"></a>Id Step</h3>
<div class="paragraph">
<p><code>id()</code> (<strong>map</strong>) 单步传入一个元素（<code>Element</code>），并获得它的id</p>
</div>
<div class="listingblock">
<div class="content">
<pre>g.V().id()
g.V(1).out().id().is(2)
g.V(1).outE().id()
g.V(1).properties().id()</pre>
</div>
</div>
<div class="paragraph">
<p><strong>更多参考</strong></p>
</div>
<div class="paragraph">
<p><a href="http://tinkerpop.apache.org/javadocs/3.4.1/core/org/apache/tinkerpop/gremlin/process/traversal/dsl/graph/GraphTraversal.html#id--"><code>id()</code></a></p>
</div>
</div>
<div class="sect2">
<h3 id="identity-step"><a class="anchor" href="#identity-step"></a>Identity Step</h3>
<div class="paragraph">
<p><code>identity()</code> (<strong>map</strong>) 单步是一个映射对象到自己的<a href="https://en.wikipedia.org/wiki/Identity_function">恒等函数</a></p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
【中文添加，方便读者理解】<code>identity()</code> 和 <code>id()</code> 的区别就是返回一个函数，而这个函数可以作为下一步运算。
比如如果用户使用id()获取到一个唯一标识后，如果想继续运算就得把它as()一下
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre>g.V().identity()</pre>
</div>
</div>
<div class="paragraph">
<p><strong>更多参考</strong></p>
</div>
<div class="paragraph">
<p><a href="http://tinkerpop.apache.org/javadocs/3.4.1/core/org/apache/tinkerpop/gremlin/process/traversal/dsl/graph/GraphTraversal.html#identity--"><code>identity()</code></a></p>
</div>
</div>
<div class="sect2">
<h3 id="index-step"><a class="anchor" href="#index-step"></a>Index Step</h3>
<div class="paragraph">
<p><code>index()</code> (<strong>map</strong>) 单步为当前的集合每个元素创建索引。如果当前遍历器值不是一个value，那就被认为是个单元素集合。
目前有两种索引器，它们可以用 <code>with()</code> 协调步来选择。一种是List索引器（默认索引器），它为这个集合创建一个链表，第一个是原有的元素，第二个是索引，以此类推。
第二种Map索引器创建一个LinkedHashMap，索引作为键，原有的元素作为值</p>
</div>
<div class="listingblock">
<div class="content">
<pre>g.V().hasLabel("software").index()  <i class="conum" data-value="1"></i><b>(1)</b>
g.V().hasLabel("software").values("name").fold().
  order(Scope.local).
  index().
  unfold().
  order().
    by(__.tail(Scope.local, 1))     <i class="conum" data-value="2"></i><b>(2)</b>
g.V().hasLabel("software").values("name").fold().
  order(Scope.local).
  index().
    with(WithOptions.indexer, WithOptions.list).
  unfold().
  order().
    by(__.tail(Scope.local, 1))     <i class="conum" data-value="3"></i><b>(3)</b>
g.V().hasLabel("person").values("name").fold().
  order(Scope.local).
  index().
    with(WithOptions.indexer, WithOptions.map)  <i class="conum" data-value="4"></i><b>(4)</b></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>在非集合对象上做索引将生成一个多元索引的单对象集合（相同的元素，因为查到的元素相同，所以对应了相同的索引0）</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>对所有“software”的name做索引，按字母序</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>和1相同，显式的选择List索引器</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>对所有“person”的name做索引，按字母排序，且选择Map索引器</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><strong>更多参考</strong></p>
</div>
<div class="paragraph">
<p><a href="http://tinkerpop.apache.org/javadocs/3.4.1/core/org/apache/tinkerpop/gremlin/process/traversal/dsl/graph/GraphTraversal.html#index--"><code>index()</code></a></p>
</div>
</div>
<div class="sect2">
<h3 id="inject-step"><a class="anchor" href="#inject-step"></a>Inject Step</h3>
<div class="imageblock">
<div class="content">
<img src="./images/inject-step.png" alt="inject step" width="800">
</div>
</div>
<div class="paragraph">
<p>“可插入单步”的理念其实是让“能够任意的在遍历流中插入对象”变得可能。总体来说
<code>inject()</code> (<strong>sideEffect</strong>) 单步是存在的，下面是一些例子</p>
</div>
<div class="listingblock">
<div class="content">
<pre>g.V(4).out().values('name').inject('daniel')
g.V(4).out().values('name').inject('daniel').map {it.get().length()}
g.V(4).out().values('name').inject('daniel').map {it.get().length()}.path()</pre>
</div>
</div>
<div class="paragraph">
<p>在上面的例子中，请注意从 <code>daniel</code> 开始的路径深度只有2。这是因为 <code>daniel</code> 这个字符串在遍历的中间步骤（half-way）被插入。
最后，下面是一个典型的用法——当图遍历的起点不是一个图对象</p>
</div>
<div class="listingblock">
<div class="content">
<pre>inject(1,2)
inject(1,2).map {it.get() + 1}
inject(1,2).map {it.get() + 1}.map {g.V(it.get()).next()}.values('name')</pre>
</div>
</div>
<div class="paragraph">
<p><strong>更多参考</strong></p>
</div>
<div class="paragraph">
<p><a href="http://tinkerpop.apache.org/javadocs/3.4.1/core/org/apache/tinkerpop/gremlin/process/traversal/dsl/graph/GraphTraversal.html#inject-E&#8230;&#8203;-"><code>inject(Object)</code></a></p>
</div>
<div class="paragraph">
<p><a id="_gremlin_i_o"></a></p>
</div>
</div>
<div class="sect2">
<h3 id="io-step"><a class="anchor" href="#io-step"></a>IO Step</h3>
<div class="imageblock left">
<div class="content">
<img src="./images/gremlin-io.png" alt="gremlin io" width="250">
</div>
</div>
<div class="paragraph">
<p>在图的实例上导入导出数据是 <code>io()</code> 单步的工作。
默认的，TinkerPop支持三种导入导出图数据的格式，分别是 <a href="#graphml">GraphML</a>， <a href="#graphson">GraphSON</a>，和 <a href="#gryo">Gryo</a>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
附加的关于TinkerPop IO 格式的文档在 <a href="http://tinkerpop.apache.org/docs/3.4.1/dev/io/">IO 参考</a>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code>io()</code> 单步本身只是导入和导出的配置，表明其的工作模式，后续在调用 <code>read()</code> 或者 <code>write()</code> 时才真正执行（导入或导出）。
因此，典型的 <code>io()</code> 应该类似：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">g.io(someInputFile).read().iterate()
g.io(someOutputFile).write().iterate()</code></pre>
</div>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
上面的命令仍旧是一个遍历操作，所以需要一个迭代来执行，正如这里的 <code>iterate()</code> 这个 <code>结束性单步</code>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>默认的，<code>io()</code> 单步将通过文件的扩展名来检测是否是使用了正确的格式。
要去获得更高级格式控制的能力，应通过 <code>with()</code> 单步来提供更多的信息给 <code>io()</code>，比如：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">g.io(someInputFile).
    with(IO.reader, IO.graphson).
  read().iterate()
g.io(someOutputFile).
    with(IO.writer,IO.graphml).
  write().iterate()</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>IO</code> 类是一个实现 <code>io()</code> 单步的helper类，它提供了可以帮助（用户）配置的表达式和供"reader" 和 "writer"使用的直接规范。
"reader" 其实可以参考 <code>GraphReader</code> 的实现，同样，"writer" 的一个实现是 <code>GraphWriter</code>。这两个接口类的默认实现是标准的tinkerpop实现的一部分</p>
</div>
<div class="paragraph">
<p>这个默认的实现对用户来说也是很重要的、要考虑的一点。Tinkerpop的实现并不是以“超大规模、复杂、大并发负载”为目的来思考设计的。
它是围绕着“单线程，OLTP类型的数据负载”这种常见类型来设计的，因为这样可以适配较多的图数据库类应用。
因此，从导入角度，这样的设计对一些小数据量（对时间不敏感的中型数据图也是足够的）的空图导入是最好的 —— 不支持增量数据导入。
对导出来说也是同样的，整个过程中没有并行操作。存储流式数据到磁盘是一个单通道的过程，所以对大数据量来说并不需要特别多内存</p>
</div>
<div class="paragraph">
<p>总体来说，TinkerPop建议用户在选择图实现时，测试一下这些它自带的导入导出工具。这些工具一般比 <code>io()</code> 单步强很多，功能很多也很容易上手。
也就是说，图服务的提供方确实是可以优化 <code>io()</code> 的，一般可以用那些（他们提供的）导入导出工具的实现来覆盖TinkerPop上面描述的实现即可。</p>
</div>
<div class="paragraph">
<p>一个极好的实践是在<a href="#hadoop-gremlin">HadoopGraph</a>中，<a href="#sparkgraphcomputer">SparkGraphComputer</a>内部使用<a href="#clonevertexprogram">CloneVertexProgram</a>
覆盖掉了原有的单线程实现，提供了高级的OLAP类型的批量导入导出功能。使用这个模块，Hadoop的 <code>InputFormat</code> 或者 <code>OutputFormat</code> 就可以支持
任意规格的图的导入导出。</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
远程Gremlin控制台或者使用Gremlin语言变种（Gremlin Language Variant, GLV）的用户（比如gremlin-python），这些集成了
<code>io()</code> 单步的，需要记得，这些 <code>read()</code> 或 <code>write()</code> 操作都是不是在本地发生而是在远端的服务器上。所以制定的导入导出文件必须能够
被服务器访问到
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>GraphSON和Gryo 格式可以为用户和图服务提供商提供串行化的扩展。可以通过 <code>IoRegistry</code> 的来实现这些扩展。<code>IoRegistry</code> 依赖使用
<code>with()</code> 选项和 <code>IO.registry</code> 键才能被使用。<code>IO.registry</code> 键对应的值可以在 <code>IoRegistry</code> 的实例或
实现类的类名这二者之一选择</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">g.io(someInputFile).
    with(IO.reader, IO.gryo).
    with(IO.registry, TinkerIoRegistryV3d0.instance())
  read().iterate()
g.io(someOutputFile).
    with(IO.writer,IO.graphson).
    with(IO.registry, <span class="string"><span class="delimiter">&quot;</span><span class="content">org.apache.tinkerpop.gremlin.tinkergraph.structure.TinkerIoRegistryV3d0</span><span class="delimiter">&quot;</span></span>)
  write().iterate()</code></pre>
</div>
</div>
<div class="paragraph">
<p>明显的，GLVs（Gremlin语言变种）一般都会选择后者（传入类名的方式）因为它们没法创建一个 <code>IoRegistry</code> 实例并传递到服务器。
（<code>IoRegistry</code> 也不一定是按需要串行化的）</p>
</div>
<div class="paragraph">
<p><code>io()</code> 集成的这些类型的版本号（例如GraphSON 2.0或3.0）是在早期 <code>IO.reader</code> 和 <code>IO.writer</code> 的配置或者默认选项决定的。
默认的版本号永远是当前TinkerPop最新的版本。当然，图服务提供商也能够直接覆盖这些默认值，要获取详细的配置信息，需要查阅相应的图数据库文档</p>
</div>
<div class="paragraph">
<p>关于 <code>GraphReader</code> 和 <code>GraphWriter</code> 的更多配置信息（比如标准化GraphSON的输出，或者禁止Gryo的类注册）：在创建相应的
<code>GraphReader</code> 和 <code>GraphWriter</code> 对象时使用 <code>build()</code> 方法，并直接将其应用上去就可以了。<code>IO.reader</code> 或 <code>IO.writer</code>
的参数都可以直接接受这些对象。当然，这些基于JVM的操作对于GLVs（Gremlin语言变种）来说不可用</p>
</div>
<div class="paragraph">
<p><a id="_graphml_reader_writer"></a></p>
</div>
<div class="sect3">
<h4 id="graphml"><a class="anchor" href="#graphml"></a>GraphML</h4>
<div class="imageblock">
<div class="content">
<img src="./images/gremlin-graphml.png" alt="gremlin graphml" width="350">
</div>
</div>
<div class="paragraph">
<p><a href="http://graphml.graphdrawing.org/">GraphML</a> 类型的文件是一种常用的基于xml图的描述方式。
它也是TinkerPop内部的一种可靠的可插拔的格式，也被各种图相关的工具和库所支持。
这样说，如果想要去让TinkerPop和外部的图数据源来连接，GraphML可能是最好的选择了。典型应用有：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>使用<a href="https://networkx.github.io/">NetworkX</a>来生成一张图，用GraphML输出并导入到TinkerPop</p>
</li>
<li>
<p>生成一个子图，导出GraphML，并使用<a href="https://gephi.org/">Gephi</a>来生成可视化的图标.</p>
</li>
<li>
<p>将整个图数据迁移到一个不支持TinkerPop的图数据库系统</p>
</li>
</ul>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
GraphML是一种“有损”的格式，因为它只支持一些属性的原语值（primitive values），并不支持所有 <code>Graph</code>
结构的变量。它对原语外哪些“不认识”的将使用 <code>toString</code> 来串行化属性
</td>
</tr>
</table>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
GraphML只是一种规范，它允许 <code>&lt;edge&gt;</code> 元素（边） 和 <code>&lt;node&gt;</code> 元素（顶点）以任意顺序呈现。
很多软件系统（包括TinkerPop的 <code>GraphMLWriter</code> ）在写GraphML时，都把 <code>&lt;node&gt;</code> 写在了 <code>&lt;edge&gt;</code> 前。
但是需要着重注意的是，<code>GraphMLReader</code> 读数据的顺序是很关键的。如果一个 <code>&lt;edge&gt;</code> 元素在 <code>&lt;node&gt;</code> 顶点元素前出现，
那么顶点（label）的标签就被忽略了。所以如果标签对图很重要，那么所有的 <code>&lt;node&gt;</code> 元素 必须排序在 <code>&lt;edge&gt;</code> 元素前
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">g.io(<span class="string"><span class="delimiter">&quot;</span><span class="content">graph.xml</span><span class="delimiter">&quot;</span></span>).read().iterate()
g.io(<span class="string"><span class="delimiter">&quot;</span><span class="content">graph.xml</span><span class="delimiter">&quot;</span></span>).write().iterate()</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
如果使用了TinkerPop 2.x 生成的GraphML，需要查阅这些不兼容的条目
<a href="http://tinkerpop.apache.org/docs/3.4.1/upgrade/#graphml-format">升级指南</a>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><a id="graphson-reader-writer"></a></p>
</div>
</div>
<div class="sect3">
<h4 id="graphson"><a class="anchor" href="#graphson"></a>GraphSON</h4>
<div class="imageblock">
<div class="content">
<img src="./images/gremlin-graphson.png" alt="gremlin graphson" width="350">
</div>
</div>
<div class="paragraph">
<p>GraphSON 是TinkerPop早期版本 <a href="http://json.org/">JSON</a> 对JSON格式的扩展
请注意TinkerPop的GraphSON是不向前兼容的。GraphSON也有一些非TinkerPop的图相关系统的支持，但它比较适合两种场景：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>倾向于实用文本的方式来描述图和它的元素（比如调试，代码管理等）</p>
</li>
<li>
<p>这些图和图的元素不是被基于JVM的代码所使用（比如JavaScript， Python， .NET等）</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">g.io(<span class="string"><span class="delimiter">&quot;</span><span class="content">graph.json</span><span class="delimiter">&quot;</span></span>).read().iterate()
g.io(<span class="string"><span class="delimiter">&quot;</span><span class="content">graph.json</span><span class="delimiter">&quot;</span></span>).write().iterate()</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Additional documentation for GraphSON can be found in the <a href="http://tinkerpop.apache.org/docs/3.4.1/dev/io/#graphson">IO Reference</a>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><a id="gryo-reader-writer"></a></p>
</div>
</div>
<div class="sect3">
<h4 id="gryo"><a class="anchor" href="#gryo"></a>Gryo</h4>
<div class="imageblock">
<div class="content">
<img src="./images/gremlin-kryo.png" alt="gremlin kryo" width="400">
</div>
</div>
<div class="paragraph">
<p><a href="https://github.com/EsotericSoftware/kryo">Kryo</a> 是在JVM上的一个常用的串行化包。
Gremlin-Kryo 可以以二进制串行化  <code>Graph</code> ，并应用在可以在JVM之上运行的语言中。
它设计时考虑到了空间的优化、无损的格式转换，所以是TinkerPop图数据技术栈中的标准格式。
下面列表是一些常用的场景：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>将Gremlin结构体迁移到其他系统（比如从 <code>TinkerGraph</code> 到 <code>Neo4jGraph</code>）</p>
</li>
<li>
<p>将图中单独的元素串行化，并通过网络发送到其他JVM系统中</p>
</li>
<li>
<p>内存（in-memory）图或者子图的备份</p>
</li>
</ul>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
Kryo在迁移Gremlin结构时并不损失数据，但是更重要的是要考虑 <code>Graph</code> 的各个功能在另外迁移到的系统中是否支持。
如果不是这样（迁移至的系统不支持），那么就会导致错误的发生
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">g.io(<span class="string"><span class="delimiter">&quot;</span><span class="content">graph.kryo</span><span class="delimiter">&quot;</span></span>).read().iterate()
g.io(<span class="string"><span class="delimiter">&quot;</span><span class="content">graph.kryo</span><span class="delimiter">&quot;</span></span>).write().iterate()</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>更多参考</strong></p>
</div>
<div class="paragraph">
<p><a href="http://tinkerpop.apache.org/javadocs/3.4.1/core/org/apache/tinkerpop/gremlin/process/traversal/dsl/graph/GraphTraversalSource.html#io-java.lang.String-"><code>io(String)</code></a></p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="is-step"><a class="anchor" href="#is-step"></a>Is Step</h3>
<div class="paragraph">
<p><code>is()</code> (<strong>filter</strong>) 单步可以用于使用标量条件进行过滤</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Python"></i>
</td>
<td class="content">
<div class="paragraph">
<p><code>is</code> 是Python的保留字，所以要使用 <code>is_()</code> 来描述Gremlin</p>
</div>
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre>g.V().values('age').is(32)
g.V().values('age').is(lte(30))
g.V().values('age').is(inside(30, 40))
g.V().where(__.in('created').count().is(1)).values('name') <i class="conum" data-value="1"></i><b>(1)</b>
g.V().where(__.in('created').count().is(gte(2))).values('name') <i class="conum" data-value="2"></i><b>(2)</b>
g.V().where(__.in('created').values('age').
                           mean().is(inside(30d, 35d))).values('name') <i class="conum" data-value="3"></i><b>(3)</b></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>找到只有一个作者的项目工程</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>找到那些有大于两个作者的项目工程</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>找到作者的age在30到35之间的项目工程</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><strong>更多参考</strong></p>
</div>
<div class="paragraph">
<p><a href="http://tinkerpop.apache.org/javadocs/3.4.1/core/org/apache/tinkerpop/gremlin/process/traversal/dsl/graph/GraphTraversal.html#is-java.lang.Object-"><code>is(Object)</code></a>,
<a href="http://tinkerpop.apache.org/javadocs/3.4.1/core/org/apache/tinkerpop/gremlin/process/traversal/dsl/graph/GraphTraversal.html#is-org.apache.tinkerpop.gremlin.process.traversal.P-"><code>is(P)</code></a>,
<a href="http://tinkerpop.apache.org/javadocs/3.4.1/core/org/apache/tinkerpop/gremlin/process/traversal/P.html"><code>P</code></a></p>
</div>
</div>
<div class="sect2">
<h3 id="key-step"><a class="anchor" href="#key-step"></a>Key Step</h3>
<div class="paragraph">
<p><code>key()</code>(<strong>map</strong>) 单步接受一个 <code>Property</code> 并且从中获取键</p>
</div>
<div class="listingblock">
<div class="content">
<pre>g.V(1).properties().key()
g.V(1).properties().properties().key()</pre>
</div>
</div>
<div class="paragraph">
<p><strong>更多参考</strong></p>
</div>
<div class="paragraph">
<p><a href="http://tinkerpop.apache.org/javadocs/3.4.1/core/org/apache/tinkerpop/gremlin/process/traversal/dsl/graph/GraphTraversal.html#key--"><code>key()</code></a></p>
</div>
</div>
<div class="sect2">
<h3 id="label-step"><a class="anchor" href="#label-step"></a>Label Step</h3>
<div class="paragraph">
<p><code>label()</code>(<strong>map</strong>) 单步接受一个 <code>Element</code> 并且从中获取标签</p>
</div>
<div class="listingblock">
<div class="content">
<pre>g.V().label()
g.V(1).outE().label()
g.V(1).properties().label()</pre>
</div>
</div>
<div class="paragraph">
<p><strong>更多参考</strong></p>
</div>
<div class="paragraph">
<p><a href="http://tinkerpop.apache.org/javadocs/3.4.1/core/org/apache/tinkerpop/gremlin/process/traversal/dsl/graph/GraphTraversal.html#label--"><code>label()</code></a></p>
</div>
</div>
<div class="sect2">
<h3 id="limit-step"><a class="anchor" href="#limit-step"></a>Limit Step</h3>
<div class="paragraph">
<p><code>limit()</code> 单步是一个类似 <a href="#range-step">`range()`单步</a> 的实现，不过它的取值下界为0</p>
</div>
<div class="listingblock">
<div class="content">
<pre>g.V().limit(2)
g.V().range(0, 2)</pre>
</div>
</div>
<div class="paragraph">
<p><code>limit()</code> 单步同样可以使用 <code>Scope.local</code>，这样它就用来操作后面传入的集合
下面的例子使用 <a href="#the-crew-toy-graph">The Crew</a> 这个模型集合</p>
</div>
<div class="listingblock">
<div class="content">
<pre>g.V().valueMap().select('location').limit(local,2) <i class="conum" data-value="1"></i><b>(1)</b>
g.V().valueMap().limit(local, 1) <i class="conum" data-value="2"></i><b>(2)</b></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>使用 <code>List&lt;String&gt;</code> 来存储顶点，每个保存2个location</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>用 <code>Map&lt;String, Object&gt;</code> 来存储顶点，但只保存第一个属性</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><strong>更多参考</strong></p>
</div>
<div class="paragraph">
<p><a href="http://tinkerpop.apache.org/javadocs/3.4.1/core/org/apache/tinkerpop/gremlin/process/traversal/dsl/graph/GraphTraversal.html#limit-long-"><code>limit(long)</code></a>,
<a href="http://tinkerpop.apache.org/javadocs/3.4.1/core/org/apache/tinkerpop/gremlin/process/traversal/dsl/graph/GraphTraversal.html#limit-org.apache.tinkerpop.gremlin.process.traversal.Scope-long-"><code>limit(Scope,long)</code></a>
<a href="http://tinkerpop.apache.org/javadocs/3.4.1/core/org/apache/tinkerpop/gremlin/process/traversal/Scope.html"><code>Scope</code></a></p>
</div>
</div>
<div class="sect2">
<h3 id="local-step"><a class="anchor" href="#local-step"></a>Local Step</h3>
<div class="imageblock">
<div class="content">
<img src="./images/local-step.png" alt="local step" width="450">
</div>
</div>
<div class="paragraph">
<p><code>GraphTraversal</code> 操作连续的对象流。很多场景下，在对象流中操作一个元素是很关键的。所以 <code>local()</code> (<strong>branch</strong>) 单步就用来
做这样一个“局部对象”的遍历计算。
下面的例子使用 <a href="#the-crew-toy-graph">The Crew</a> 这个模型集合</p>
</div>
<div class="listingblock">
<div class="content">
<pre>g.V().as('person').
      properties('location').order().by('startTime',asc).limit(2).value().as('location').
      select('person','location').by('name').by() <i class="conum" data-value="1"></i><b>(1)</b>
g.V().as('person').
      local(properties('location').order().by('startTime',asc).limit(2)).value().as('location').
      select('person','location').by('name').by() <i class="conum" data-value="2"></i><b>(2)</b></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>根据startTime的历史，找到两个人和他们的相应的location</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>对每个人都找到他们出现的两个最早的出现点</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>除了 <code>local()</code> 包含起来的使用局部对象的部分遍历之外，这两个遍历看起来几乎相同。
local单步在功能上非常像<a href="#general-steps">Flat Map Step</a>所以比较难以理解。
<code>local()</code> 将通过内部遍历将迭代器进行下去，而不是使用切分（splitting）或者克隆（cloning）来进行分发。
所以它是一个没有局部处理的“全局遍历”。它的使用很微妙，主要是用来做应用的编译优化（比如实现 <code>TraversalStrategy</code>）。
另外的一个例子是：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>g.V().both().barrier().flatMap(groupCount().by("name"))
g.V().both().barrier().local(groupCount().by("name"))</pre>
</div>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
匿名的 <code>local()</code> 遍历“局部的”处理当前的对象。在OLAP系统中当原子计算一个“星型图”（图单元）时，
匿名遍历本身不能离开这个局部的“星型图”的界线本身。也就说，计算不能到其他非（“星型图”）的顶点和边上去
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
【中文添加，方便读者理解】<code>local</code> 这个的解释翻译过来很拗口，主要是理解遍历本身在local中的运行。
遍历流本身一旦遇到local，看起来就是并行的执行了。内部并不是自己将自己clone一份传递到多个local遍历中，这也是文献要传达的意思，
一个是表现起来像一个flat map，其实内部实现还是一个全局的执行
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><strong>更多参考</strong></p>
</div>
<div class="paragraph">
<p><a href="http://tinkerpop.apache.org/javadocs/3.4.1/core/org/apache/tinkerpop/gremlin/process/traversal/dsl/graph/GraphTraversal.html#local-org.apache.tinkerpop.gremlin.process.traversal.Traversal-"><code>local(Traversal)</code></a></p>
</div>
</div>
<div class="sect2">
<h3 id="loops-step"><a class="anchor" href="#loops-step"></a>Loops Step</h3>
<div class="paragraph">
<p><code>loops()</code> (<strong>map</strong>) 单步提取遍历器（<code>Traverser</code>）当前循环的数目</p>
</div>
<div class="listingblock">
<div class="content">
<pre>g.V().emit(__.has("name", "marko").or().loops().is(2)).repeat(__.out()).values("name")</pre>
</div>
</div>
<div class="paragraph">
<p><strong>更多参考</strong></p>
</div>
<div class="paragraph">
<p><a href="http://tinkerpop.apache.org/javadocs/3.4.1/core/org/apache/tinkerpop/gremlin/process/traversal/dsl/graph/GraphTraversal.html#loops--"><code>loops()</code></a></p>
</div>
</div>
<div class="sect2">
<h3 id="match-step"><a class="anchor" href="#match-step"></a>Match Step</h3>
<div class="paragraph">
<p><code>match()</code>(<strong>map</strong>) 单步提供一个<a href="http://en.wikipedia.org/wiki/Declarative_programming">描述性编程</a>类型的基于
<a href="http://en.wikipedia.org/wiki/Pattern_matching">模式匹配</a>语义的图查询方式。
用户使用 <code>match()</code> 来提供一组“遍历片段”，统称为模式。这些定义的变量在执行 <code>match()</code> 的整个过程中都为真。
当遍历器在进行 <code>match()</code> 单步时，一个注册的 <code>MatchAlgorithm</code> 的算法将用于分析当前遍历器的状态（比如它的基于<a href="#path-data-structure">path data</a>的历史），
运行态遍历状态的统计信息，并返回一个遍历模式，用于遍历器接下来执行。
默认的 <code>MatchAlgorithm</code> 算法叫做 <code>CountMatchAlgorithm</code>，它根据对过滤功能的模式排序来动态的调整模式匹配的执行计划。
（比如，优先执行大集合的reduce操作）。
对于一些特定的特大图，程序员也不清楚图的状态统计（比如有多少条 <code>knows</code> 和多少个 <code>worksFor</code> 的边）。这样使用 <code>match()</code> 操作就
很有好处，因为特定的优化执行方案就会被自动执行。再者，有些查询用 <code>match()</code> 来表达也比使用单路遍历容易得多。</p>
</div>
<div class="literalblock">
<div class="content">
<pre>"谁created了'lop'这个工程？并且这个created这个工程的人中，谁的age是29？返回2个创建者"</pre>
</div>
</div>
<div class="imageblock">
<div class="content">
<img src="./images/match-step.png" alt="match step" width="500">
</div>
</div>
<div class="listingblock">
<div class="content">
<pre>g.V().match(
        __.as('a').out('created').as('b'),
        __.as('b').has('name', 'lop'),
        __.as('b').in('created').as('c'),
        __.as('c').has('age', 29)).
      select('a','c').by('name')</pre>
</div>
</div>
<div class="paragraph">
<p>注意上例可以用如下这种简洁的方式来写，也表明了标准的内部遍历可以随意的被定义</p>
</div>
<div class="listingblock">
<div class="content">
<pre>g.V().match(
        __.as('a').out('created').has('name', 'lop').as('b'),
        __.as('b').in('created').has('age', 29).as('c')).
      select('a','c').by('name')</pre>
</div>
</div>
<div class="paragraph">
<p>为了提高可读性，<code>as()</code> 单步可以提供有意义的标签来更好的映射数据域。前面的查询用下面的展示更具有描述性</p>
</div>
<div class="listingblock">
<div class="content">
<pre>g.V().match(
        __.as('creators').out('created').has('name', 'lop').as('projects'), <i class="conum" data-value="1"></i><b>(1)</b>
        __.as('projects').in('created').has('age', 29).as('cocreators')). <i class="conum" data-value="2"></i><b>(2)</b>
      select('creators','cocreators').by('name') <i class="conum" data-value="3"></i><b>(3)</b></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>找到“created”东西的顶点，作为“creators”，然后找到它们name为lop的顶点，作为“projects”</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>使用这些“projects”的顶点，找到created它们的29岁的成员，作为“cocreators”</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>返回“creators”和“cocreators”的name</td>
</tr>
</table>
</div>
<div id="grateful-dead" class="imageblock">
<div class="content">
<img src="./images/grateful-dead-schema.png" alt="grateful dead schema" width="475">
</div>
<div class="title">Figure 1. Grateful Dead</div>
</div>
<div class="paragraph">
<p><code>Match</code> 单步可以使Gremlin具有<a href="http://en.wikipedia.org/wiki/SPARQL">SPARQL</a>类似的功能。
正如SPARQL，单步可以链接一组模式，然后应用于图上。比如说，下面的遍历过程精确查找那些Jerry Garcia创作且演唱的歌。
（使用分布在 <code>data/</code> 目录的渐亡图）</p>
</div>
<div class="listingblock">
<div class="content">
<pre>g = graph.traversal()
g.io('data/grateful-dead.xml').read().iterate()
g.V().match(
        __.as('a').has('name', 'Garcia'),
        __.as('a').in('writtenBy').as('b'),
        __.as('a').in('sungBy').as('b')).
      select('b').values('name')</pre>
</div>
</div>
<div class="paragraph">
<p><code>match()</code> 有一些功能是与SPARQL不同的，例如：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>g.V().match(
        __.as('a').out('created').has('name','lop').as('b'), <i class="conum" data-value="1"></i><b>(1)</b>
        __.as('b').in('created').has('age', 29).as('c'),
        __.as('c').repeat(out()).times(2)). <i class="conum" data-value="2"></i><b>(2)</b>
      select('c').out('knows').dedup().values('name') <i class="conum" data-value="3"></i><b>(3)</b></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><strong>任意复杂度的模式</strong>：<code>match()</code> 并不严格要求模式不超过三个，或者仅限于属性路径</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td><strong>支持递归</strong>： <code>match()</code> 支持在模式内使用单步进行判断择路，包含使用 <code>repeat()</code></td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td><strong>命令式/声明式语义的混合</strong>：无论是在 `match()`单步前后都可以使用经典的Gremlin遍历</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>对#3的引申理解：可以将指令式语义转换为声明式语义，或者指令式本身，无限种可能</p>
</div>
<div class="listingblock">
<div class="content">
<pre>g.V().match(
        __.as('a').out('knows').as('b'),
        __.as('b').out('created').has('name','lop')).
      select('b').out('created').
        match(
          __.as('x').in('created').as('y'),
          __.as('y').out('knows').as('z')).
      select('z').values('name')</pre>
</div>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<code>match()</code> 单步是无状态的。遍历模式相关联的变量都存在遍历器的历史路径里。所以，
这些用于遍历中 <code>match()</code> 单步使用的变量，全局来说是唯一的。这样的好处是随后的 <code>where()</code>， <code>select()</code>， <code>match()</code>
等单步就可以使用一个相同的变量作分析
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>正如Gremlin所有的单步一样，<code>match()</code> 是个函数，
所以在 <code>match()</code> 函数能有内部的 <code>match()</code> ，这种使用方式是由Gremlin函数式运算的本质设计的自然结果。
（比如递归匹配）</p>
</div>
<div class="listingblock">
<div class="content">
<pre>g.V().match(
        __.as('a').out('knows').as('b'),
        __.as('b').out('created').has('name','lop'),
        __.as('b').match(
                     __.as('b').out('created').as('c'),
                     __.as('c').has('name','ripple')).
                   select('c').as('c')).
      select('a','c').by('name')</pre>
</div>
</div>
<div class="paragraph">
<p>如果一个使用了 <code>match()</code> 单步的遍历被某一步打了标签（如as），那么使用了 <code>match()</code> 的遍历器肯定也注定要绑一个特殊变量，
那么前面的单步就应该相应的打好标签</p>
</div>
<div class="listingblock">
<div class="content">
<pre>g.V().as('a').out('knows').as('b').
  match(
    __.as('b').out('created').as('c'),
    __.not(__.as('c').in('created').as('a'))).
  select('a','b','c').by('name')</pre>
</div>
</div>
<div class="paragraph">
<p>总共有三种类型的 <code>match()</code> 遍历模式</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><code>as('a')...as('b')</code>：遍历的开始和结束都有声明变量</p>
</li>
<li>
<p><code>as('a')...</code>：只有遍历开始有声明的变量</p>
</li>
<li>
<p><code>...</code>：没有生命的变量</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>如果在遍历模式的开头有一个变量那么它就 <strong>必须</strong> 当成一个在遍历历史路径中的标签而存在，否则遍历器就没法按照这个路径走下去。
如果遍历模式的后面有一个变量，那么情况是：如果变量已经存在于遍历的历史路径里，当前遍历器的位置 <strong>必须</strong> 与处于相同标签的历史位置匹配，
（比如相等）。然而，如果遍历器历史路径中不存在变量，那么当前的位置就被当成变量打上标签，变成一个为后续模式匹配而存在的相关变量。
如果模式匹配最后没有跟随一个结束标签，那么遍历器必须要在模式匹配中“幸存”（比如不因为没有匹配结果而被过滤掉）才能执行下一个模式匹配。
如果遍历模式没有开始标签，那么遍历器就能够在任意点沿路径执行，但只在这个模式上执行一次。因为遍历模式只执行一次且在遍历器的历史记录上也是只执行一次。
一个典型的用法是没有开始和结束标签的遍历模式一般和 <code>and()</code>， <code>or()</code>，<code>where()</code> 相连接。
一旦遍历器在所有的模式匹配中“幸存”（或者最少有一个 <code>or()</code> 存在），<code>match()</code> 将分析遍历器历史路径并生成一个 <code>Map&lt;String,Object&gt;</code>
绑定到遍历的下个单步操作</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
【中文添加，方便读者理解】这段话相当晦涩。其实要传达的意思是遍历中的变量的传递和自动绑定关系。一个as(label)实际上在一个Map结构中创建了
一个以label为key的对象，这个Map在这次遍历中是全局的（如上文）。这样，match()中的匿名遍历"__"引用的as就会尝试做自动绑定。
如果Map中有，就会按照label为key取出值，如果没有就会自动创建——所以区分了在遍历模式前标签和后标签的行为。另外的，匿名遍历其实是相当于回到遍历的开头。
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre>g.V().as('a').out().as('b'). <i class="conum" data-value="1"></i><b>(1)</b>
    match( <i class="conum" data-value="2"></i><b>(2)</b>
      __.as('a').out().count().as('c'), <i class="conum" data-value="3"></i><b>(3)</b>
      __.not(__.as('a').in().as('b')), <i class="conum" data-value="4"></i><b>(4)</b>
      or( <i class="conum" data-value="5"></i><b>(5)</b>
        __.as('a').out('knows').as('b'),
        __.as('b').in().count().as('c').and().as('c').is(gt(2)))).  <i class="conum" data-value="6"></i><b>(6)</b>
    dedup('a','c'). <i class="conum" data-value="7"></i><b>(7)</b>
    select('a','b','c').by('name').by('name').by() <i class="conum" data-value="8"></i><b>(8)</b></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>一个标准的在 <code>match()</code> 前对遍历打标签的操作</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>如果遍历器在进入 <code>match()</code> 的路径前有必须的标签，那么这些历史值就会被绑定</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>可以使用<a href="#a-note-on-barrier-steps">barrier单步</a>尽管它对模式进行本地计算（正如期望结果）</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>也可以使用 <code>not()</code> 来对模式取非</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>可以嵌套 <code>and()</code> 和 <code>or()</code> 单步来连接匹配过程</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>中缀和前缀连接符号都可以支持</td>
</tr>
<tr>
<td><i class="conum" data-value="7"></i><b>7</b></td>
<td>可以“区分”指定的标签组合</td>
</tr>
<tr>
<td><i class="conum" data-value="8"></i><b>8</b></td>
<td>绑定的值可以是不同的类型 —— 顶点a，顶点b，和long型的值c</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="using-where-with-match"><a class="anchor" href="#using-where-with-match"></a>使用 Where 来 Match</h4>
<div class="paragraph">
<p>Match单步通常与 <code>select()</code> （前文已述）和 <code>where()</code> 来连接，接下来讨论
<code>where()</code> 单步允许用户来对 <code>match()</code> 提供的结果集合进行进一步约束</p>
</div>
<div class="listingblock">
<div class="content">
<pre>g.V().match(
        __.as('a').out('created').as('b'),
        __.as('b').in('created').as('c')).
        where('a', neq('c')).
      select('a','c').by('name')</pre>
</div>
</div>
<div class="paragraph">
<p><code>where()</code> 单步可以传入一个 <code>P</code> 谓词函数（如上例）或者一个遍历本身，如下。
使用 <code>MatchPredicateStrategy</code> 时，<code>where()</code> 语句自动被折叠到 <code>match()</code> 中所以它同样可以被 <code>match()</code> 中的优化器覆盖到。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>traversal = g.V().match(
                    __.as('a').has(label,'person'), <i class="conum" data-value="1"></i><b>(1)</b>
                    __.as('a').out('created').as('b'),
                    __.as('b').in('created').as('c')).
                    where(__.as('a').out('knows').as('c')). <i class="conum" data-value="2"></i><b>(2)</b>
                  select('a','c').by('name'); null <i class="conum" data-value="3"></i><b>(3)</b>
traversal.toString() <i class="conum" data-value="4"></i><b>(4)</b>
traversal <i class="conum" data-value="5"></i><b>(5)</b> <i class="conum" data-value="6"></i><b>(6)</b>
traversal.toString() <i class="conum" data-value="7"></i><b>(7)</b></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>所有用于key匹配的 <code>has()</code> 单步遍历模式都会被拉到 <code>match()</code> 外面，让图系统能够利用索引查找来筛选过滤</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td><code>where()</code> 单步传入了一个遍历，其中使用了 <code>match()</code> 单步中使用的绑定的变量</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>一个有用的技巧，保证遍历不被Gremlin控制台进行迭代</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>在计划执行前查看遍历的文本描述</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>Gremlin 控制台将自动迭代执行迭代器，或者可迭代执行的对象</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>marko 和 josh 都是协同开发者并且 marko 认识 josh</td>
</tr>
<tr>
<td><i class="conum" data-value="7"></i><b>7</b></td>
<td>在执行计划被应用后，查看遍历的文本描述（从而 <code>where()</code> 被叠到 <code>match()</code> 里面）</td>
</tr>
</table>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<code>where()</code> 单步是一个过滤步，所以 <code>where()</code> 语句中的变量并不全局绑定到 <code>match()</code> 的遍历器路径里去。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><strong>更多参考</strong></p>
</div>
<div class="paragraph">
<p><a href="http://tinkerpop.apache.org/javadocs/3.4.1/core/org/apache/tinkerpop/gremlin/process/traversal/dsl/graph/GraphTraversal.html#match-org.apache.tinkerpop.gremlin.process.traversal.Traversal&#8230;&#8203;-"><code>match(Traversal...)</code></a></p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="math-step"><a class="anchor" href="#math-step"></a>Math Step</h3>
<div class="paragraph">
<p><code>math()</code> (<strong>math</strong>) 单步为Gremlin提供了科学计算功能。与普通的数学函数组合和嵌套的形式稍有不同，单步提供了一种可读性更好的
基于文本描述的数学处理器。
表达式中的变量被映射到Gremlin的作用域中——比如路径标签，副作用，或传入的映射的key等。
这个单步支持使用 <code>by()</code> 来按照变量首次在算式中被引用的顺序来进行调整。
注意“__”这个保留变量指的是当前传入 <code>math()</code> 单步的数字遍历器对象</p>
</div>
<div class="listingblock">
<div class="content">
<pre>g.V().as('a').out('knows').as('b').math('a + b').by('age')
g.V().as('a').out('created').as('b').
  math('b + a').
    by(both().count().math('_ + 100')).
    by('age')
g.withSideEffect('x',10).V().values('age').math('_ / x')
g.withSack(1).V(1).repeat(sack(sum).by(constant(1))).times(10).emit().sack().math('sin _')</pre>
</div>
</div>
<div class="paragraph">
<p>运算其中支持的运算符包括：<code>*</code>， <code>+</code>， <code>\</code>。 <code>^</code> 和 <code>%</code>。
另外，也支持下面的内置函数：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>abs</code>: 绝对值</p>
</li>
<li>
<p><code>acos</code>: 反余弦</p>
</li>
<li>
<p><code>asin</code>: 反正弦</p>
</li>
<li>
<p><code>atan</code>: 反正切</p>
</li>
<li>
<p><code>cbrt</code>: 立方根</p>
</li>
<li>
<p><code>ceil</code>: 向上取整</p>
</li>
<li>
<p><code>cos</code>: 余弦</p>
</li>
<li>
<p><code>cosh</code>: 双曲余弦</p>
</li>
<li>
<p><code>exp</code>: 自然指数 （<code>e^x</code>）</p>
</li>
<li>
<p><code>floor</code>: 向下取整</p>
</li>
<li>
<p><code>log</code>: 自然对数（注意不是ln）</p>
</li>
<li>
<p><code>log10</code>: 对数（10为底）</p>
</li>
<li>
<p><code>log2</code>: 对数（2为底）</p>
</li>
<li>
<p><code>sin</code>: 正弦</p>
</li>
<li>
<p><code>sinh</code>: 双曲正弦</p>
</li>
<li>
<p><code>sqrt</code>: 平方根</p>
</li>
<li>
<p><code>tan</code>: 正切</p>
</li>
<li>
<p><code>tanh</code>: 双曲正切</p>
</li>
<li>
<p><code>signum</code>: 符号函数</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>更多参考</strong></p>
</div>
<div class="paragraph">
<p><a href="http://tinkerpop.apache.org/javadocs/3.4.1/core/org/apache/tinkerpop/gremlin/process/traversal/dsl/graph/GraphTraversal.html#math-java.lang.String-"><code>math(String)</code></a></p>
</div>
</div>
<div class="sect2">
<h3 id="max-step"><a class="anchor" href="#max-step"></a>Max Step</h3>
<div class="paragraph">
<p><code>max()</code> (<strong>map</strong>) 单步找到可对比对象流中按序后的最后一个对象。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>g.V().values('age').max()
g.V().repeat(both()).times(3).values('age').max()
g.V().values('name').max()</pre>
</div>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<code>max(local)</code> 找到当前局部对象的最大值（而不是遍历流的最大值）。
这对于 <code>Collection</code> 和 <code>Comparable</code> 类型对象生效
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><strong>更多参考</strong></p>
</div>
<div class="paragraph">
<p><a href="http://tinkerpop.apache.org/javadocs/3.4.1/core/org/apache/tinkerpop/gremlin/process/traversal/dsl/graph/GraphTraversal.html#max--"><code>max()</code></a>,
<a href="http://tinkerpop.apache.org/javadocs/3.4.1/core/org/apache/tinkerpop/gremlin/process/traversal/dsl/graph/GraphTraversal.html#max-org.apache.tinkerpop.gremlin.process.traversal.Scope-"><code>max(Scope)</code></a>,
<a href="http://tinkerpop.apache.org/javadocs/3.4.1/core/org/apache/tinkerpop/gremlin/process/traversal/Scope.html"><code>Scope</code></a></p>
</div>
</div>
<div class="sect2">
<h3 id="mean-step"><a class="anchor" href="#mean-step"></a>Mean Step</h3>
<div class="paragraph">
<p><code>mean()</code> (<strong>map</strong>) 单步从一串流数字中计算出平均值</p>
</div>
<div class="listingblock">
<div class="content">
<pre>g.V().values('age').mean()
g.V().repeat(both()).times(3).values('age').mean() <i class="conum" data-value="1"></i><b>(1)</b>
g.V().repeat(both()).times(3).values('age').dedup().mean()</pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>要注意遍历器被 <code>repeat()</code> 批量化了，所以有一些数字比其余的多，从而改变了平均值</td>
</tr>
</table>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<code>mean(local)</code> 计算的是当前的局部变量，而不是遍历流中的对象。
这对于 <code>Collection</code> 和 <code>Number</code> 类型对象生效
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><strong>更多参考</strong></p>
</div>
<div class="paragraph">
<p><a href="http://tinkerpop.apache.org/javadocs/3.4.1/core/org/apache/tinkerpop/gremlin/process/traversal/dsl/graph/GraphTraversal.html#mean--"><code>mean()</code></a>,
<a href="http://tinkerpop.apache.org/javadocs/3.4.1/core/org/apache/tinkerpop/gremlin/process/traversal/dsl/graph/GraphTraversal.html#mean-org.apache.tinkerpop.gremlin.process.traversal.Scope-"><code>mean(Scope)</code></a>,
<a href="http://tinkerpop.apache.org/javadocs/3.4.1/core/org/apache/tinkerpop/gremlin/process/traversal/Scope.html"><code>Scope</code></a></p>
</div>
</div>
<div class="sect2">
<h3 id="min-step"><a class="anchor" href="#min-step"></a>Min Step</h3>
<div class="paragraph">
<p>The <code>min()</code> (<strong>map</strong>) 单步找到可对比对象流中按序后的第一个对象。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>g.V().values('age').min()
g.V().repeat(both()).times(3).values('age').min()
g.V().values('name').min()</pre>
</div>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<code>min(local)</code> 找到当前局部对象的最小值（而不是遍历流的最小值）。
这对于 <code>Collection</code> 和 <code>Comparable</code> 类型对象生效
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><strong>更多参考</strong></p>
</div>
<div class="paragraph">
<p><a href="http://tinkerpop.apache.org/javadocs/3.4.1/core/org/apache/tinkerpop/gremlin/process/traversal/dsl/graph/GraphTraversal.html#min--"><code>min()</code></a>,
<a href="http://tinkerpop.apache.org/javadocs/3.4.1/core/org/apache/tinkerpop/gremlin/process/traversal/dsl/graph/GraphTraversal.html#min-org.apache.tinkerpop.gremlin.process.traversal.Scope-"><code>min(Scope)</code></a>,
<a href="http://tinkerpop.apache.org/javadocs/3.4.1/core/org/apache/tinkerpop/gremlin/process/traversal/Scope.html"><code>Scope</code></a></p>
</div>
</div>
<div class="sect2">
<h3 id="none-step"><a class="anchor" href="#none-step"></a>None Step</h3>
<div class="paragraph">
<p><code>none()</code> (<strong>filter</strong>) 把遍历流中所有的对象都过滤掉。它在两种场景下非常有用，一种是过滤远程执行的无用结果，一种是遍历器本身也不想产生什么副作用。
选择不返回对象的好处就是在服务端过滤掉结果，从而在客户端测上节省串行化和网络传输的开销。
通常这个单步不直接使用，<code>iterate()</code> 这个终止性单步在实际迭代结果前，遍历将被静默被添加一个 <code>none()</code></p>
</div>
<div class="paragraph">
<p><strong>更多参考</strong></p>
</div>
<div class="paragraph">
<p><a href="http://tinkerpop.apache.org/javadocs/current/core/org/apache/tinkerpop/gremlin/process/traversal/Traversal.html#none--<code>"><em>none()</em></a>
<a href="http://tinkerpop.apache.org/javadocs/current/core/org/apache/tinkerpop/gremlin/process/traversal/Traversal.html#iterate--</code>"><em>iterate()</em></a></p>
</div>
</div>
<div class="sect2">
<h3 id="not-step"><a class="anchor" href="#not-step"></a>Not Step</h3>
<div class="paragraph">
<p><code>not()</code> (<strong>filter</strong>) 单步首先确认传入遍历返回的结果对象，然后在遍历流中删除这些对象</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Groovy"></i>
</td>
<td class="content">
<div class="paragraph">
<p><code>not</code> 在Groovy中是个保留字，所以在用作匿名遍历一部分来使用Gremlin时，必须增加双下划线来引用 <code>__.not()</code></p>
</div>
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Python"></i>
</td>
<td class="content">
<div class="paragraph">
<p><code>not</code> 在Python中也是个保留字，所以如果使用Gremlin应该用 <code>not_()</code></p>
</div>
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre>g.V().not(hasLabel('person')).valueMap().with(WithOptions.tokens)
g.V().hasLabel('person').
  not(out('created').count().is(gt(1))).values('name')   <i class="conum" data-value="1"></i><b>(1)</b></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>josh 创建了两个工程，但vadas 没有创建任何的工程</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><strong>更多参考</strong></p>
</div>
<div class="paragraph">
<p><a href="http://tinkerpop.apache.org/javadocs/3.4.1/core/org/apache/tinkerpop/gremlin/process/traversal/dsl/graph/GraphTraversal.html#not-org.apache.tinkerpop.gremlin.process.traversal.Traversal-"><code>not(Traversal)</code></a></p>
</div>
</div>
<div class="sect2">
<h3 id="option-step"><a class="anchor" href="#option-step"></a>Option Step</h3>
<div class="paragraph">
<p><a href="#general-steps"><code>branch()</code></a> 和 <a href="#choose-step"><code>choose()</code></a> 单步的选择项</p>
</div>
<div class="paragraph">
<p><strong>更多参考</strong></p>
</div>
<div class="paragraph">
<p><a href="http://tinkerpop.apache.org/javadocs/3.4.1/core/org/apache/tinkerpop/gremlin/process/traversal/dsl/graph/GraphTraversal.html#option-M-org.apache.tinkerpop.gremlin.process.traversal.Traversal-"><code>option(Object,Traversal)</code></a>,
<a href="http://tinkerpop.apache.org/javadocs/3.4.1/core/org/apache/tinkerpop/gremlin/process/traversal/dsl/graph/GraphTraversal.html#option-org.apache.tinkerpop.gremlin.process.traversal.Traversal-"><code>option(Traversal)</code></a></p>
</div>
</div>
<div class="sect2">
<h3 id="optional-step"><a class="anchor" href="#optional-step"></a>Optional Step</h3>
<div class="paragraph">
<p><code>optional()</code> (<strong>branch/flatMap</strong>) 单步如果特定的遍历返回结果，那么将结果返回，否则就返回调用元素（比如 <code>identity()</code>）。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>g.V(2).optional(out('knows')) <i class="conum" data-value="1"></i><b>(1)</b>
g.V(2).optional(__.in('knows')) <i class="conum" data-value="2"></i><b>(2)</b></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>vadas 没有外向的knows边，所以返回vadas本身</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>vadas 的确有一条knows的in边，所以返回了marko</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>当与 <code>path</code> 或者 <code>tree</code> 连接使用时， <code>optional</code> 在拉出整个图时特别有用</p>
</div>
<div class="listingblock">
<div class="content">
<pre>g.V().hasLabel('person').optional(out('knows').optional(out('created'))).path() <i class="conum" data-value="1"></i><b>(1)</b></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>找到所有人中谁认识谁，然后接下来显示他创建的项目的每条路径</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><strong>更多参考</strong></p>
</div>
<div class="paragraph">
<p><a href="http://tinkerpop.apache.org/javadocs/3.4.1/core/org/apache/tinkerpop/gremlin/process/traversal/dsl/graph/GraphTraversal.html#optional-org.apache.tinkerpop.gremlin.process.traversal.Traversal-"><code>optional(Traversal)</code></a></p>
</div>
</div>
<div class="sect2">
<h3 id="or-step"><a class="anchor" href="#or-step"></a>Or Step</h3>
<div class="paragraph">
<p><code>or()</code> (<strong>filter</strong>) 单步保证最少一个提供的遍历能返回结果。请查阅<a href="#and-step"><code>and()</code></a> 语句</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Python"></i>
</td>
<td class="content">
<div class="paragraph">
<p><code>or</code> 在Python中是个保留字，所以如果使用Gremlin应该用 <code>or_()</code>.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre>g.V().or(
   __.outE('created'),
   __.inE('created').count().is(gt(1))).
     values('name')</pre>
</div>
</div>
<div class="paragraph">
<p><code>or()</code> 可以接受任意多个遍历。最少一个遍历产生至少一个结果才能让原来的遍历进行到下一步</p>
</div>
<div class="paragraph">
<p>同样可以使用<a href="http://en.wikipedia.org/wiki/Infix_notation">中缀标识法</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre>g.V().where(outE('created').or().outE('knows')).values('name')</pre>
</div>
</div>
<div class="paragraph">
<p><strong>更多参考</strong></p>
</div>
<div class="paragraph">
<p><a href="http://tinkerpop.apache.org/javadocs/3.4.1/core/org/apache/tinkerpop/gremlin/process/traversal/dsl/graph/GraphTraversal.html#or-org.apache.tinkerpop.gremlin.process.traversal.Traversal&#8230;&#8203;-"><code>or(Traversal...)</code></a></p>
</div>
</div>
<div class="sect2">
<h3 id="order-step"><a class="anchor" href="#order-step"></a>Order Step</h3>
<div class="paragraph">
<p>如果遍历流中的对象需要排序，那么就可以利用 <code>order()</code> (<strong>map</strong>) 单步来做</p>
</div>
<div class="listingblock">
<div class="content">
<pre>g.V().values('name').order()
g.V().values('name').order().by(desc)
g.V().hasLabel('person').order().by('age', asc).values('name')</pre>
</div>
</div>
<div class="paragraph">
<p>元素 <code>Element</code> 是遍历中最多被访问的对象。元素可以有很多个相关的属性（比如键值对）。
在很多场景下，一般都倾向于使用属性的对比来对遍历流中的对象来进行排序</p>
</div>
<div class="listingblock">
<div class="content">
<pre>g.V().values('name')
g.V().order().by('name',asc).values('name')
g.V().order().by('name',desc).values('name')</pre>
</div>
</div>
<div class="paragraph">
<p><code>order()</code> 单步允许用户提供任意多个应用于主和次的对比器（排序中使用）。
正如下例所示，主排序是根据外向的created的边的总数，而次排序是根据每个人的年龄</p>
</div>
<div class="listingblock">
<div class="content">
<pre>g.V().hasLabel('person').order().by(outE('created').count(), asc).
                                 by('age', asc).values('name')
g.V().hasLabel('person').order().by(outE('created').count(), asc).
                                 by('age', desc).values('name')</pre>
</div>
</div>
<div class="paragraph">
<p>可以 <code>Order.shuffle</code> 来在为遍历的特定的点上来进行随机排序</p>
</div>
<div class="listingblock">
<div class="content">
<pre>g.V().hasLabel('person').order().by(shuffle)
g.V().hasLabel('person').order().by(shuffle)</pre>
</div>
</div>
<div class="paragraph">
<p><code>order(local)</code> 排序的也是当前的局部变量，而不是遍历流中的对象。
这对于 <code>Collection</code> 和 <code>Map</code> 类型对象生效。遇到其他类型对象就原样地被返回。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>g.V().values('age').fold().order(local).by(desc) <i class="conum" data-value="1"></i><b>(1)</b>
g.V().values('age').order(local).by(desc) <i class="conum" data-value="2"></i><b>(2)</b>
g.V().groupCount().by(inE().count()).order(local).by(values, desc) <i class="conum" data-value="3"></i><b>(3)</b>
g.V().groupCount().by(inE().count()).order(local).by(keys, asc) <i class="conum" data-value="4"></i><b>(4)</b></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>将年龄收集到链表中，然后按降序对该列表进行排序</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>这些年龄，由于没有收集起来，所以 <code>order(local)</code> 相当于对单个数字的集合排序，什么也不做</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td><code>groupCount()</code> 集合中元素按照降序对values排序（见后面的NOTE，keys是Column这个枚举中的一个值）</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td><code>groupCount()</code> 集合中元素按照升序对keys进行排序（同见后面的NOTE）</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<code>values</code> 和 <code>keys</code> 都是 <code>Column</code> 这个枚举中的元素（内部实现），用于从 <code>Map</code>， <code>Map.Entry</code> 或 <code>Path</code> 中获取 "columns"
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
在3.3.4版本之前，排序是依靠 <code>Order.incr</code>，降序靠 <code>Order.decr</code>。这些实现已经废弃，建议使用示例中的查询样式，
这样的格式更常见。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><strong>更多参考</strong></p>
</div>
<div class="paragraph">
<p><a href="http://tinkerpop.apache.org/javadocs/3.4.1/core/org/apache/tinkerpop/gremlin/process/traversal/dsl/graph/GraphTraversal.html#order--"><code>order()</code></a>,
<a href="http://tinkerpop.apache.org/javadocs/3.4.1/core/org/apache/tinkerpop/gremlin/process/traversal/dsl/graph/GraphTraversal.html#order-org.apache.tinkerpop.gremlin.process.traversal.Scope-"><code>order(Scope)</code></a>,
<a href="http://tinkerpop.apache.org/javadocs/3.4.1/core/org/apache/tinkerpop/gremlin/process/traversal/Scope.html"><code>Scope</code></a>,
<a href="http://tinkerpop.apache.org/javadocs/3.4.1/core/org/apache/tinkerpop/gremlin/process/traversal/Order.html"><code>Order</code></a></p>
</div>
</div>
<div class="sect2">
<h3 id="pagerank-step"><a class="anchor" href="#pagerank-step"></a>PageRank Step</h3>
<div class="paragraph">
<p><code>pageRank()</code> (<strong>map</strong>/<strong>sideEffect</strong>) 使用<a href="#pagerankvertexprogram"><code>PageRankVertexProgram</code></a> 来计算<a href="http://en.wikipedia.org/wiki/PageRank">PageRank</a></p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<code>pageRank()</code> 单步是一个 <code>VertexComputing</code>（顶点计算）的单步，所以只有支持 <code>GraphComputer</code> (OLAP)的图系统才能使用。
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre>g = graph.traversal().withComputer()
g.V().pageRank().by('pageRank').values('pageRank')
g.V().hasLabel('person').
  pageRank().
    with(PageRank.edges, __.outE('knows')).
    with(PageRank.propertyName, 'friendRank').
  order().by('friendRank',desc).valueMap('name','friendRank')</pre>
</div>
</div>
<div class="paragraph">
<p>注意可以使用 <code>with()</code> 来调整算法的配置参数，
它使用 <code>PageRank</code> 这个结构提供的keys就可以自动的导入到Gremlin控制台上</p>
</div>
<div class="paragraph">
<p><a href="#explain-step"><code>explain()</code></a> 单步也能够帮助来理解遍历器怎样编译和分发 <code>GraphComputer</code> 任务</p>
</div>
<div class="listingblock">
<div class="content">
<pre>g = graph.traversal().withComputer()
g.V().hasLabel('person').
  pageRank().
    with(PageRank.edges, __.outE('knows')).
    with(PageRank.propertyName, 'friendRank').
  order().by('friendRank',desc).valueMap('name','friendRank').explain()</pre>
</div>
</div>
<div class="paragraph">
<p><strong>更多参考</strong></p>
</div>
<div class="paragraph">
<p><a href="http://tinkerpop.apache.org/javadocs/3.4.1/core/org/apache/tinkerpop/gremlin/process/traversal/dsl/graph/GraphTraversal.html#pageRank--"><code>pageRank()</code></a>,
<a href="http://tinkerpop.apache.org/javadocs/3.4.1/core/org/apache/tinkerpop/gremlin/process/traversal/dsl/graph/GraphTraversal.html#pageRank-double-"><code>pageRank(double)</code></a></p>
</div>
</div>
<div class="sect2">
<h3 id="path-step"><a class="anchor" href="#path-step"></a>Path Step</h3>
<div class="paragraph">
<p>在遍历中，遍历器当进行一些单步后，就会发生变化。这些遍历器的历史记录就可以用 <code>path()</code> 单步来检测它的路径实现。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="./images/path-step.png" alt="path step" width="650">
</div>
</div>
<div class="listingblock">
<div class="content">
<pre>g.V().out().out().values('name')
g.V().out().out().values('name').path()</pre>
</div>
</div>
<div class="paragraph">
<p>如果遍历器需要展示边，那么遍历器就要显式的遍历过这些边（如下面实例的outE）</p>
</div>
<div class="listingblock">
<div class="content">
<pre>g.V().outE().inV().outE().inV().path()</pre>
</div>
</div>
<div class="paragraph">
<p>遍历路径的元素，也能延迟的被 <code>by()</code> 来以round-robin的形式处理</p>
</div>
<div class="listingblock">
<div class="content">
<pre>g.V().out().out().path().by('name').by('age')</pre>
</div>
</div>
<div class="paragraph">
<p>最后，因为 <code>by()</code> 的延迟处理导致没法避免触发下一次遍历。
下面的遍历中，对每一个路径中便利过得对象，如果是一个person，那么就获取他created的东西；如果是一个创作品（工程），
那么就获取到所有创建它的人。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>g.V().out().out().path().by(
                   choose(hasLabel('person'),
                                 out('created').values('name'),
                                 __.in('created').values('name')).fold())</pre>
</div>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
遍历器的历史路径都存在Java的List结构中，所以生成路径信息本身这个操作就非常昂贵。遍历中有多少个遍历器，就有多少个List结构。
多说一句，在一个OLAP <a href="#graphcomputer"><code>GraphComputer</code></a>环境里，由于有太多顶点的并发访问，列举路径基本是不可能的。
在OLAP系统中的确也存在一些供便利其选择的优化方式，但当路径本身在计算的时（并且遍历器由于它的历史路径唯一时），优化本身也是无效的
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="path-data-structure"><a class="anchor" href="#path-data-structure"></a>Path Data Structure</h4>
<div class="paragraph">
<p><code>Path</code> 数据结构是一个有序对象的List链表结构。而每个对象又有一个 <code>Set&lt;String&gt;</code> 的标签项和其绑定。下面的给出的示例展示了 <code>Path</code>
API的使用和一个遍历如何生成带标签的路径</p>
</div>
<div class="imageblock">
<div class="content">
<img src="./images/path-data-structure.png" alt="path data structure" width="350">
</div>
</div>
<div class="listingblock">
<div class="content">
<pre>path = g.V(1).as('a').has('name').as('b').
              out('knows').out('created').as('c').
              has('name','ripple').values('name').as('d').
              identity().as('e').path().next()
path.size()
path.objects()
path.labels()
path.a
path.b
path.c
path.d == path.e</pre>
</div>
</div>
<div class="paragraph">
<p><strong>更多参考</strong></p>
</div>
<div class="paragraph">
<p><a href="http://tinkerpop.apache.org/javadocs/3.4.1/core/org/apache/tinkerpop/gremlin/process/traversal/dsl/graph/GraphTraversal.html#path--"><code>path()</code></a></p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="peerpressure-step"><a class="anchor" href="#peerpressure-step"></a>PeerPressure Step</h3>
<div class="paragraph">
<p><code>peerPressure()</code> (<strong>map</strong>/<strong>sideEffect</strong>) 单步使用 <code>PeerPressureVertexProgram</code> 来对顶点进行归类</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<code>peerPressure()</code> 单步属于 <code>VertexComputing</code> 步骤之一，所以它只能在支持 <code>GraphComputer</code> (OLAP) 的图系统中使用
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre>g = graph.traversal().withComputer()
g.V().peerPressure().by('cluster').values('cluster')
g.V().hasLabel('person').
  peerPressure().
    with(PeerPressure.propertyName, 'cluster').
  group().
    by('cluster').
    by('name')</pre>
</div>
</div>
<div class="paragraph">
<p>注意可以使用 <code>with()</code> 来调整算法的配置参数，
它使用 <code>PeerPressure</code> 这个类结构提供的keys就可以自动的导入到Gremlin控制台上</p>
</div>
<div class="paragraph">
<p><strong>更多参考</strong></p>
</div>
<div class="paragraph">
<p><a href="http://tinkerpop.apache.org/javadocs/3.4.1/core/org/apache/tinkerpop/gremlin/process/traversal/dsl/graph/GraphTraversal.html#peerPressure--"><code>peerPressure()</code></a></p>
</div>
</div>
<div class="sect2">
<h3 id="profile-step"><a class="anchor" href="#profile-step"></a>Profile Step</h3>
<div class="paragraph">
<p><code>profile()</code> (<strong>sideEffect</strong>) 单步是用来允许开发者来采样分析遍历的统计信息，比如单步执行，计数器等</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
对编译器进行采样分析会对遍历本身造成性能影响。这些额外开销大多数可以从采样分析结果中去除，但统计时间并不精确。
所以，最好通过两个时间对比来看（性能）
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre>g.V().out('created').repeat(both()).times(3).hasLabel('person').values('age').sum().profile()</pre>
</div>
</div>
<div class="paragraph">
<p><code>profile()</code> 单步生成一个 <code>TraversalMetrics</code> “副作用”对象，它包含如下信息：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>Step</code>：当前在遍历中被分析的单步</p>
</li>
<li>
<p><code>Count</code>：通过该单步的 <em>呈现</em> 的遍历器的计数</p>
</li>
<li>
<p><code>Traversers</code>：通过单步的遍历器的数目</p>
</li>
<li>
<p><code>Time (ms)</code>：发生在此单步的总执行时间</p>
</li>
<li>
<p><code>% Dur</code>：当前单步耗时比例</p>
</li>
</ul>
</div>
<div class="imageblock left">
<div class="content">
<img src="./images/gremlin-exercise.png" alt="gremlin exercise" width="120">
</div>
</div>
<div class="paragraph">
<p>理解 <code>Count</code> 和 <code>Traversers</code> 这两栏的区别很重要。遍历器是可以合并的，所以当两个遍历器走“相同”路时他们就被聚合成一个了。
这个新的遍历器有一个 <code>Traverser.bulk()</code> 来计算两个合并遍历器的bulk批量。另外的一点是，<code>Count</code> 代表的是这些 <code>Traverser.bulk()</code>
的和所以 <em>呈现</em> 而非列举了所有遍历器。所以 <code>Traversers</code> 栏将永远小于等于 <code>Count</code></p>
</div>
<div class="paragraph">
<p>同样可以提供一个保存“副作用”的键给 <code>profile()</code> 单步，这样可以在一些场景下用来先执行遍历的迭代，后续步骤来获取 <code>TraversalMetrics</code>，
如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>t = g.V().out('created').profile('metrics')
t.iterate()
metrics = t.getSideEffects().get('metrics')</pre>
</div>
</div>
<div class="paragraph">
<p>For traversal compilation information, please see <a href="#explain-step"><code>explain()</code></a>-step.</p>
</div>
<div class="paragraph">
<p><strong>更多参考</strong></p>
</div>
<div class="paragraph">
<p><a href="http://tinkerpop.apache.org/javadocs/3.4.1/core/org/apache/tinkerpop/gremlin/process/traversal/dsl/graph/GraphTraversal.html#profile--"><code>profile()</code></a>,
<a href="http://tinkerpop.apache.org/javadocs/3.4.1/core/org/apache/tinkerpop/gremlin/process/traversal/dsl/graph/GraphTraversal.html#profile-java.lang.String-"><code>profile(String)</code></a></p>
</div>
</div>
<div class="sect2">
<h3 id="project-step"><a class="anchor" href="#project-step"></a>Project Step</h3>
<div class="paragraph">
<p><code>project()</code> (<strong>map</strong>) 单步可以把当前对象映射成一个用提供的标签来索引的 <code>Map&lt;String,Object&gt;</code> 结构里。
它很像<a href="#select-step"><code>select()</code></a> 单步，只保存而不是获取并调整遍历器历史状态，但调整当前遍历器的状态。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>g.V().out('created').
  project('a','b').
    by('name').
    by(__.in('created').count()).
  order().by(select('b'),desc).
  select('a')
g.V().has('name','marko').
               project('out','in').
                 by(outE().count()).
                 by(inE().count())</pre>
</div>
</div>
<div class="paragraph">
<p><strong>更多参考</strong></p>
</div>
<div class="paragraph">
<p><a href="http://tinkerpop.apache.org/javadocs/3.4.1/core/org/apache/tinkerpop/gremlin/process/traversal/dsl/graph/GraphTraversal.html#project-java.lang.String-java.lang.String&#8230;&#8203;-"><code>project(String,String...)</code></a></p>
</div>
</div>
<div class="sect2">
<h3 id="program-step"><a class="anchor" href="#program-step"></a>Program Step</h3>
<div class="paragraph">
<p><code>program()</code> (<strong>map</strong>/<strong>sideEffect</strong>) 单步是用于在 <code>GraphComputer</code> 执行lambda表达式的单步。
传入一个<a href="#vertexprogram"><code>VertexProgram</code></a> 参数，且用于后来的相应的图处理。
所以，用户可以创建一个 <code>VertexProgram</code> 的实现并在遍历中执行，VertexProgram提供的配置参数有：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>gremlin.vertexProgramStep.rootTraversal</code> 是一个 <code>PureTraversal</code> 类型的根遍历的串行化</p>
</li>
<li>
<p><code>gremlin.vertexProgramStep.stepId</code> 是 <code>program()</code> 这个单步的执行时字符串类型的id</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>用户提供的 <code>VertexProgram</code> 能有效利用他们顶点的相关联信息。例如以下的使用示例。</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
开发 <code>VertexProgram</code> 是一个专家级行为。另外，做好一个能够高效在遍历中使用的 <code>VertexProgram</code> 也需要很多实践来佐证。
强烈推荐高级用户来阅读并深层次理解 Gremlin OLAP （<a href="#graphcomputer"><code>GraphComputer</code></a>）机制
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">private</span> TraverserSet&lt;<span class="predefined-type">Object</span>&gt; haltedTraversers;

<span class="directive">public</span> <span class="type">void</span> loadState(Graph graph, <span class="predefined-type">Configuration</span> configuration) {
  VertexProgram.super.loadState(graph, configuration);
  <span class="local-variable">this</span>.traversal = PureTraversal.loadState(configuration, VertexProgramStep.ROOT_TRAVERSAL, graph);
  <span class="local-variable">this</span>.programStep = <span class="keyword">new</span> TraversalMatrix&lt;&gt;(<span class="local-variable">this</span>.traversal.get()).getStepById(configuration.getString(ProgramVertexProgramStep.STEP_ID));
  <span class="comment">// 如果遍历的“副作用”在计算中将被使用，那么将其添加为一个内存计算key</span>
  <span class="local-variable">this</span>.memoryComputeKeys.addAll(MemoryTraversalSideEffects.getMemoryComputeKeys(<span class="local-variable">this</span>.traversal.get()));
  <span class="comment">// 如果主遍历要被复制，那么也创建一个内存计算的key</span>
  <span class="local-variable">this</span>.memoryComputeKeys.add(MemoryComputeKey.of(TraversalVertexProgram.HALTED_TRAVERSERS, Operator.addAll, <span class="predefined-constant">false</span>, <span class="predefined-constant">false</span>));
  <span class="comment">// 如果没有停止的遍历器，那么就返回一个空遍历器</span>
  <span class="local-variable">this</span>.haltedTraversers = TraversalVertexProgram.loadHaltedTraversers(configuration);
}

<span class="directive">public</span> <span class="type">void</span> storeState(<span class="predefined-type">Configuration</span> configuration) {
  VertexProgram.super.storeState(configuration);
  <span class="comment">// 如果停止的遍历器为空，那么什么也不做</span>
  TraversalVertexProgram.storeHaltedTraversers(configuration, <span class="local-variable">this</span>.haltedTraversers);
}

<span class="directive">public</span> <span class="type">void</span> setup(Memory memory) {
  <span class="keyword">if</span>(!<span class="local-variable">this</span>.haltedTraversers.isEmpty()) {
    <span class="comment">// 这里做你想对哪些停止的主遍历做的事情</span>
  }
  <span class="comment">// 一旦做了操作，也就不用在主遍历器里保留这些信息了</span>
  <span class="local-variable">this</span>.haltedTraversers = <span class="predefined-constant">null</span>;
}

<span class="directive">public</span> <span class="type">void</span> execute(Vertex vertex, Messenger messenger, Memory memory) {
  <span class="comment">// 一旦做了操作，也就不用在工作线程里保留这些信息了</span>
  once used, no need to keep that information around (workers)
  <span class="keyword">if</span>(<span class="predefined-constant">null</span> != <span class="local-variable">this</span>.haltedTraversers)
    <span class="local-variable">this</span>.haltedTraversers = <span class="predefined-constant">null</span>;
  <span class="keyword">if</span>(vertex.property(TraversalVertexProgram.HALTED_TRAVERSERS).isPresent()) {
    <span class="comment">// 在 execute() 中的haltedTraversers 代表那些正在进行遍历的遍历器（worker-traversal）</span>
    <span class="comment">// 比如，从g.V().out().program(...) 而来的遍历</span>
    TraverserSet&lt;<span class="predefined-type">Object</span>&gt; haltedTraversers = vertex.value(TraversalVertexProgram.HALTED_TRAVERSERS);
    <span class="comment">// 创建一个被停止的遍历器集合，一边在后续OLAP 任务链中使用</span>
    <span class="comment">// 这些正在工作的遍历器可能分布在整个图中</span>
    TraverserSet&lt;<span class="predefined-type">Object</span>&gt; newHaltedTraversers = <span class="keyword">new</span> TraverserSet&lt;&gt;();
    haltedTraversers.forEach(traverser -&gt; {
       newHaltedTraversers.add(traverser.split(traverser.get().toString(), <span class="local-variable">this</span>.programStep));
    });
    vertex.property(VertexProperty.Cardinality.single, TraversalVertexProgram.HALTED_TRAVERSERS, newHaltedTraversers);
    <span class="comment">// 可以在主遍历中，创建一些主遍历器（这也是将最终结果返回给用户的方法）</span>
    memory.add(TraversalVertexProgram.HALTED_TRAVERSERS,
               <span class="keyword">new</span> TraverserSet&lt;&gt;(<span class="local-variable">this</span>.traversal().get().getTraverserGenerator().generate(<span class="string"><span class="delimiter">&quot;</span><span class="content">an example</span><span class="delimiter">&quot;</span></span>, <span class="local-variable">this</span>.programStep, <span class="integer">1l</span>)));
  }

<span class="directive">public</span> <span class="type">boolean</span> terminate(Memory memory) {
  <span class="comment">// 主遍历器将包含很多停止的遍历器</span>
  <span class="keyword">assert</span> memory.exists(TraversalVertexProgram.HALTED_TRAVERSERS);
  TraverserSet&lt;<span class="predefined-type">String</span>&gt; haltedTraversers = memory.get(TraversalVertexProgram.HALTED_TRAVERSERS);
  <span class="comment">// 这里只有通过memory内存将这些遍历器发送给主遍历</span>
  <span class="keyword">assert</span> haltedTraversers.stream().map(Traverser::get).filter(s -&gt; s.equals(<span class="string"><span class="delimiter">&quot;</span><span class="content">an example</span><span class="delimiter">&quot;</span></span>)).findAny().isPresent();
  <span class="comment">// 这里将不包含分布在各个顶点上的工作遍历器</span>
  <span class="keyword">assert</span> !haltedTraversers.stream().map(Traverser::get).filter(s -&gt; !s.equals(<span class="string"><span class="delimiter">&quot;</span><span class="content">an example</span><span class="delimiter">&quot;</span></span>)).findAny().isPresent();
  <span class="keyword">return</span> <span class="predefined-constant">true</span>;
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
在 <code>gremlin-test</code> 中的 <code>ProgramTest</code> 测试实例中有一个叫做 <code>TestProgram</code> 的示例程序。它展示了各种在顶点程序中
复制遍历和遍历器信息到后续顶点OLAP计算链的方法
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>最后，一个使用 <code>PageRankVertexProgram</code> 而不是用<a href="#pagerank-step"><code>pageRank()</code></a> 单步的例子：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>g = graph.traversal().withComputer()
g.V().hasLabel('person').
  program(PageRankVertexProgram.build().property('rank').create(graph)).
    order().by('rank', asc).
  valueMap('name', 'rank')</pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="properties-step"><a class="anchor" href="#properties-step"></a>Properties Step</h3>
<div class="paragraph">
<p><code>properties()</code> (<strong>map</strong>) 单步从遍历流中提取单个 <code>Element</code> 的属性</p>
</div>
<div class="listingblock">
<div class="content">
<pre>g.V(1).properties()
g.V(1).properties('location').valueMap()
g.V(1).properties('location').has('endTime').valueMap()</pre>
</div>
</div>
<div class="paragraph">
<p><strong>更多参考</strong></p>
</div>
<div class="paragraph">
<p><a href="http://tinkerpop.apache.org/javadocs/3.4.1/core/org/apache/tinkerpop/gremlin/process/traversal/dsl/graph/GraphTraversal.html#properties-java.lang.String&#8230;&#8203;-"><code>properties(String...)</code></a></p>
</div>
</div>
<div class="sect2">
<h3 id="propertymap-step"><a class="anchor" href="#propertymap-step"></a>PropertyMap Step</h3>
<div class="paragraph">
<p><code>propertiesMap()</code> 单步生成一个用于描述元素诸多属性的Map结构数据</p>
</div>
<div class="listingblock">
<div class="content">
<pre>g.V().propertyMap()
g.V().propertyMap('age')
g.V().propertyMap('age','blah')
g.E().propertyMap()</pre>
</div>
</div>
<div class="paragraph">
<p><strong>更多参考</strong></p>
</div>
<div class="paragraph">
<p><a href="http://tinkerpop.apache.org/javadocs/3.4.1/core/org/apache/tinkerpop/gremlin/process/traversal/dsl/graph/GraphTraversal.html#propertyMap-java.lang.String&#8230;&#8203;-"><code>propertyMap(String...)</code></a></p>
</div>
</div>
<div class="sect2">
<h3 id="range-step"><a class="anchor" href="#range-step"></a>Range Step</h3>
<div class="paragraph">
<p>遍历过程中会生成很多遍历器执行，那么就可以使用 <code>range()</code> (<strong>filter</strong>) 单步来传入参数来允许特定的一部分遍历器执行。
当区间下界没有满足时，对象仍旧在被迭代。但在区间内（前闭后开）里是迭代器才被发出。当大于区间上界时，遍历将直接跳出迭代。
最后，如果上界值是 <code>-1</code>，那么所有在下界往上的迭代器都会被发出</p>
</div>
<div class="listingblock">
<div class="content">
<pre>g.V().range(0,3)
g.V().range(1,3)
g.V().range(1, -1)
g.V().repeat(both()).times(1000000).emit().range(6,10)</pre>
</div>
</div>
<div class="paragraph">
<p><code>range()</code> 单步也可以结合 <code>Scope.local</code> 来试用，这种情况下就是操作接下来的集合。下例就是可以为每条遍历路径生成一个
<code>Map&lt;String, String&gt;</code> 结构，但只包含第二个属性值（b这一步）</p>
</div>
<div class="listingblock">
<div class="content">
<pre>g.V().as('a').out().as('b').in().as('c').select('a','b','c').by('name').range(local,1,2)</pre>
</div>
</div>
<div class="paragraph">
<p>接下来的例子就是使用 <a href="#the-crew-toy-graph">The Crew</a> 这个数据模型，它生成一个只包含顶点第二和第三位置信息的 <code>List&lt;String&gt;</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre>g.V().valueMap().select('location').range(local, 1, 3)</pre>
</div>
</div>
<div class="paragraph">
<p><strong>更多参考</strong></p>
</div>
<div class="paragraph">
<p><a href="http://tinkerpop.apache.org/javadocs/3.4.1/core/org/apache/tinkerpop/gremlin/process/traversal/dsl/graph/GraphTraversal.html#range-long-long-"><code>range(long,long)</code></a>,
<a href="http://tinkerpop.apache.org/javadocs/3.4.1/core/org/apache/tinkerpop/gremlin/process/traversal/dsl/graph/GraphTraversal.html#range-org.apache.tinkerpop.gremlin.process.traversal.Scope-long-long-"><code>range(Scope,long,long)</code></a>,
<a href="http://tinkerpop.apache.org/javadocs/3.4.1/core/org/apache/tinkerpop/gremlin/process/traversal/Scope.html"><code>Scope</code></a></p>
</div>
</div>
<div class="sect2">
<h3 id="repeat-step"><a class="anchor" href="#repeat-step"></a>Repeat Step</h3>
<div class="imageblock">
<div class="content">
<img src="./images/gremlin-fade.png" alt="gremlin fade" width="350">
</div>
</div>
<div class="paragraph">
<p><code>repeat()</code> (<strong>branch</strong>)  单步用于按退出条件（predicate）来循环执行遍历。下面是使用 <code>repeat()</code> 的例子</p>
</div>
<div class="listingblock">
<div class="content">
<pre>g.V(1).repeat(out()).times(2).path().by('name') <i class="conum" data-value="1"></i><b>(1)</b>
g.V().until(has('name','ripple')).
      repeat(out()).path().by('name') <i class="conum" data-value="2"></i><b>(2)</b></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>do-while 语义，连续执行 <code>out</code> 两次</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>while-do 语义，如果遍历器遇到顶点name是ripple就退出</td>
</tr>
</table>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<code>repeat()</code> 有两个调整器：<code>until()</code> 和 <code>emit()</code>。
如果 <code>until()</code> 在 <code>repeat()</code> 后面出现那就是do/while循环。
如果 <code>until()</code> 在 <code>repeat()</code> 前面就是while/do循环。
如果 <code>emit()</code> 是在 <code>repeat()</code> 之后，那么就用于评估遍历器如何离开这个循环遍历。
如果 <code>emit()</code> 是在 <code>repeat()</code> 之前，那么就用于评估遍历器进入循环遍历之前对其进行评估。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code>repeat()</code> 单步同样支持“发出谓词”的操作，如果 <code>emit()</code> 中传入空参数就是认为是 <code>true</code> 所以无条件发出，
（<code>emit() == emit{true}</code>）。有了 <code>emit()</code> 后遍历器就被分成两步了，遍历器将退出代码段后再执行代码段（假如 <code>until()</code>
一直为真）</p>
</div>
<div class="listingblock">
<div class="content">
<pre>g.V(1).repeat(out()).times(2).emit().path().by('name') <i class="conum" data-value="1"></i><b>(1)</b>
g.V(1).emit().repeat(out()).times(2).path().by('name') <i class="conum" data-value="2"></i><b>(2)</b></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><code>emit()</code> 在 <code>repeat()</code> 后，所以发出操作在 <code>repeat()</code> 遍历执行后才开始。所以没有单顶点的路径存在。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td><code>emit()</code> 在 <code>repeat()</code> 前，那么所有发出操作在 <code>repeat()</code> 遍历执行前就开始了，所以存在单顶点路径</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code>emit()</code> 调节器可以接受任意多个谓词参数</p>
</div>
<div class="listingblock">
<div class="content">
<pre>g.V(1).repeat(out()).times(2).emit(has('lang')).path().by('name')</pre>
</div>
</div>
<div class="imageblock">
<div class="content">
<img src="./images/repeat-step.png" alt="repeat step" width="500">
</div>
</div>
<div class="listingblock">
<div class="content">
<pre>g.V(1).repeat(out()).times(2).emit().path().by('name')</pre>
</div>
</div>
<div class="paragraph">
<p>第一次执行 <code>repeat()</code> 后，顶点lop，vadas 和 josh 就可见了。这时 <code>loops==1</code> 所以遍历器继续。
但是因为发出谓词函数此处为真，所以这些顶点被发出（到遍历器）了。当执行下次 <code>repeat()</code> 时，遍历走过的顶点是ripple和lop
（如图，Josh created了两个项目，而lop和vadas没有出边），这时 <code>loops==2</code>，那么until 判断就失败，所以ripple和lop也被发出了。
最终的遍历器可以看到的顶点有lop，vadas，josh，ripple和lop.</p>
</div>
<div class="paragraph">
<p><code>repeat()</code> 单步也可以被嵌套到其他repeat中，或者 <code>emit()</code> <code>until()</code> 这些谓词中也都可以。
可以向它传递一个字符串，作为第一个参数来命名这个 <code>repeat()</code> 。在“命名”循环中，
可以使用 <code>loopName</code> （就是创建 <code>repeat()</code> 时传递的那个字符串）传递到 <code>loops(loopName)</code> 单步中，从而获取循环的次数</p>
</div>
<div class="listingblock">
<div class="content">
<pre>g.V(1).
  repeat(out("knows")).
    until(repeat(out("created")).emit(has("name", "lop"))) <i class="conum" data-value="1"></i><b>(1)</b>
g.V(6).
  repeat('a', both('created').simplePath()).
    emit(repeat('b', both('knows')).
           until(loops('b').as('b').where(loops('a').as('b'))).
  hasId(2)).dedup() <i class="conum" data-value="2"></i><b>(2)</b></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>从顶点1开始，一直沿着knows的外向边游走，知道找到有创建lop顶点的顶点</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>从顶点6开始，双向的游走created的边，找到那些顶点（与顶点6）有着与顶点2 knows的顶点同距离的那些顶点</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>最后注意 <code>emit()</code> 和 <code>until()</code> 都可以接受一个traversal</p>
</div>
<div class="paragraph">
<p>最后，注意 <code>emit()</code> 和 <code>until()</code> 都可以传入一个遍历，在这种情况下，判断的谓词就是 <code>traversal.hasNext()</code>
下面有几个例子</p>
</div>
<div class="listingblock">
<div class="content">
<pre>g.V(1).repeat(out()).until(hasLabel('software')).path().by('name') <i class="conum" data-value="1"></i><b>(1)</b>
g.V(1).emit(hasLabel('person')).repeat(out()).path().by('name') <i class="conum" data-value="2"></i><b>(2)</b>
g.V(1).repeat(out()).until(outE().count().is(0)).path().by('name') <i class="conum" data-value="3"></i><b>(3)</b></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>从顶点1开始，沿向外边游走，直到遇到一个software顶点</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>从顶点1开始的无限循环里，判断如果是person的顶点就发出，并沿外向边游走</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>从顶点1开始，一直沿外向边游走，直到找到没有边的顶点</td>
</tr>
</table>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
<code>emit()</code> 和 <code>until()</code> （非 <code>repeat()</code>）的匿名遍历本地的处理他们的当前对象。
在OLAP系统中，计算的原子单元是顶点本身和它相关联的“星型图”，匿名遍历不离开星型图本身的界限很重要。
换句话说，它们不能游走到其他相邻的顶点或者边。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><strong>更多参考</strong></p>
</div>
<div class="paragraph">
<p><a href="http://tinkerpop.apache.org/javadocs/3.4.1/core/org/apache/tinkerpop/gremlin/process/traversal/dsl/graph/GraphTraversal.html#repeat-org.apache.tinkerpop.gremlin.process.traversal.Traversal-"><code>repeat(Traversal)</code></a></p>
</div>
</div>
<div class="sect2">
<h3 id="sack-step"><a class="anchor" href="#sack-step"></a>Sack Step</h3>
<div class="imageblock right">
<div class="content">
<img src="./gremlin-sacks-running.png" alt="gremlin sacks running" width="175">
</div>
</div>
<div class="paragraph">
<p>遍历器可以携带一个内部结构，叫做“sack”。<code>sack()</code> (<strong>sideEffect</strong> 或 <strong>map</strong>) 单步就用来读写这些sacks。
每个遍历器可以使用 <code>GraphTraversal.withSack(initialValueSupplier,splitOperator?,mergeOperator?)</code> 来创建sack。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Initial value supplier</strong>: 一个用于提供遍历器sack初始值的 <code>Supplier</code></p>
</li>
<li>
<p><strong>Split operator</strong>:  一个当遍历器分列时克隆sack的 <code>UnaryOperator</code> （一元描述符，java functional接口） ，
如果没有给定分裂操作描述符，那么就使用 <code>UnaryOperator.identity()</code></p>
</li>
<li>
<p><strong>Merge operator</strong>: 一个能够在遍历器归并时将sack合并的 <code>BinaryOperator</code> ，如果没有提供合并运算符，
那么两个有sack的遍历器则不能合并</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>下面两个日常的例子来说明这些 <strong>initial value supplier</strong>。在下面最前的例子，在图（<code>g.V()</code>）中每个顶点创建一个遍历器，携带着一个
值为1.0的sack，并且想去获取这些sack（<code>sack()</code>）。下面的例子是，使用一个float类型的随机数生成器来填充sack</p>
</div>
<div class="listingblock">
<div class="content">
<pre>g.withSack(1.0f).V().sack()
rand = new Random()
g.withSack {rand.nextFloat()}.V().sack()</pre>
</div>
</div>
<div class="paragraph">
<p>下面是一个比较复杂的 <strong>initial value supplier</strong> 例子，sack本身被用于一个运行的计算中，并到遍历最后被发出。
当边在遍历时将与权值sack相乘。注意<a href="#by-step"><code>by()</code></a> 协调步可以是任意的遍历。</p>
</div>
<div class="paragraph">
<p>more complicated initial value supplier example is presented below where the sack values are used in a running
computation and then emitted at the end of the traversal. When an edge is traversed, the edge weight is multiplied
by the sack value (<code>sack(mult).by('weight')</code>). Note that the <a href="#by-step"><code>by()</code></a>-modulator can be any arbitrary traversal.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>g.withSack(1.0f).V().repeat(outE().sack(mult).by('weight').inV()).times(2)
g.withSack(1.0f).V().repeat(outE().sack(mult).by('weight').inV()).times(2).sack()
g.withSack(1.0f).V().repeat(outE().sack(mult).by('weight').inV()).times(2).path().
      by().by('weight')</pre>
</div>
</div>
<div class="imageblock">
<div class="content">
<img src="./images/gremlin-sacks-standing.png" alt="gremlin sacks standing" width="100">
</div>
</div>
<div class="paragraph">
<p>当使用复杂对象时（比如非原语变量）时，为了保证每个遍历器能够克隆一份父遍历器的sack，<strong>split operator</strong> 是需要定义的。
第一个示例不使用拆分运算符，因此相同的map将被传播到所有遍历器（全局数据结构）。第二个例子展示了 <code>Map.clone()</code> 是如何
保证每个遍历器拿到一个独一无二的局部的sack</p>
</div>
<div class="listingblock">
<div class="content">
<pre>g.withSack {[:]}.V().out().out().
      sack {m,v -&gt; m[v.value('name')] = v.value('lang'); m}.sack() // BAD: single map
g.withSack {[:]}{it.clone()}.V().out().out().
      sack {m,v -&gt; m[v.value('name')] = v.value('lang'); m}.sack() // GOOD: cloned map</pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
对于原语类型变量（即整数，长整数，浮点数等），不需要拆分运算符，因为它们在sack中被编码成地址，而不是作为对象引用
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>如果没有提供 <strong>merge operator</strong> ，那么有sack的那些遍历器就不能被批量（归并）。但是在很多场景下，在两个遍历器同一个位置上对sack进行归并
是合理的，并能够进行批量优化。下面的示例中就是用 <code>Operator.sum</code> 这个归并运算符，所以当两个遍历器归并时，它们响应的sack直接相加</p>
</div>
<div class="listingblock">
<div class="content">
<pre>g.withSack(1.0d).V(1).out('knows').in('knows') <i class="conum" data-value="1"></i><b>(1)</b>
g.withSack(1.0d).V(1).out('knows').in('knows').sack() <i class="conum" data-value="2"></i><b>(2)</b>
g.withSack(1.0d, sum).V(1).out('knows').in('knows').sack() <i class="conum" data-value="3"></i><b>(3)</b>
g.withSack(1.0d).V(1).local(outE('knows').barrier(normSack).inV()).in('knows').barrier() <i class="conum" data-value="4"></i><b>(4)</b>
g.withSack(1.0d).V(1).local(outE('knows').barrier(normSack).inV()).in('knows').barrier().sack() <i class="conum" data-value="5"></i><b>(5)</b>
g.withSack(1.0d,sum).V(1).local(outE('knows').barrier(normSack).inV()).in('knows').barrier().sack() <i class="conum" data-value="6"></i><b>(6)</b>
g.withBulk(false).withSack(1.0f,sum).V(1).local(outE('knows').barrier(normSack).inV()).in('knows').barrier().sack() <i class="conum" data-value="7"></i><b>(7)</b>
g.withBulk(false).withSack(1.0f).V(1).local(outE('knows').barrier(normSack).inV()).in('knows').barrier().sack()<i class="conum" data-value="8"></i><b>(8)</b></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>顶点1被输出两次，因为它认识两个其他人</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>没有归并的操作，两个sack的值都是1.0</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>当在归并操作中指定了 <code>sum</code>，sack的值因为批量归并所以变成2.0</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>和1相同，但是内部使用栅栏（barrier）</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td><code>local(...barrier(normSack)...)</code> 保证所有离开顶点1的遍历器均分原始的1.0 “能量” （50-50均分），比如每个结果都是0.5的sack</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>和3相同，但是用 <code>sum</code> 归并了，导致结果是1.0</td>
</tr>
<tr>
<td><i class="conum" data-value="7"></i><b>7</b></td>
<td>这里是一个打包后为为2的遍历器但sack为1.0的遍历器，通过withBulk(false)后结果是1.0</td>
</tr>
<tr>
<td><i class="conum" data-value="8"></i><b>8</b></td>
<td>与7相同，但是没有sum这个操作符</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><strong>更多参考</strong></p>
</div>
<div class="paragraph">
<p><a href="http://tinkerpop.apache.org/javadocs/3.4.1/core/org/apache/tinkerpop/gremlin/process/traversal/dsl/graph/GraphTraversal.html#sack--"><code>sack()</code></a>,
<a href="http://tinkerpop.apache.org/javadocs/3.4.1/core/org/apache/tinkerpop/gremlin/process/traversal/dsl/graph/GraphTraversal.html#sack-java.util.function.BiFunction-"><code>sack(BiFunction)</code></a></p>
</div>
</div>
<div class="sect2">
<h3 id="sample-step"><a class="anchor" href="#sample-step"></a>Sample Step</h3>
<div class="paragraph">
<p><code>sample()</code> 单步的主要作用是采样某个数目的前遍历中的遍历器</p>
</div>
<div class="listingblock">
<div class="content">
<pre>g.V().outE().sample(1).values('weight')
g.V().outE().sample(1).by('weight').values('weight')
g.V().outE().sample(2).by('weight').values('weight')</pre>
</div>
</div>
<div class="paragraph">
<p><code>sample()</code> 的一个比较有意思的例子是用于和<a href="#local-step"><code>local()</code></a> 连接。
这两个单步联合起来可以用于执行<a href="http://en.wikipedia.org/wiki/Random_walk">随机游走</a>
在下例中，遍历从顶点1来时，根据每条边的权值的概率分布来选择游走边。因为只选择一条边，所以输出永远是一条单一路径。
遍历器不会分裂，只会沿着一条路径走</p>
</div>
<div class="listingblock">
<div class="content">
<pre>g.V(1).repeat(local(
         bothE().sample(1).by('weight').otherV()
       )).times(5)
g.V(1).repeat(local(
         bothE().sample(1).by('weight').otherV()
       )).times(5).path()
g.V(1).repeat(local(
         bothE().sample(1).by('weight').otherV()
       )).times(10).path()</pre>
</div>
</div>
<div class="paragraph">
<p>声明注意，上例因为只是一个顶点的随机遍历，<code>local()</code> 并不是一定必须的，但注意如果对于多个顶点遍历的情况，没有它会发生：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>g.V().repeat(bothE().sample(1).by('weight').otherV()).times(5).path()</pre>
</div>
</div>
<div class="paragraph">
<p>使用 <code>local()</code> 能够保证遍历器没经过一个顶点，就通过 <code>bothE()</code> 遍历一次，并且只允许每顶点只游走一步</p>
</div>
<div class="listingblock">
<div class="content">
<pre>g.V().repeat(local(bothE().sample(1).by('weight').otherV())).times(5).path()</pre>
</div>
</div>
<div class="paragraph">
<p>所以，虽然不是严格要求，但最好显式地使用 <code>local()</code> ，这样可以更正确地描述遍历的意图</p>
</div>
<div class="paragraph">
<p><strong>更多参考</strong></p>
</div>
<div class="paragraph">
<p><a href="http://tinkerpop.apache.org/javadocs/3.4.1/core/org/apache/tinkerpop/gremlin/process/traversal/dsl/graph/GraphTraversal.html#sample-int-"><code>sample(int)</code></a>,
<a href="http://tinkerpop.apache.org/javadocs/3.4.1/core/org/apache/tinkerpop/gremlin/process/traversal/dsl/graph/GraphTraversal.html#sample-org.apache.tinkerpop.gremlin.process.traversal.Scope-int-"><code>sample(Scope,int)</code></a>,
<a href="http://tinkerpop.apache.org/javadocs/3.4.1/core/org/apache/tinkerpop/gremlin/process/traversal/Scope.html"><code>Scope</code></a></p>
</div>
</div>
<div class="sect2">
<h3 id="select-step"><a class="anchor" href="#select-step"></a>Select Step</h3>
<div class="paragraph">
<p><a href="http://en.wikipedia.org/wiki/Functional_programming">函数式编程</a> 使用函数的组合和缓式求值（lazy evaluation）将元操作组合成复杂的计算形式。
正如 <code>Traversal</code> 遍历本身。但从一个不同的角度来说，Gremlin数据流的实现与图的处理的区别有差异，主要是数据流并不一定总是“向前”的，实际上，
也能够向后看到先前已经计算的区域。例子包含<a href="#path-step"><code>path()</code></a> 也包含 <code>select()</code> (<strong>map</strong>) 单步。<code>select()</code> 单步有两种通用使用方式：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>选取路径中打标签的单步（比如在遍历中用 <code>as()</code> 定义的）</p>
</li>
<li>
<p>在一个 <code>Map&lt;String,Object&gt;</code> 流中将对象滤出（比如，子图）</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>第一种情况可以见下例</p>
</div>
<div class="listingblock">
<div class="content">
<pre>g.V().as('a').out().as('b').out().as('c') // no select
g.V().as('a').out().as('b').out().as('c').select('a','b','c')
g.V().as('a').out().as('b').out().as('c').select('a','b')
g.V().as('a').out().as('b').out().as('c').select('a','b').by('name')
g.V().as('a').out().as('b').out().as('c').select('a') <i class="conum" data-value="1"></i><b>(1)</b></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>如果选择只有一个，那么就不返回map类型了</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>如果只选择一个标签，那么就返回一个单独对象（而不是map）。针对于退出计算并根据返回的对象再次向前遍历很有用</p>
</div>
<div class="listingblock">
<div class="content">
<pre>g.V().out().out()
g.V().out().out().path()
g.V().as('x').out().out().select('x')
g.V().out().as('x').out().select('x')
g.V().out().out().as('x').select('x') // pointless</pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
当在一个标准的遍历引擎（比如OLTP）里使用 <code>select()</code> 进行遍历时，<code>select()</code> 将尽力避免计算历史路径，而是依赖一个
全局数据结构来存储当前选择的对象。所以，如果只需要一个走过路径的一个子集，那么 <code>select()</code> 应当优于 <a href="#path-step"><code>path()</code></a> 使用，
因为后者属于资源密集型
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>如果需要一组路径键或值（比如columns），或者map本身，可以相应的使用 <code>select(keys)</code> 和 <code>select(values)</code>。
如果只对 <code>groupCount()</code> 排名中的top N元素感兴趣，那么这样使用就很有用</p>
</div>
<div class="listingblock">
<div class="content">
<pre>g = graph.traversal()
g.io('data/grateful-dead.xml').read().iterate()
g.V().hasLabel('song').out('followedBy').groupCount().by('name').
      order(local).by(values,desc).limit(local, 5)
g.V().hasLabel('song').out('followedBy').groupCount().by('name').
      order(local).by(values,desc).limit(local, 5).select(keys)
g.V().hasLabel('song').out('followedBy').groupCount().by('name').
      order(local).by(values,desc).limit(local, 5).select(keys).unfold()</pre>
</div>
</div>
<div class="paragraph">
<p>相同的，从一个路径或者map中提取数据</p>
</div>
<div class="listingblock">
<div class="content">
<pre>g = graph.traversal()
g.io('data/grateful-dead.xml').read().iterate()
g.V().hasLabel('song').out('sungBy').groupCount().by('name') <i class="conum" data-value="1"></i><b>(1)</b>
g.V().hasLabel('song').out('sungBy').groupCount().by('name').select(values) <i class="conum" data-value="2"></i><b>(2)</b>
g.V().hasLabel('song').out('sungBy').groupCount().by('name').select(values).unfold().
      groupCount().order(local).by(values,desc).limit(local, 5) <i class="conum" data-value="3"></i><b>(3)</b></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>哪位艺术家唱了多少歌</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>获得一组歌单的曲目数目，不显示名字</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>5个最常见的歌单曲目大小</td>
</tr>
</table>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
<code>select(keys)</code> 和 <code>select(values)</code> 不能用 <code>by()</code> 来调整
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>在遍历器 <code>Traverser</code> 中的 <code>List</code> 对象在使用 <code>select()</code> 操作时，还有一个选项是提供 <code>Pop</code> 操作。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>g.V(1).as("a").repeat(out().as("a")).times(2).select(first, "a")
g.V(1).as("a").repeat(out().as("a")).times(2).select(last, "a")
g.V(1).as("a").repeat(out().as("a")).times(2).select(all, "a")</pre>
</div>
</div>
<div class="paragraph">
<p>之前的示例都是 <code>select()</code> 来根据一个静态的key来选取元素，除此之外，<code>select()</code> 也能够传入一个能够生成一个key的遍历结构</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
因为 <code>select(&lt;traversal&gt;)</code> 不能在编译时确定，所以 <code>TraversalSelectStep</code> 启用全路径跟踪
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre>g.withSideEffect("alias", ["marko":"okram"]).V().  <i class="conum" data-value="1"></i><b>(1)</b>
  values("name").sack(assign).                     <i class="conum" data-value="2"></i><b>(2)</b>
  optional(select("alias").select(sack()))         <i class="conum" data-value="3"></i><b>(3)</b></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>插入一个存名字的alias，并且对所有顶点开始遍历</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>选取所有 <code>name</code> 值并且当做当前遍历器的sack来存放</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>从插入的alias中可以选择当前的名字</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="using-where-with-select"><a class="anchor" href="#using-where-with-select"></a>Using Where with Select</h4>
<div class="paragraph">
<p>与 <a href="#match-step"><code>match()</code></a> 单步相同，可以使用 <code>where()</code>， 它是一个处理 <code>Map&lt;String,Object&gt;</code> 对象流的过滤器</p>
</div>
<div class="listingblock">
<div class="content">
<pre>g.V().as('a').out('created').in('created').as('b').select('a','b').by('name') <i class="conum" data-value="1"></i><b>(1)</b>
g.V().as('a').out('created').in('created').as('b').
      select('a','b').by('name').where('a',neq('b')) <i class="conum" data-value="2"></i><b>(2)</b>
g.V().as('a').out('created').in('created').as('b').
      select('a','b'). <i class="conum" data-value="3"></i><b>(3)</b>
      where('a',neq('b')).
      where(__.as('a').out('knows').as('b')).
      select('a','b').by('name')</pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>一个标准的 <code>select()</code> 使用，在例子中，它在路径中（比如 <code>a</code> and <code>b</code>）生成一个 <code>Map&lt;String,Object&gt;</code> 对象的绑定</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td><code>select().by('name')</code> 将绑定的顶点按name的属性值投放，同时 <code>where()</code> 操作保证 <code>a</code> 和 <code>b</code> 字符串不相同</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>第一个 <code>select()</code> 投放一个顶点绑定集合，那些 <code>a</code> 与 <code>b</code> 中顶点相同的被过滤掉了。如果 <code>a</code> 和 <code>b</code> 没有knows也被过滤掉了。
第二个也就是最后一个 <code>select()</code> 投放这些顶点的name</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><strong>更多参考</strong></p>
</div>
<div class="paragraph">
<p><a href="http://tinkerpop.apache.org/javadocs/3.4.1/core/org/apache/tinkerpop/gremlin/process/traversal/dsl/graph/GraphTraversal.html#select-org.apache.tinkerpop.gremlin.structure.Column-"><code>select(Column)</code></a>,
<a href="http://tinkerpop.apache.org/javadocs/3.4.1/core/org/apache/tinkerpop/gremlin/process/traversal/dsl/graph/GraphTraversal.html#select-org.apache.tinkerpop.gremlin.process.traversal.Pop-java.lang.String-"><code>select(Pop,String)</code></a>,
<a href="http://tinkerpop.apache.org/javadocs/3.4.1/core/org/apache/tinkerpop/gremlin/process/traversal/dsl/graph/GraphTraversal.html#select-java.lang.String-"><code>select(String)</code></a>,
<a href="http://tinkerpop.apache.org/javadocs/3.4.1/core/org/apache/tinkerpop/gremlin/process/traversal/dsl/graph/GraphTraversal.html#select-java.lang.String-java.lang.String-java.lang.String&#8230;&#8203;-"><code>select(String,String,String...)</code></a>,
<a href="http://tinkerpop.apache.org/javadocs/3.4.1/core/org/apache/tinkerpop/gremlin/process/traversal/dsl/graph/GraphTraversal.html#select-org.apache.tinkerpop.gremlin.process.traversal.Traversal-"><code>select(Traversal)</code></a>,
<a href="http://tinkerpop.apache.org/javadocs/3.4.1/core/org/apache/tinkerpop/gremlin/process/traversal/dsl/graph/GraphTraversal.html#select-org.apache.tinkerpop.gremlin.process.traversal.Pop-org.apache.tinkerpop.gremlin.process.traversal.Traversal-"><code>select(Pop,Traversal)</code></a>,
<a href="http://tinkerpop.apache.org/javadocs/3.4.1/core/org/apache/tinkerpop/gremlin/structure/Column.html"><code>Column</code></a>,
<a href="http://tinkerpop.apache.org/javadocs/3.4.1/core/org/apache/tinkerpop/gremlin/process/traversal/Pop.html"><code>Pop</code></a></p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="shortestpath-step"><a class="anchor" href="#shortestpath-step"></a>ShortestPath step</h3>
<div class="paragraph">
<p><code>shortestPath()</code> 单步提供一个简单的查找图最短非循环路径方法。它通过 <code>with()</code> 可以按照以下选项进行配置</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 11.5384%;">
<col style="width: 11.5384%;">
<col style="width: 57.6923%;">
<col style="width: 19.2309%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Key</th>
<th class="tableblock halign-left valign-top">Type</th>
<th class="tableblock halign-left valign-top">Description</th>
<th class="tableblock halign-left valign-top">Default</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>target</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Traversal</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">为结束顶点设置过滤器遍历（比如 <code>+__.has('name','marko')+</code> ）</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">所有顶点 （<code>+__.identity()+</code>）</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>edges</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Traversal</code> 或 <code>Direction</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">设置 <code>Traversal</code>，让它从当前顶点的边发出，或者用 <code>Direction</code> 做最短路径发现</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Direction.BOTH</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>distance</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Traversal</code> 或 <code>String</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">设置 <code>Traversal</code> 用于计算当前边的距离，或者设置边属性的标识，用于距离计算中使用</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>__.constant(1)</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>maxDistance</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Number</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">设置最短路径的距离限制</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">none</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>includeEdges</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Boolean</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">结果中是否包含边</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>false</code></p></td>
</tr>
</tbody>
</table>
<div class="listingblock">
<div class="content">
<pre>g = g.withComputer()
g.V().shortestPath() <i class="conum" data-value="1"></i><b>(1)</b>
g.V().has('person','name','marko').shortestPath() <i class="conum" data-value="2"></i><b>(2)</b>
g.V().shortestPath().with(ShortestPath.target, __.has('name','peter')) <i class="conum" data-value="3"></i><b>(3)</b>
g.V().shortestPath().
        with(ShortestPath.edges, Direction.IN).
        with(ShortestPath.target, __.has('name','josh')) <i class="conum" data-value="4"></i><b>(4)</b>
g.V().has('person','name','marko').
      shortestPath().
        with(ShortestPath.target, __.has('name','josh')) <i class="conum" data-value="5"></i><b>(5)</b>
g.V().has('person','name','marko').
      shortestPath().
        with(ShortestPath.target, __.has('name','josh')).
        with(ShortestPath.distance, 'weight') <i class="conum" data-value="6"></i><b>(6)</b>
g.V().has('person','name','marko').
      shortestPath().
        with(ShortestPath.target, __.has('name','josh')).
        with(ShortestPath.includeEdges, true) <i class="conum" data-value="7"></i><b>(7)</b></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>找到所有最短路径</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>找到从 <code>marko</code> 开始的最短路径</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>找到终点为 <code>peter</code> 的最短路径</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>找到所有入向到 <code>josh</code> 的最短路径</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>找到所有从 <code>marko</code> 到 <code>josh</code> 的最短路径</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>使用定义的距离属性，找到所有从 <code>marko</code> 到 <code>josh</code> 的最短路径</td>
</tr>
<tr>
<td><i class="conum" data-value="7"></i><b>7</b></td>
<td>找到所有从 <code>marko</code> 到 <code>josh</code> 的最短路径，结果中包含边的信息</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre>g.inject(g.withComputer().V().shortestPath().
           with(ShortestPath.distance, 'weight').
           with(ShortestPath.includeEdges, true).
           with(ShortestPath.maxDistance, 1).toList().toArray()).
  map(unfold().values('name','weight').fold()) <i class="conum" data-value="1"></i><b>(1)</b></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>使用定义的距离属性和距离为1的条件来找到所有最短路径，在OLTP的 <code>GraphTraversal</code> 中注入结果，用于在以后所有的路径里都能够在元素中选择属性</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><strong>更多参考</strong></p>
</div>
<div class="paragraph">
<p><a href="http://tinkerpop.apache.org/javadocs/3.4.1/core/org/apache/tinkerpop/gremlin/process/traversal/dsl/graph/GraphTraversal.html#shortestPath--"><code>shortestPath()</code></a></p>
</div>
</div>
<div class="sect2">
<h3 id="simplepath-step"><a class="anchor" href="#simplepath-step"></a>SimplePath Step</h3>
<div class="imageblock">
<div class="content">
<img src="./images/simplepath-step.png" alt="simplepath step" width="400">
</div>
</div>
<div class="paragraph">
<p>当遍历器游走路径不回环这个条件很重要时，可以使用 <code>simplePath()</code> (<strong>filter</strong>) 单步。
遍历器的<a href="#path-data-structure">路径</a> 信息如果被分析出有重复的对象，那么这个遍历器就被滤掉了。
如果需要带有回环的，可以参考 <a href="#cyclicpath-step"><code>cyclicPath()</code></a>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>g.V(1).both().both()
g.V(1).both().both().simplePath()
g.V(1).both().both().simplePath().path()
g.V().out().as('a').out().as('b').out().as('c').
  simplePath().by(label).
  path()
g.V().out().as('a').out().as('b').out().as('c').
  simplePath().
    by(label).
    from('b').
    to('c').
  path().
    by('name')</pre>
</div>
</div>
<div class="paragraph">
<p>遍历器可以使用 <code>from()</code> 和 <code>to()</code> 来保证只有路径的特定部分是非循环的</p>
</div>
<div class="listingblock">
<div class="content">
<pre>g.addV().property(id, 'A').as('a').
  addV().property(id, 'B').as('b').
  addV().property(id, 'C').as('c').
  addV().property(id, 'D').as('d').
  addE('link').from('a').to('b').
  addE('link').from('b').to('c').
  addE('link').from('c').to('d').iterate()
g.V('A').repeat(both().simplePath()).times(3).path()  <i class="conum" data-value="1"></i><b>(1)</b>
g.V('D').repeat(both().simplePath()).times(3).path()  <i class="conum" data-value="2"></i><b>(2)</b>
g.V('A').as('a').
  repeat(both().simplePath().from('a')).times(3).as('b').
  repeat(both().simplePath().from('b')).times(3).path()  <i class="conum" data-value="3"></i><b>(3)</b></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>从顶点 <code>A</code> 开始遍历游走所有非循环的3跳的路径</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>从顶点 <code>D</code> 开始遍历游走所有非循环的3跳的路径</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>从顶点 <code>A</code> 开始遍历游走所有非循环的3跳的路径，再从那里开始（遍历）非循环3跳的路径。第二条路径可能穿越第一条路径的顶点</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><strong>更多参考</strong></p>
</div>
<div class="paragraph">
<p><a href="http://tinkerpop.apache.org/javadocs/3.4.1/core/org/apache/tinkerpop/gremlin/process/traversal/dsl/graph/GraphTraversal.html#simplePath--"><code>simplePath()</code></a></p>
</div>
</div>
<div class="sect2">
<h3 id="skip-step"><a class="anchor" href="#skip-step"></a>Skip Step</h3>
<div class="paragraph">
<p><code>skip()</code> 单步相当于在 <a href="#range-step"><code>range()</code></a>里把其上届设置成 -1。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>g.V().values('age').order()
g.V().values('age').order().skip(2)
g.V().values('age').order().range(2, -1)</pre>
</div>
</div>
<div class="paragraph">
<p><code>skip()</code> 单步也可以结合 <code>Scope.local</code> 来使用，那么它就操作接下来的集合</p>
</div>
<div class="listingblock">
<div class="content">
<pre>g.V().hasLabel('person').filter(outE('created')).as('p'). <i class="conum" data-value="1"></i><b>(1)</b>
  map(out('created').values('name').fold()).
  project('person','primary','other').
    by(select('p').by('name')).
    by(limit(local, 1)). <i class="conum" data-value="2"></i><b>(2)</b>
    by(skip(local, 1)) <i class="conum" data-value="3"></i><b>(3)</b></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>找到created什么东西的person</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>&#8230;&#8203;选取第一个工程（随机顺序）作为 <code>primary</code> 并&#8230;&#8203;</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>&#8230;&#8203;选取其他工程作为 <code>other</code></td>
</tr>
</table>
</div>
<div class="paragraph">
<p><strong>更多参考</strong></p>
</div>
<div class="paragraph">
<p><a href="http://tinkerpop.apache.org/javadocs/3.4.1/core/org/apache/tinkerpop/gremlin/process/traversal/dsl/graph/GraphTraversal.html#skip-long-"><code>skip(long)</code></a>,
<a href="http://tinkerpop.apache.org/javadocs/3.4.1/core/org/apache/tinkerpop/gremlin/process/traversal/dsl/graph/GraphTraversal.html#skip-org.apache.tinkerpop.gremlin.process.traversal.Scope-long-"><code>skip(Scope,long)</code></a>,
<a href="http://tinkerpop.apache.org/javadocs/3.4.1/core/org/apache/tinkerpop/gremlin/process/traversal/Scope.html"><code>Scope</code></a></p>
</div>
</div>
<div class="sect2">
<h3 id="store-step"><a class="anchor" href="#store-step"></a>Store Step</h3>
<div class="paragraph">
<p>当需要 <a href="http://en.wikipedia.org/wiki/Lazy_evaluation">惰性</a> 聚合时，要使用 <code>store()</code> (<strong>sideEffect</strong>) 单步而不是 <a href="#aggregate-step"><code>aggregate()</code></a>。
这两步所不同的是 <code>store()</code> 并不阻塞，并只在走过时将对象存在它的side-effect对象集合里</p>
</div>
<div class="listingblock">
<div class="content">
<pre>g.V().aggregate('x').limit(1).cap('x')
g.V().store('x').limit(1).cap('x')</pre>
</div>
</div>
<div class="paragraph">
<p>有趣的是，即使选择区间只有1，<code>store()</code> 的副作用集合也会有两个结果。其实当第二个对象在到 <code>range()</code> （limit是 <code>[0..1]</code>）过滤之前，
它经过了 <code>store()</code> 单步，所以存了下来</p>
</div>
<div class="listingblock">
<div class="content">
<pre>g.E().store('x').by('weight').cap('x')</pre>
</div>
</div>
<div class="paragraph">
<p><strong>更多参考</strong></p>
</div>
<div class="paragraph">
<p><a href="http://tinkerpop.apache.org/javadocs/3.4.1/core/org/apache/tinkerpop/gremlin/process/traversal/dsl/graph/GraphTraversal.html#store-java.lang.String-"><code>store(String)</code></a></p>
</div>
</div>
<div class="sect2">
<h3 id="subgraph-step"><a class="anchor" href="#subgraph-step"></a>Subgraph Step</h3>
<div class="imageblock">
<div class="content">
<img src="./images/subgraph-logo.png" alt="subgraph logo" width="380">
</div>
</div>
<div class="paragraph">
<p>从大图中提取小图做分析和可视化等其他目的，是图分析中常见的操作。<code>subgraph()</code> (<strong>sideEffect</strong>) 单步提供了一种通过
<a href="http://mathworld.wolfram.com/Edge-InducedSubgraph.html">边导出子图</a>，这样几乎可以在任何遍历中生成子图。
下例展示了如何生成 "knows" 子图：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>subGraph = g.E().hasLabel('knows').subgraph('subGraph').cap('subGraph').next() <i class="conum" data-value="1"></i><b>(1)</b>
sg = subGraph.traversal()
sg.E() <i class="conum" data-value="2"></i><b>(2)</b></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>因为函数生成“边导出子图”，必须在边操作单步上使用 <code>subgraph()</code></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>子图只包含 "knows" 子图</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>常用的获取子图的例子还包括比如获取所有与一个顶点相邻的图结构：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>subGraph = g.V(3).repeat(__.inE().subgraph('subGraph').outV()).times(3).cap('subGraph').next()  <i class="conum" data-value="1"></i><b>(1)</b>
sg = subGraph.traversal()
sg.E()</pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>从顶点 <code>3</code> 开始，向入边游走三步，将其全部输出到</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>一次完整的遍历中可能哟多次 <code>subgraph()</code> 调用。每一次可以或者针对同一个图（携带相同的副作用key），也可以不相同（不同的副作用key）</p>
</div>
<div class="listingblock">
<div class="content">
<pre>t = g.V().outE('knows').subgraph('knowsG').inV().outE('created').subgraph('createdG').
          inV().inE('created').subgraph('createdG').iterate()
t.sideEffects.get('knowsG').traversal().E()
t.sideEffects.get('createdG').traversal().E()</pre>
</div>
</div>
<div class="paragraph">
<p>TinkerGraph一个理想（默认）<code>Graph</code> 图，子图可以在内存中快速提取，也可以支持用户标识符（可以是任何Java对象）。
这也是最后需要关注的一个功能，因为很多基于TinkerPop的图实现都有很复杂的标识符类型，TinkerGraph能够消费这些对象的能力
可以让其变成一个完美的处理传入子图的寄宿（host）。但当使用TinkerGraph里面的元素时候要很小心。原图中的标识符可能已经被预留了，
但在TinkerGraph中的元素如顶点和边的对象却是 <code>TinkerVertex</code> 和 <code>TinkerEdge</code> 类型。所以，它们没法直接在原图里用Gremlin运行，
以下的遍历操作就大概率返回一个错误：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="text">Vertex v = sg.V().has('name','marko').next();  <i class="conum" data-value="1"></i><b>(1)</b>
List&lt;Vertex&gt; vertices = g.V(v).out().toList(); <i class="conum" data-value="2"></i><b>(2)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>这里"sg" 是一个TinkerGraph的子图，"v" 是一个 <code>TinkerVertex</code> 类型对象</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>这里 <code>g.V(v)</code> 就有可能失败，因为 "g" 是原始的 <code>Graph</code> 实例，而不是一个inkerGraph，因为不认识 <code>TinkerVertex</code> 实例所以可能会拒绝掉</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>将 <code>TinkerVertex</code> 包在 <code>ReferenceVertex</code> 对象里就很安全，或者直接用 <code>id()</code> 来引用，如下：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="text">Vertex v = sg.V().has('name','marko').next();
List&lt;Vertex&gt; vertices = g.V(v.id()).out().toList();

// OR

Vertex v = new ReferenceVertex(sg.V().has('name','marko').next());
List&lt;Vertex&gt; vertices = g.V(v).out().toList();</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>更多参考</strong></p>
</div>
<div class="paragraph">
<p><a href="http://tinkerpop.apache.org/javadocs/3.4.1/core/org/apache/tinkerpop/gremlin/process/traversal/dsl/graph/GraphTraversal.html#subgraph-java.lang.String-"><code>subgraph(String)</code></a></p>
</div>
</div>
<div class="sect2">
<h3 id="sum-step"><a class="anchor" href="#sum-step"></a>Sum Step</h3>
<div class="paragraph">
<p><code>sum()</code> (<strong>map</strong>) 单步将流中的数字进行求和操作，并且生成结果。
注意遍历器数字乘以遍历器批量才表示最后的数字</p>
</div>
<div class="listingblock">
<div class="content">
<pre>g.V().values('age').sum()
g.V().repeat(both()).times(3).values('age').sum()</pre>
</div>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<code>sum(local)</code> 决定的是当前的局部变量的和（并不是遍历流中的），这对于 <code>Collection</code> 类型对象生效
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><strong>更多参考</strong></p>
</div>
<div class="paragraph">
<p><a href="http://tinkerpop.apache.org/javadocs/3.4.1/core/org/apache/tinkerpop/gremlin/process/traversal/dsl/graph/GraphTraversal.html#sum--"><code>sum()</code></a>,
<a href="http://tinkerpop.apache.org/javadocs/3.4.1/core/org/apache/tinkerpop/gremlin/process/traversal/dsl/graph/GraphTraversal.html#sum-org.apache.tinkerpop.gremlin.process.traversal.Scope-"><code>sum(Scope)</code></a>,
<a href="http://tinkerpop.apache.org/javadocs/3.4.1/core/org/apache/tinkerpop/gremlin/process/traversal/Scope.html"><code>Scope</code></a></p>
</div>
</div>
<div class="sect2">
<h3 id="tail-step"><a class="anchor" href="#tail-step"></a>Tail Step</h3>
<div class="imageblock">
<div class="content">
<img src="./images/tail-step.png" alt="tail step" width="530">
</div>
</div>
<div class="paragraph">
<p><code>tail()</code> 单步等同于 <a href="#limit-step"><code>limit()</code></a> 单步，但它发出最后 <code>n</code> 个对象，而不是前面 <code>n</code> 个</p>
</div>
<div class="listingblock">
<div class="content">
<pre>g.V().values('name').order()
g.V().values('name').order().tail() <i class="conum" data-value="1"></i><b>(1)</b>
g.V().values('name').order().tail(1) <i class="conum" data-value="2"></i><b>(2)</b>
g.V().values('name').order().tail(3) <i class="conum" data-value="3"></i><b>(3)</b></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>姓（字母序）</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>与1相同</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>最后三个名字</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code>tail()</code> 也可以与 <code>Scope.local</code> 公用，那么就是操作传入的集合</p>
</div>
<div class="listingblock">
<div class="content">
<pre>g.V().as('a').out().as('a').out().as('a').select('a').by(tail(local)).values('name') <i class="conum" data-value="1"></i><b>(1)</b>
g.V().as('a').out().as('a').out().as('a').select('a').by(unfold().values('name').fold()).tail(local) <i class="conum" data-value="2"></i><b>(2)</b>
g.V().as('a').out().as('a').out().as('a').select('a').by(unfold().values('name').fold()).tail(local, 2) <i class="conum" data-value="3"></i><b>(3)</b>
g.V().valueMap().tail(local) <i class="conum" data-value="4"></i><b>(4)</b></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>只去处理最近的一个 <code>a</code> （<code>List&lt;Vertex&gt;</code> 变成 <code>Vertex</code>）</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>和1相同（<code>List&lt;String&gt;</code> 变成 <code>String</code>）</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>在 <code>a</code> 中包含最后两个name的 <code>List&lt;String&gt;</code> 结构</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>每顶点的 <code>Map&lt;String, Object&gt;</code>，但是只包含最后的属性值</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><strong>更多参考</strong></p>
</div>
<div class="paragraph">
<p><a href="http://tinkerpop.apache.org/javadocs/3.4.1/core/org/apache/tinkerpop/gremlin/process/traversal/dsl/graph/GraphTraversal.html#tail--"><code>tail()</code></a>,
<a href="http://tinkerpop.apache.org/javadocs/3.4.1/core/org/apache/tinkerpop/gremlin/process/traversal/dsl/graph/GraphTraversal.html#tail-long-"><code>tail(long)</code></a>,
<a href="http://tinkerpop.apache.org/javadocs/3.4.1/core/org/apache/tinkerpop/gremlin/process/traversal/dsl/graph/GraphTraversal.html#tail-org.apache.tinkerpop.gremlin.process.traversal.Scope-"><code>tail(Scope)</code></a>
<a href="http://tinkerpop.apache.org/javadocs/3.4.1/core/org/apache/tinkerpop/gremlin/process/traversal/dsl/graph/GraphTraversal.html#tail-org.apache.tinkerpop.gremlin.process.traversal.Scope-long-"><code>tail(Scope,long)</code></a>
<a href="http://tinkerpop.apache.org/javadocs/3.4.1/core/org/apache/tinkerpop/gremlin/process/traversal/Scope.html"><code>Scope</code></a></p>
</div>
</div>
<div class="sect2">
<h3 id="timelimit-step"><a class="anchor" href="#timelimit-step"></a>TimeLimit Step</h3>
<div class="paragraph">
<p>很多情况下，图遍历只想获得相对排名，而不是一个精确答案，经典的例子是<a href="http://en.wikipedia.org/wiki/Recommender_system">推荐系统</a>。
需要的是一个顶点的相对排名而非绝对排名。期望的执行结果可能需要不超过2毫秒。在这种场景下，可以使用 <code>timeLimit()</code> (<strong>filter</strong>) 单步</p>
</div>
<div class="imageblock">
<div class="content">
<img src="./images/timelimit-step.png" alt="timelimit step" width="400">
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<code>clock(int runs, Closure code)</code> 是一个预装在 <a href="#gremlin-console">Gremlin Console</a> 的程序，它能够统计代码的执行时间
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre>g.V().repeat(both().groupCount('m')).times(16).cap('m').order(local).by(values,desc).next()
clock(1) {g.V().repeat(both().groupCount('m')).times(16).cap('m').order(local).by(values,desc).next()}
g.V().repeat(timeLimit(2).both().groupCount('m')).times(16).cap('m').order(local).by(values,desc).next()
clock(1) {g.V().repeat(timeLimit(2).both().groupCount('m')).times(16).cap('m').order(local).by(values,desc).next()}</pre>
</div>
</div>
<div class="paragraph">
<p>本质上说，即使要游走所有顶点的数目，也不会考虑相对顺序。这样做的主要好处就是能够保证计算能在指定时间内（毫秒）完成。
最后，注意 <code>timeLimit()</code> 内部的计时器从第一个进入这个单步的遍历器开始计时。当达到时间上限后，任何有 <code>next()</code> 评估单步将生成一个
<code>NoSuchElementException</code> 异常，每个 <code>hasNext()</code> 预判将返回 <code>false</code></p>
</div>
<div class="paragraph">
<p><strong>更多参考</strong></p>
</div>
<div class="paragraph">
<p><a href="http://tinkerpop.apache.org/javadocs/3.4.1/core/org/apache/tinkerpop/gremlin/process/traversal/dsl/graph/GraphTraversal.html#timeLimit-long-"><code>timeLimit(long)</code></a></p>
</div>
</div>
<div class="sect2">
<h3 id="to-step"><a class="anchor" href="#to-step"></a>To Step</h3>
<div class="paragraph">
<p><code>to()</code> 并不是一个真正的单步执行操作，它更像是一个“调整步”（step modulator），类似 <a href="#as-step"><code>as()</code></a> 和<a href="#by-step"><code>by()</code></a>。
 如果一个单步能够接受遍历或者字符串，那么 <code>to()</code> 就是告诉它们从哪添加的。 通用的模式就是 <code>step().to()</code>。 同样可以看<a href="#from-step"><code>from()</code></a></p>
</div>
<div class="paragraph">
<p><a href="#simplepath-step"><code>simplePath()</code></a>， <a href="#cyclicpath-step"><code>cyclicPath()</code></a>，<a href="#path-step"><code>path()</code></a>，和 <a href="#addedge-step"><code>addE()</code></a>可以接受 <code>to()</code></p>
</div>
<div class="paragraph">
<p><strong>更多参考</strong></p>
</div>
<div class="paragraph">
<p><a href="http://tinkerpop.apache.org/javadocs/3.4.1/core/org/apache/tinkerpop/gremlin/process/traversal/dsl/graph/GraphTraversal.html#to-org.apache.tinkerpop.gremlin.process.traversal.Traversal-"><code>to(Direction,String...)</code></a>,
<a href="http://tinkerpop.apache.org/javadocs/3.4.1/core/org/apache/tinkerpop/gremlin/process/traversal/dsl/graph/GraphTraversal.html#to-org.apache.tinkerpop.gremlin.process.traversal.Traversal-"><code>to(String)</code></a>,
<a href="http://tinkerpop.apache.org/javadocs/3.4.1/core/org/apache/tinkerpop/gremlin/process/traversal/dsl/graph/GraphTraversal.html#to-org.apache.tinkerpop.gremlin.process.traversal.Traversal-"><code>to(Traversal)</code></a>,
<a href="http://tinkerpop.apache.org/javadocs/3.4.1/core/org/apache/tinkerpop/gremlin/process/traversal/dsl/graph/GraphTraversal.html#to-org.apache.tinkerpop.gremlin.structure.Vertex-"><code>to(Vertex)</code></a>,
<a href="http://tinkerpop.apache.org/javadocs/3.4.1/core/org/apache/tinkerpop/gremlin/process/traversal/dsl/graph/GraphTraversal.html#toE-org.apache.tinkerpop.gremlin.structure.Direction-java.lang.String&#8230;&#8203;-"><code>toE(Direction,String)</code></a>,
<a href="http://tinkerpop.apache.org/javadocs/3.4.1/core/org/apache/tinkerpop/gremlin/process/traversal/dsl/graph/GraphTraversal.html#toV-org.apache.tinkerpop.gremlin.structure.Direction-"><code>toV(Direction)</code></a>,
<a href="http://tinkerpop.apache.org/javadocs/3.4.1/core/org/apache/tinkerpop/gremlin/structure/Direction.html"><code>Direction</code></a></p>
</div>
</div>
<div class="sect2">
<h3 id="tree-step"><a class="anchor" href="#tree-step"></a>Tree Step</h3>
<div class="paragraph">
<p>对于任意一个图元素（比如顶点和边），从它发出的路径可以聚合为一个<a href="http://en.wikipedia.org/wiki/Tree_(data_structure)">树</a>。
Gremlin 提供 <code>tree()</code> (<strong>sideEffect</strong>) 单步来对这种情况进行处理</p>
</div>
<div class="imageblock">
<div class="content">
<img src="./images/tree-step.png" alt="tree step" width="450">
</div>
</div>
<div class="listingblock">
<div class="content">
<pre>tree = g.V().out().out().tree().next()</pre>
</div>
</div>
<div class="paragraph">
<p>能够看到所有遍历器是怎么通过路径联动来生成树的，这很重要</p>
</div>
<div class="imageblock">
<div class="content">
<img src="./images/tree-step2.png" alt="tree step2" width="500">
</div>
</div>
<div class="paragraph">
<p>生成的tree的对象结果可以被后续操作（见JavaDoc的 <code>Tree</code>）</p>
</div>
<div class="listingblock">
<div class="content">
<pre>tree = g.V().out().out().tree().by('name').next()
tree['marko']
tree['marko']['josh']
tree.getObjectsAtDepth(3)</pre>
</div>
</div>
<div class="paragraph">
<p>注意当使用 <code>by()</code> 调整时，tree的节点是根据投射的唯一性，而不是根据原始投射的对象的唯一性来组合的，比如：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>g.V().has('name','josh').out('created').values('name').tree() <i class="conum" data-value="1"></i><b>(1)</b>
g.V().has('name','josh').out('created').values('name').
  tree().by('name').by(label).by() <i class="conum" data-value="2"></i><b>(2)</b></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>当 <code>tree()</code> 被创建时，顶点3和5是唯一的，所以生成了单独的分支</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>当 <code>tree()</code> 被 <code>by()</code> 用 <code>label</code> 来调整时，顶点3和5都是"software"，所以在树中被合并成了一个单独的节点</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><strong>更多参考</strong></p>
</div>
<div class="paragraph">
<p><a href="http://tinkerpop.apache.org/javadocs/3.4.1/core/org/apache/tinkerpop/gremlin/process/traversal/dsl/graph/GraphTraversal.html#tree--"><code>tree()</code></a>,
<a href="http://tinkerpop.apache.org/javadocs/3.4.1/core/org/apache/tinkerpop/gremlin/process/traversal/dsl/graph/GraphTraversal.html#tree-java.lang.String-"><code>tree(String)</code></a></p>
</div>
</div>
<div class="sect2">
<h3 id="unfold-step"><a class="anchor" href="#unfold-step"></a>Unfold Step</h3>
<div class="paragraph">
<p>当进入 <code>unfold()</code> (<strong>flatMap</strong>) 里的对象是迭代器，可迭代的类，或者map等，它将被展开成一个线性结构。
如果不是，那对象就被直接发出，可以查看 <a href="#fold-step"><code>fold()</code></a> 的反向操作</p>
</div>
<div class="listingblock">
<div class="content">
<pre>g.V(1).out().fold().inject('gremlin',[1.23,2.34])
g.V(1).out().fold().inject('gremlin',[1.23,2.34]).unfold()</pre>
</div>
</div>
<div class="paragraph">
<p>注意 <code>unfold()</code> 单步并不递归展开迭代器。而 <code>repeat()</code> 可以用于递归展开</p>
</div>
<div class="listingblock">
<div class="content">
<pre>inject(1,[2,3,[4,5,[6]]])
inject(1,[2,3,[4,5,[6]]]).unfold()
inject(1,[2,3,[4,5,[6]]]).repeat(unfold()).until(count(local).is(1)).unfold()</pre>
</div>
</div>
<div class="paragraph">
<p><strong>更多参考</strong></p>
</div>
<div class="paragraph">
<p><a href="http://tinkerpop.apache.org/javadocs/3.4.1/core/org/apache/tinkerpop/gremlin/process/traversal/dsl/graph/GraphTraversal.html#unfold--"><code>unfold()</code></a></p>
</div>
</div>
<div class="sect2">
<h3 id="union-step"><a class="anchor" href="#union-step"></a>Union Step</h3>
<div class="imageblock">
<div class="content">
<img src="./images/union-step.png" alt="union step" width="650">
</div>
</div>
<div class="paragraph">
<p><code>union()</code> (<strong>branch</strong>) 支持合并任意多个迭代的结果。
当一个遍历器到达 <code>union()</code> 单步他就被拷贝到内部的单步里。而 <code>union()</code> 发出的遍历器则是相应的内部遍历生成的输出</p>
</div>
<div class="listingblock">
<div class="content">
<pre>g.V(4).union(
         __.in().values('age'),
         out().values('lang'))
g.V(4).union(
         __.in().values('age'),
         out().values('lang')).path()</pre>
</div>
</div>
<div class="paragraph">
<p><strong>更多参考</strong></p>
</div>
<div class="paragraph">
<p><a href="http://tinkerpop.apache.org/javadocs/3.4.1/core/org/apache/tinkerpop/gremlin/process/traversal/dsl/graph/GraphTraversal.html#union-org.apache.tinkerpop.gremlin.process.traversal.Traversal&#8230;&#8203;-"><code>union(Traversal...)</code></a></p>
</div>
</div>
<div class="sect2">
<h3 id="until-step"><a class="anchor" href="#until-step"></a>Until Step</h3>
<div class="paragraph">
<p><code>until</code> 不是一个独立的单步，它是 <code>&lt;&lt;repeat-step,repeat()&gt;&gt;</code> 的一个协调器（可以在 <code>until()</code> 里找到更多使用信息）</p>
</div>
<div class="paragraph">
<p><strong>更多参考</strong></p>
</div>
<div class="paragraph">
<p><a href="http://tinkerpop.apache.org/javadocs/3.4.1/core/org/apache/tinkerpop/gremlin/process/traversal/dsl/graph/GraphTraversal.html#until-java.util.function.Predicate-"><code>until(Predicate)</code></a>,
<a href="http://tinkerpop.apache.org/javadocs/3.4.1/core/org/apache/tinkerpop/gremlin/process/traversal/dsl/graph/GraphTraversal.html#until-org.apache.tinkerpop.gremlin.process.traversal.Traversal-"><code>until(Traversal)</code></a></p>
</div>
</div>
<div class="sect2">
<h3 id="value-step"><a class="anchor" href="#value-step"></a>Value Step</h3>
<div class="paragraph">
<p><code>value()</code> (<strong>map</strong>) 传入一个 <code>Property</code> 并且提取它的值</p>
</div>
<div class="listingblock">
<div class="content">
<pre>g.V(1).properties().value()
g.V(1).properties().properties().value()</pre>
</div>
</div>
<div class="paragraph">
<p><strong>更多参考</strong></p>
</div>
<div class="paragraph">
<p><a href="http://tinkerpop.apache.org/javadocs/3.4.1/core/org/apache/tinkerpop/gremlin/process/traversal/dsl/graph/GraphTraversal.html#value--"><code>value()</code></a></p>
</div>
</div>
<div class="sect2">
<h3 id="valuemap-step"><a class="anchor" href="#valuemap-step"></a>ValueMap Step</h3>
<div class="paragraph">
<p><code>valueMap()</code> 单步生成描述元素诸多属性的Map结构</p>
</div>
<div class="listingblock">
<div class="content">
<pre>g.V().valueMap()
g.V().valueMap('age')
g.V().valueMap('age','blah')
g.E().valueMap()</pre>
</div>
</div>
<div class="paragraph">
<p>一个重要提示是一个顶点的Map为每key维护着一个值的list，而一条边或一个定点的属性只有一个单一属性（而不是一个list）。
原因是TinkerPop的顶点利用<a href="#vertex-properties">vertex properties</a>来支持每key多值结构，使用<a href="#the-crew-toy-graph">"The Crew"</a> 数据模型，可以显式的展示这一点。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>g.V().valueMap()
g.V().has('name','marko').properties('location')
g.V().has('name','marko').properties('location').valueMap()</pre>
</div>
</div>
<div class="paragraph">
<p>将值的list转换为一个单一值，可以按下例使用 <code>by()</code> 来协调</p>
</div>
<div class="listingblock">
<div class="content">
<pre>g.V().valueMap().by(unfold())
g.V().valueMap('name','location').by().by(unfold())</pre>
</div>
</div>
<div class="paragraph">
<p>如果需要元素 <code>Element</code> 中的 <code>id</code>， <code>label</code>，<code>key</code> 和 <code>value</code>，则可以使用 <code>with()</code> 来协调将其插入到返回的map结构中</p>
</div>
<div class="listingblock">
<div class="content">
<pre>g.V().hasLabel('person').valueMap().with(WithOptions.tokens)
g.V().hasLabel('person').valueMap('name').with(WithOptions.tokens, WithOptions.labels)
g.V().hasLabel('person').properties('location').valueMap().with(WithOptions.tokens, WithOptions.values)</pre>
</div>
</div>
<div class="paragraph">
<p><strong>更多参考</strong></p>
</div>
<div class="paragraph">
<p><a href="http://tinkerpop.apache.org/javadocs/3.4.1/core/org/apache/tinkerpop/gremlin/process/traversal/dsl/graph/GraphTraversal.html#valueMap-java.lang.String&#8230;&#8203;-"><code>valueMap(String...)</code></a></p>
</div>
</div>
<div class="sect2">
<h3 id="values-step"><a class="anchor" href="#values-step"></a>Values Step</h3>
<div class="paragraph">
<p><code>values()</code>  (<strong>map</strong>) 在遍历数据流中，从一个元素 <code>Element</code> 中提取所有属性的值</p>
</div>
<div class="listingblock">
<div class="content">
<pre>g.V(1).values()
g.V(1).values('location')
g.V(1).properties('location').values()</pre>
</div>
</div>
<div class="paragraph">
<p><strong>更多参考</strong></p>
</div>
<div class="paragraph">
<p><a href="http://tinkerpop.apache.org/javadocs/3.4.1/core/org/apache/tinkerpop/gremlin/process/traversal/dsl/graph/GraphTraversal.html#values-java.lang.String&#8230;&#8203;-"><code>values(String...)</code></a></p>
</div>
</div>
<div class="sect2">
<h3 id="vertex-steps"><a class="anchor" href="#vertex-steps"></a>Vertex Steps</h3>
<div class="imageblock">
<div class="content">
<img src="./images/vertex-steps.png" alt="vertex steps" width="350">
</div>
</div>
<div class="paragraph">
<p>vertex (<strong>flatMap</strong>) 单步是Gremlin语言的基本操作，可以用来“游走”图（比如遍历）</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>out(string...)</code>：根据给定的边标签来沿外向游走到相邻的那些顶点</p>
</li>
<li>
<p><code>in(string...)</code>：根据给定的边标签来沿内向游走到相邻的那些顶点</p>
</li>
<li>
<p><code>both(string...)</code>：根据给定的边标签来双向游走到相邻的那些顶点</p>
</li>
<li>
<p><code>outE(string...)</code>：根据给定的边标签来沿外向游走到相邻的那些边</p>
</li>
<li>
<p><code>inE(string...)</code>：根据给定的边标签来沿内向游走到相邻的那些边</p>
</li>
<li>
<p><code>bothE(string...)</code>：根据给定的边标签来双向游走到相邻的那些边</p>
</li>
<li>
<p><code>outV()</code>：游走到外向顶点</p>
</li>
<li>
<p><code>inV()</code>：游走到内向顶点</p>
</li>
<li>
<p><code>bothV()</code>：游走到双向定点</p>
</li>
<li>
<p><code>otherV()</code>：游走到其他顶点，这些顶点不包含此顶点从哪移动来的那些顶点</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Groovy"></i>
</td>
<td class="content">
<div class="paragraph">
<p><code>in</code> 在Groovy中是一个关键字，在Gremlin中使用必须使用双下划线的匿名引用如 <code>__.in()</code>.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Javascript"></i>
</td>
<td class="content">
<div class="paragraph">
<p><code>in</code> 在JavaScript中是一个保留字，所以如果要使用Gremlin就需要用：<code>in_()</code></p>
</div>
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Python"></i>
</td>
<td class="content">
<div class="paragraph">
<p><code>in</code> 在Python中是一个保留字，所以如果要使用Gremlin就需要用：<code>in_()</code></p>
</div>
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre>g.V(4)
g.V(4).outE() <i class="conum" data-value="1"></i><b>(1)</b>
g.V(4).inE('knows') <i class="conum" data-value="2"></i><b>(2)</b>
g.V(4).inE('created') <i class="conum" data-value="3"></i><b>(3)</b>
g.V(4).bothE('knows','created','blah')
g.V(4).bothE('knows','created','blah').otherV()
g.V(4).both('knows','created','blah')
g.V(4).outE().inV() <i class="conum" data-value="4"></i><b>(4)</b>
g.V(4).out() <i class="conum" data-value="5"></i><b>(5)</b>
g.V(4).inE().outV()
g.V(4).inE().bothV()</pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>所有出边</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>所有knows的入边</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>所有created的入边</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>向外游走，并引入边和顶点</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>向外游走，但只引入顶点</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><strong>更多参考</strong></p>
</div>
<div class="paragraph">
<p><a href="http://tinkerpop.apache.org/javadocs/3.4.1/core/org/apache/tinkerpop/gremlin/process/traversal/dsl/graph/GraphTraversal.html#both-java.lang.String&#8230;&#8203;-"><code>both(String...)</code></a>,
<a href="http://tinkerpop.apache.org/javadocs/3.4.1/core/org/apache/tinkerpop/gremlin/process/traversal/dsl/graph/GraphTraversal.html#bothE-java.lang.String&#8230;&#8203;-"><code>bothE(String...)</code></a>,
<a href="http://tinkerpop.apache.org/javadocs/3.4.1/core/org/apache/tinkerpop/gremlin/process/traversal/dsl/graph/GraphTraversal.html#bothV--"><code>bothV()</code></a>,
<a href="http://tinkerpop.apache.org/javadocs/3.4.1/core/org/apache/tinkerpop/gremlin/process/traversal/dsl/graph/GraphTraversal.html#in-java.lang.String&#8230;&#8203;-"><code>in(String...)</code></a>,
<a href="http://tinkerpop.apache.org/javadocs/3.4.1/core/org/apache/tinkerpop/gremlin/process/traversal/dsl/graph/GraphTraversal.html#inE-java.lang.String&#8230;&#8203;-"><code>inE(String...)</code></a>,
<a href="http://tinkerpop.apache.org/javadocs/3.4.1/core/org/apache/tinkerpop/gremlin/process/traversal/dsl/graph/GraphTraversal.html#inV--"><code>inV()</code></a>,
<a href="http://tinkerpop.apache.org/javadocs/3.4.1/core/org/apache/tinkerpop/gremlin/process/traversal/dsl/graph/GraphTraversal.html#otherV--"><code>otherV()</code></a>,
<a href="http://tinkerpop.apache.org/javadocs/3.4.1/core/org/apache/tinkerpop/gremlin/process/traversal/dsl/graph/GraphTraversal.html#out-java.lang.String&#8230;&#8203;-"><code>out(String...)</code></a>,
<a href="http://tinkerpop.apache.org/javadocs/3.4.1/core/org/apache/tinkerpop/gremlin/process/traversal/dsl/graph/GraphTraversal.html#outE-java.lang.String&#8230;&#8203;-"><code>outE(String...)</code></a>,
<a href="http://tinkerpop.apache.org/javadocs/3.4.1/core/org/apache/tinkerpop/gremlin/process/traversal/dsl/graph/GraphTraversal.html#outV--"><code>outV()</code></a></p>
</div>
</div>
<div class="sect2">
<h3 id="where-step"><a class="anchor" href="#where-step"></a>Where Step</h3>
<div class="paragraph">
<p><code>where()</code> (<strong>filter</strong>) 单步根据对象本身（<code>Scope.local</code>）或者对象的历史路径（<code>Scope.global</code>）来对当前对象进行过滤。
它主要用于链接<a href="#match-step"><code>match()</code></a> 或 <a href="#select-step"><code>select()</code></a> 单步，但也可以独立使用</p>
</div>
<div class="listingblock">
<div class="content">
<pre>g.V(1).as('a').out('created').in('created').where(neq('a')) <i class="conum" data-value="1"></i><b>(1)</b>
g.withSideEffect('a',['josh','peter']).V(1).out('created').in('created').values('name').where(within('a')) <i class="conum" data-value="2"></i><b>(2)</b>
g.V(1).out('created').in('created').where(out('created').count().is(gt(1))).values('name') <i class="conum" data-value="3"></i><b>(3)</b></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>谁是marko的协作者，并且marko不能作为自己的协作者（传入predicate谓词函数）</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>在marko的协作者中，只包含那些名字为josh和peter的（使用一个副作用sideEffect）</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>在marko的协作者中有谁创建了多于一个工程？（使用遍历做参数）</td>
</tr>
</table>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
请查阅 <a href="#using-where-with-match"><code>match().where()</code></a> 和 <a href="#using-where-with-select"><code>select().where()</code></a> 来
查阅 <code>where()</code> 怎样用于链接 <code>Map&lt;String,Object&gt;</code> 映射的对象，比如 <code>Scope.local</code>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>下面的一些实例描述了怎样基于匿名遍历过滤任意对象</p>
</div>
<div class="listingblock">
<div class="content">
<pre>g.V().where(out('created')).values('name') <i class="conum" data-value="1"></i><b>(1)</b>
g.V().out('knows').where(out('created')).values('name') <i class="conum" data-value="2"></i><b>(2)</b>
g.V().where(out('created').count().is(gte(2))).values('name') <i class="conum" data-value="3"></i><b>(3)</b>
g.V().where(out('knows').where(out('created'))).values('name') <i class="conum" data-value="4"></i><b>(4)</b>
g.V().where(__.not(out('created'))).where(__.in('knows')).values('name') <i class="conum" data-value="5"></i><b>(5)</b>
g.V().where(__.not(out('created')).and().in('knows')).values('name') <i class="conum" data-value="6"></i><b>(6)</b>
g.V().as('a').out('knows').as('b').
  where('a',gt('b')).
    by('age').
  select('a','b').
    by('name') <i class="conum" data-value="7"></i><b>(7)</b>
g.V().as('a').out('knows').as('b').
  where('a',gt('b').or(eq('b'))).
    by('age').
    by('age').
    by(__.in('knows').values('age')).
  select('a','b').
    by('name') <i class="conum" data-value="8"></i><b>(8)</b></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>那些创建了工程的人的名字是什么？</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>不但创建了工程，而且还被别人认识的人名字是什么？</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>那些创建了2个及多个工程的人叫什么？</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>那些认识创建工程的人的人的名字是什么？（仅对OLTP系统生效，见下面 <code>WARNING</code>）</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>那些虽然没有创建任何工程，但是被认识的人的名字是？</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>使用 <code>where()</code> 级联和使用单个 <code>where()</code> 与and从句连接的意义相同</td>
</tr>
<tr>
<td><i class="conum" data-value="7"></i><b>7</b></td>
<td>Marko认识josh和vadas但是只比vadas年龄大</td>
</tr>
<tr>
<td><i class="conum" data-value="8"></i><b>8</b></td>
<td>Marko比josh年轻，但josh认识某些和marko同龄的人（也是marko）</td>
</tr>
</table>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
The anonymous traversal of <code>where()</code> processes the current object "locally". In OLAP, where the atomic unit
of computing is the vertex and its local "star graph," it is important that the anonymous traversal does not leave
the confines of the vertex&#8217;s star graph. In other words, it can not traverse to an adjacent vertex&#8217;s properties or
edges.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><strong>更多参考</strong></p>
</div>
<div class="paragraph">
<p><a href="http://tinkerpop.apache.org/javadocs/3.4.1/core/org/apache/tinkerpop/gremlin/process/traversal/dsl/graph/GraphTraversal.html#where-org.apache.tinkerpop.gremlin.process.traversal.P-"><code>where(P)</code></a>,
<a href="http://tinkerpop.apache.org/javadocs/3.4.1/core/org/apache/tinkerpop/gremlin/process/traversal/dsl/graph/GraphTraversal.html#where-java.lang.String-org.apache.tinkerpop.gremlin.process.traversal.P-"><code>where(String,P)</code></a>,
<a href="http://tinkerpop.apache.org/javadocs/3.4.1/core/org/apache/tinkerpop/gremlin/process/traversal/dsl/graph/GraphTraversal.html#where-org.apache.tinkerpop.gremlin.process.traversal.Traversal-"><code>where(Traversal)</code></a>,
<a href="http://tinkerpop.apache.org/javadocs/3.4.1/core/org/apache/tinkerpop/gremlin/process/traversal/P.html"><code>P</code></a></p>
</div>
</div>
<div class="sect2">
<h3 id="with-step"><a class="anchor" href="#with-step"></a>With Step</h3>
<div class="paragraph">
<p><code>with()</code> 单步也不是一个真正的独立单步，而是一个“协调步”来改变前一步的行为。
<code>with()</code> 也提供了一些额外的“配置”信息，这些都是实现了 <code>Configuring</code> 这个接口。
那些允许使用with来协调的单步都在文档里说明了怎样显式的使用</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="a-note-on-predicates"><a class="anchor" href="#a-note-on-predicates"></a>Predicates介绍</h2>
<div class="sectionbody">
<div class="paragraph">
<p><code>P</code> 是一个 <code>Function&lt;Object,Boolean&gt;</code> 类型的谓词函数（Java 函数类）。也就是说，给定一些对象，返回ture/false。
截止到TinkerPop 3.4.0，Gremlin也支持文本谓词函数，只对 <code>String</code> 类型值做处理。<code>TextP</code> 文本谓词是 <code>P</code> 的子类，但特定了是 <code>Function&lt;String,Boolean&gt;</code>。
下面展示了提供的谓词列表，可以在<a href="#has-step"><code>has()</code></a>，<a href="#where-step"><code>where()</code></a>和<a href="#is-step"><code>is()</code></a>中使用</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 16.6666%;">
<col style="width: 83.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">谓词函数</th>
<th class="tableblock halign-left valign-top">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>P.eq(object)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">传入对象是否等于提供对象？</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>P.neq(object)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">传入对象是否不等于提供对象？</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>P.lt(number)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">传入数是否小于提供数？</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>P.lte(number)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">传入数是否小于等于提供数？</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>P.gt(number)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">传入数是否大于提供数？</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>P.gte(number)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">传入数是否大于等于提供数？</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>P.inside(number,number)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">传入数字是否在大于提供的第一个并小于第二个数字？</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>P.outside(number,number)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">传入数字是否在小于提供的第一个或大于第二个？</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>P.between(number,number)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">传入数字是否在大于等于提供的第一个并小于第二个数字？</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>P.within(objects...)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">传入对象是否是提供列表中的一个？</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>P.without(objects...)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">传入对象是否不在提供列表中？</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>TextP.startingWith(string)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">传入string以提供的string为开始？</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>TextP.endingWith(string)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">传入string以提供的string为结束？</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>TextP.containing(string)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">传入string是否包含提供的string？</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>TextP.notStartingWith(string)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">传入string是否不以提供的string为开始？</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>TextP.notEndingWith(string)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">传入string是否不以提供的string为结束？</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>TextP.notContaining(string)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">传入string是否不包含提供的string？</p></td>
</tr>
</tbody>
</table>
<div class="listingblock">
<div class="content">
<pre>eq(2)
not(neq(2)) <i class="conum" data-value="1"></i><b>(1)</b>
not(within('a','b','c'))
not(within('a','b','c')).test('d') <i class="conum" data-value="2"></i><b>(2)</b>
not(within('a','b','c')).test('a')
within(1,2,3).and(not(eq(2))).test(3) <i class="conum" data-value="3"></i><b>(3)</b>
inside(1,4).or(eq(5)).test(3) <i class="conum" data-value="4"></i><b>(4)</b>
inside(1,4).or(eq(5)).test(5)
between(1,2) <i class="conum" data-value="5"></i><b>(5)</b>
not(between(1,2))</pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><code>not()</code> 加一个 <code>P</code> 谓词函数是一个新的 <code>P</code> 谓词</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td><code>P</code> 谓词函数中参数的很多部可以内部的使用 <code>test()</code> 来测试传入</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td><code>P</code> 谓词函数可以用and连接</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td><code>P</code> 谓词函数可以用or连接（生成新谓词）</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td><code>and()</code> 是一个 <code>P</code> 谓词所以 <code>P</code> 谓词可以由很多谓词函数组成</td>
</tr>
</table>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
为了让谓词表达更加清晰，最好可以 <code>import static org.apache.tinkerpop.gremlin.process.traversal.P.*</code>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>最后，注意<a href="#where-step"><code>where()</code></a> 接受一个 <code>P&lt;String&gt;</code>。提供的字符串值引用一个变量绑定，并不是字符串呈现的显式的值</p>
</div>
<div class="listingblock">
<div class="content">
<pre>g.V().as('a').both().both().as('b').count()
g.V().as('a').both().both().as('b').where('a',neq('b')).count()</pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
图服务提供商或者用户也可以扩展 <code>P</code> 来提供新的谓词函数，比如 <code>regex(pattern)</code> 就可以当成一个特定图系统的 <code>P</code>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="a-note-on-barrier-steps"><a class="anchor" href="#a-note-on-barrier-steps"></a>Barrier的解释</h2>
<div class="sectionbody">
<div class="imageblock">
<div class="content">
<img src="./images/barrier.png" alt="barrier" width="165">
</div>
</div>
<div class="paragraph">
<p>Gremlin本质上还是一个<a href="http://en.wikipedia.org/wiki/Lazy_evaluation">惰性</a>, 基于流处理的语言。
这意味着Gremlin先完整处理（尽其所能）当前遍历管道中的所有遍历器，然后再从遍历的头尾中获得跟多的数据。
但是，仍旧有一些场景下是不可能（或者不能实现）进行这种惰性计算。所以当计算本身不能进行惰性延迟，那么就需要一些“Barrier”。
一共有三种不同的Barrier：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><code>CollectingBarrierStep</code>：所有在这一步之前的遍历器先放入一个集合里，然后后续在一个一个“耗完”传入下一步之前做一些处理（比如排序）。
例子有<a href="#order-step"><code>order()</code></a>， <a href="#sample-step"><code>sample()</code></a>， <a href="#aggregate-step"><code>aggregate()</code></a>， <a href="#barrier-step"><code>barrier()</code></a></p>
</li>
<li>
<p><code>ReducingBarrierStep</code>：所有前面的遍历器都在被一个reduce函数处理，当所有的遍历器都被处理完成后，然后发出一个“reduce计算值”的遍历器到下一步。
注意路径历史当到达ReducingBarrierStep时因为它的多对一的特性将被销毁。例子诸如：<a href="#fold-step"><code>fold()</code></a>，<a href="#count-step"><code>count()</code></a>，<a href="#sum-step"><code>sum()</code></a>，<a href="#max-step"><code>max()</code></a>，<a href="#min-step"><code>min()</code></a>。</p>
</li>
<li>
<p><code>SupplyingBarrierStep</code>：所有在这一步前的遍历器在这一步前被迭代（但不处理），随后一个提供的supplier发出一个独立的遍历器传向下一步。例子如<a href="#cap-step"><code>cap()</code></a>。</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>在Gremlin OLAP（见<a href="#traversalvertexprogram"><code>TraversalVertexProgram</code></a>）中，在每一个<a href="#vertex-steps">顶点操作步</a>后都会插入一个barrier。
这意味着遍历将尽可能在当前局部顶点做运算。那些除非拿到相邻顶点才能计算的会被聚合到一个barrier集合里。
当局部顶点上没有遍历器后，被“栅栏”阻挡的遍历器被当做消息发给远端顶点进行下一步处理。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="a-note-on-scopes"><a class="anchor" href="#a-note-on-scopes"></a>关于Scopes的说明</h2>
<div class="sectionbody">
<div class="paragraph">
<p><code>Scope</code> 是个枚举，有两个常量：<code>Scope.local</code> 和 <code>Scope.global</code>。Scope的选择决定了一些特定的单步处理范围是当前对象（<code>local</code>）
或者是整个对象流（<code>global</code>）</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Python"></i>
</td>
<td class="content">
<div class="paragraph">
<p><code>global</code> 在Python是个关键字，所以要使用 <code>Scope</code> 的话要用 <code>global_</code></p>
</div>
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre>g.V().has('name','marko').out('knows').count() <i class="conum" data-value="1"></i><b>(1)</b>
g.V().has('name','marko').out('knows').fold().count() <i class="conum" data-value="2"></i><b>(2)</b>
g.V().has('name','marko').out('knows').fold().count(local) <i class="conum" data-value="3"></i><b>(3)</b>
g.V().has('name','marko').out('knows').fold().count(global) <i class="conum" data-value="4"></i><b>(4)</b></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Marko 认识2个人</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>创建一个Marko朋友的列表，然后计算总数（list结构个数是1）</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>创建一个Marko朋友的列表，但 <code>local</code> 计算将生成list内部的个数</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td><code>count(global)</code> 与 <code>count()</code> 相同，因为大多数单步的默认scope是 <code>global</code></td>
</tr>
</table>
</div>
<div class="paragraph">
<p>支持设置scope的单步有：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#count-step"><code>count()</code></a>：计算局部集合，还是全局数据流</p>
</li>
<li>
<p><a href="#dedup-step"><code>dedup()</code></a>：对局部对象还是全局数据流来去重</p>
</li>
<li>
<p><a href="#max-step"><code>max()</code></a>：对局部对象还是全局数据流来计算最大值</p>
</li>
<li>
<p><a href="#mean-step"><code>mean()</code></a>：对局部对象还是全局数据流来计算平均值</p>
</li>
<li>
<p><a href="#min-step"><code>min()</code></a>：对局部对象还是全局数据流来计算最小值</p>
</li>
<li>
<p><a href="#order-step"><code>order()</code></a>：对局部对象还是全局数据流来进行排序</p>
</li>
<li>
<p><a href="#range-step"><code>range()</code></a>：对局部对象还是全局数据流来进行截取</p>
</li>
<li>
<p><a href="#limit-step"><code>limit()</code></a>：对局部对象还是全局数据流来进行截取</p>
</li>
<li>
<p><a href="#sample-step"><code>sample()</code></a>：对局部对象还是全局数据流来进行采样</p>
</li>
<li>
<p><a href="#tail-step"><code>tail()</code></a>：获取局部对象还是全局数据流尾部值</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><code>Scope</code> 例子如下：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>g.V().both().group().by(label).select('software').dedup(local)
g.V().groupCount().by(label).select(values).min(local)
g.V().groupCount().by(label).order(local).by(values,desc)
g.V().fold().sample(local,2)</pre>
</div>
</div>
<div class="paragraph">
<p>最后，注意<a href="#local-step"><code>local()</code></a> 这个单步是一个“硬局部限制”的单步，它会将所有内部遍历变成局部的操作。
下面的例子就是有意图的：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>g.V().fold().local(unfold().count())
g.V().fold().count(local)</pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="a-note-on-lambdas"><a class="anchor" href="#a-note-on-lambdas"></a>Lambdas说明</h2>
<div class="sectionbody">
<div class="imageblock">
<div class="content">
<img src="./images/lambda.png" alt="lambda" width="150">
</div>
</div>
<div class="paragraph">
<p><a href="http://en.wikipedia.org/wiki/Anonymous_function">lambda</a> 是一种可以接受引用或者传入的匿名函数。
在Gremlin, lambdas使得用户能（在运行态）创建一个特定目的的单步。但是建议尽量避免使用它。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>g.V().filter{it.get().value('name') == 'marko'}.
      flatMap{it.get().vertices(OUT,'created')}.
      map {it.get().value('name')} <i class="conum" data-value="1"></i><b>(1)</b>
g.V().has('name','marko').out('created').values('name') <i class="conum" data-value="2"></i><b>(2)</b></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>携带lambda的Gremlin遍历，可以避免也应该避免（<strong>不建议使用</strong>）</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>相同的遍历，但不携带lambda （<strong>建议使用</strong>）</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Gremlin还是尽量去提供一个详尽完备的单步操作集合，用户这样就可以不需要在实际中使用lambda。
也只建议用户想要一个功能而没有这个单步的情况下使用lambda。原因是在Gremlin编译阶段lambda没法被插入到编译中，也就没法优化
（见<a href="#traversalstrategy">traversal strategies</a>），当前也不支持写一个原生的lambda发送到远程去执行，驱动也不支持。</p>
</div>
<div class="paragraph">
<p>很多在使用lambda的地方，都可以使用一个相应的单步操作，或者直接提供一个遍历来替代。
<code>TraversalLambda</code> 行为和典型的lambda类似，但它是可以参与优化的，因为它比纯正的lambda生成较少的对象</p>
</div>
<div class="listingblock">
<div class="content">
<pre>g.V().out().out().path().by {it.value('name')}.
                         by {it.value('name')}.
                         by {g.V(it).in('created').values('name').fold().next()} <i class="conum" data-value="1"></i><b>(1)</b>
g.V().out().out().path().by('name').
                         by('name').
                         by(__.in('created').values('name').fold()) <i class="conum" data-value="2"></i><b>(2)</b></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>三步游走的路径的每一个对象都被lambda转换（<strong>不建议使用</strong>）</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>三步游走的路径的每一个对象被单步和遍历（当做lambda）替代（<strong>建议使用</strong>）</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="traversalstrategy"><a class="anchor" href="#traversalstrategy"></a>TraversalStrategy</h2>
<div class="sectionbody">
<div class="imageblock">
<div class="content">
<img src="./images/traversal-strategy.png" alt="traversal strategy" width="125">
</div>
</div>
<div class="paragraph">
<p><code>TraversalStrategy</code> 分析 <code>Traversal</code> 并且一旦符合条件，就对其进行相应的变换。
遍历策略在编译阶段就参与了，这也是整个Gremlin遍历编译器的根基。下面有5种类型的遍历策略</p>
</div>
<div class="ulist">
<ul>
<li>
<p>有一个用户层面的应用可以被嵌入到遍历逻辑中 (<strong>decoration</strong>).</p>
</li>
<li>
<p>在TinkerPop层面，有一种更有效地描述遍历的方法 (<strong>optimization</strong>).</p>
</li>
<li>
<p>在图系统/语言/驱动层面，有更有效的描述遍历的方式 (<strong>provider optimization</strong>).</p>
</li>
<li>
<p>在遍历执行之前，需要有一些的最终调整/清理/分析工作</p>
</li>
<li>
<p>对应用和遍历引擎来说，某些遍历器是不合法的 (<strong>verification</strong>).</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<a href="#explain-step"><code>explain()</code></a> 单步告诉用户已经注册的策略是如何调整遍历的
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>一个简单的 <code>OptimizationStrategy</code> 实现是 <code>IdentityRemovalStrategy</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="directive">final</span> <span class="type">class</span> <span class="class">IdentityRemovalStrategy</span> <span class="directive">extends</span> AbstractTraversalStrategy&lt;TraversalStrategy.OptimizationStrategy&gt; <span class="directive">implements</span> TraversalStrategy.OptimizationStrategy {

    <span class="directive">private</span> <span class="directive">static</span> <span class="directive">final</span> IdentityRemovalStrategy INSTANCE = <span class="keyword">new</span> IdentityRemovalStrategy();

    <span class="directive">private</span> IdentityRemovalStrategy() {
    }

    <span class="annotation">@Override</span>
    <span class="directive">public</span> <span class="type">void</span> apply(Traversal.Admin&lt;?, ?&gt; traversal) {
        <span class="keyword">if</span> (traversal.getSteps().size() &lt;= <span class="integer">1</span>)
            <span class="keyword">return</span>;

        <span class="keyword">for</span> (IdentityStep&lt;?&gt; identityStep : TraversalHelper.getStepsOfClass(IdentityStep.class, traversal)) {
            <span class="keyword">if</span> (identityStep.getLabels().isEmpty() || !(identityStep.getPreviousStep() <span class="keyword">instanceof</span> EmptyStep)) {
                TraversalHelper.copyLabels(identityStep, identityStep.getPreviousStep(), <span class="predefined-constant">false</span>);
                traversal.removeStep(identityStep);
            }
        }
    }

    <span class="directive">public</span> <span class="directive">static</span> IdentityRemovalStrategy instance() {
        <span class="keyword">return</span> INSTANCE;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>策略很简单，就是直接在遍历中删除 <code>IdentityStep</code> 单步，因为 <code>aStep().identity().identity().bStep()</code> 等同于 <code>aStep().bStep()</code>。
有些遍历策略需要在执行前或执行后使用其他策略，那么就可以在 <code>TraversalStrategy</code> 实现里实现这两个相对应的方法（默认是没有实现的）。
当然，如果一个 <code>TraversalStrategy</code> 实现属于上述的五种分类中（decoration， optimization， provider-optimization， finalization，or verification），
那么它priors和posts也只能在相应的分类中选。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="predefined-type">Set</span>&lt;<span class="predefined-type">Class</span>&lt;? <span class="directive">extends</span> S&gt;&gt; applyPrior();
<span class="directive">public</span> <span class="predefined-type">Set</span>&lt;<span class="predefined-type">Class</span>&lt;? <span class="directive">extends</span> S&gt;&gt; applyPost();</code></pre>
</div>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<code>TraversalStrategy</code> 使用起来是按照其内部排序进行的，顺序是：decoration， optimization， provider optimization， finalization然后verification。
如果设计新的新策略并不是完全符合这5种分类，那么实现 <code>TraversalStrategy</code> 和其prior，posts方法也可以在任何分类中选，但不推荐这样用
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>下面是一个 <code>GraphSystemOptimizationStrategy</code> 的实现例子</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="groovy">g.V().has(<span class="string"><span class="delimiter">'</span><span class="content">name</span><span class="delimiter">'</span></span>,<span class="string"><span class="delimiter">'</span><span class="content">marko</span><span class="delimiter">'</span></span>)</code></pre>
</div>
</div>
<div class="paragraph">
<p>如上的语句，就可以让<a href="#tinkergraph-gremlin">TinkerGraph</a>在 <code>O(|V|)</code> 或 <code>O(log(|V|)</code> 的时间复杂度内实现，
具体依赖了是否有"name"的索引。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="directive">final</span> <span class="type">class</span> <span class="class">TinkerGraphStepStrategy</span> <span class="directive">extends</span> AbstractTraversalStrategy&lt;TraversalStrategy.ProviderOptimizationStrategy&gt; <span class="directive">implements</span> TraversalStrategy.ProviderOptimizationStrategy {

    <span class="directive">private</span> <span class="directive">static</span> <span class="directive">final</span> TinkerGraphStepStrategy INSTANCE = <span class="keyword">new</span> TinkerGraphStepStrategy();

    <span class="directive">private</span> TinkerGraphStepStrategy() {
    }

    <span class="annotation">@Override</span>
    <span class="directive">public</span> <span class="type">void</span> apply(Traversal.Admin&lt;?, ?&gt; traversal) {
        <span class="keyword">if</span> (TraversalHelper.onGraphComputer(traversal))
            <span class="keyword">return</span>;

        <span class="keyword">for</span> (GraphStep originalGraphStep : TraversalHelper.getStepsOfClass(GraphStep.class, traversal)) {
            TinkerGraphStep&lt;?, ?&gt; tinkerGraphStep = <span class="keyword">new</span> TinkerGraphStep&lt;&gt;(originalGraphStep);
            TraversalHelper.replaceStep(originalGraphStep, tinkerGraphStep, traversal);
            Step&lt;?, ?&gt; currentStep = tinkerGraphStep.getNextStep();
            <span class="keyword">while</span> (currentStep <span class="keyword">instanceof</span> HasStep || currentStep <span class="keyword">instanceof</span> NoOpBarrierStep) {
                <span class="keyword">if</span> (currentStep <span class="keyword">instanceof</span> HasStep) {
                    <span class="keyword">for</span> (HasContainer hasContainer : ((HasContainerHolder) currentStep).getHasContainers()) {
                        <span class="keyword">if</span> (!GraphStep.processHasContainerIds(tinkerGraphStep, hasContainer))
                            tinkerGraphStep.addHasContainer(hasContainer);
                    }
                    TraversalHelper.copyLabels(currentStep, currentStep.getPreviousStep(), <span class="predefined-constant">false</span>);
                    traversal.removeStep(currentStep);
                }
                currentStep = currentStep.getNextStep();
            }
        }
    }

    <span class="directive">public</span> <span class="directive">static</span> TinkerGraphStepStrategy instance() {
        <span class="keyword">return</span> INSTANCE;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>遍历器的重定义很简单，比如 <code>TinkerGraphStep</code> 直接把 <code>g.V()</code> 后面接上一串 <code>has()</code> 单步，并且提供 <code>HasContainers</code> 给  <code>TinkerGraphStep</code>。
这样 <code>TinkerGraphStep</code> 就可以判断是否有相应的索引。因为这是一个非TinkerPop提供的单步，所以应该归类到 <code>ProviderOptimizationStrategy</code> 类别
以免干扰到 <code>OptimizationStrategy</code> 策略的假设。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>t = g.V().has('name','marko'); null
t.toString()
t.iterate(); null
t.toString()</pre>
</div>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
<code>OptimizationStrategy</code> 和 <code>ProviderOptimizationStrategy</code> 是两个不同分组的原因是因为优化的策略只能用
TinkerPop提供的单步来重写遍历。这也保证了到优化策略执行到最后最终优化结果也是TinkerPop兼容的。就这而说，服务商提供的优化策略可以分析遍历并
使用图系统特殊的单步来重写遍历本身（比如将 <code>GraphStep.HasStep...HasStep</code> 替换成 <code>TinkerGraphStep</code>）。如果服务商为图系统实现了 <code>OptimizationStrategy</code> 并提供了特殊优化，
那么原有的TinkerPop优化在执行遍历优化可能失败，或者对图系统特殊单步行为（比如 <code>ProviderVertexStep 扩展了 VertexStep</code>）理解错误并生成错误语义。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>最后，比如下例是一个复杂的遍历，包含多种复杂组件，就可以被TinkerPop默认策略优化</p>
</div>
<div class="listingblock">
<div class="content">
<pre>g.V().hasLabel('person'). <i class="conum" data-value="1"></i><b>(1)</b>
        and(has('name'),  <i class="conum" data-value="2"></i><b>(2)</b>
            has('name','marko'),
            filter(has('age',gt(20)))). <i class="conum" data-value="3"></i><b>(3)</b>
  match(__.as('a').has('age',lt(32)), <i class="conum" data-value="4"></i><b>(4)</b>
        __.as('a').repeat(outE().inV()).times(2).as('b')). <i class="conum" data-value="5"></i><b>(5)</b>
    where('a',neq('b')). <i class="conum" data-value="6"></i><b>(6)</b>
    where(__.as('b').both().count().is(gt(1))). <i class="conum" data-value="7"></i><b>(7)</b>
  select('b'). <i class="conum" data-value="8"></i><b>(8)</b>
  groupCount().
    by(out().count()). <i class="conum" data-value="9"></i><b>(9)</b>
  explain()</pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><code>TinkerGraphStepStrategy</code> 为 <code>has()</code> 单步提供了可以使用全局图维度的索引查找的谓词</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td><code>FilterRankStrategy</code> 为过滤单步的空间时间代价进行排序</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td><code>InlineFilterStrategy</code> 去掉回环调用，用于增加相似过滤器的连接性，或者聚合它们</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td><code>InlineFilterStrategy</code> 从 <code>match()</code> 中提取名称谓词，这样就很容易让用户自定义的策略来使用索引</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td><code>RepeatUnrollStrategy</code> 将展开循环，<code>IncidentToAdjacentStrategy</code> 把 <code>outE().inV()</code> 类型变成 <code>out()</code></td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td><code>MatchPredicateStrategy</code> 将引入 <code>where()</code> 单步，所以可以接受 <code>match()</code> 单步的运行态优化器</td>
</tr>
<tr>
<td><i class="conum" data-value="7"></i><b>7</b></td>
<td><code>CountStrategy</code> 将在遍历上通过 <code>count().is(x)</code> 检查，来限制遍历器的数目</td>
</tr>
<tr>
<td><i class="conum" data-value="8"></i><b>8</b></td>
<td><code>PathRetractionStrategy</code> 将删除遍历器中的路径，并增加批量的相似性，因为 <code>select('b')</code> 并不需要路径数据</td>
</tr>
<tr>
<td><i class="conum" data-value="9"></i><b>9</b></td>
<td><code>AdjacentToIncidentStrategy</code> 讲把 <code>out()</code> 变成 <code>outE()</code> 来增加数据操作的局部性</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>TinkerPop提供了对使用者很有用的 <code>DecorationStrategy</code> 策略集合，下面子章节描述了这些策略的详细信息</p>
</div>
<div class="sect2">
<h3 id="elementidstrategy"><a class="anchor" href="#elementidstrategy"></a>ElementIdStrategy</h3>
<div class="paragraph">
<p><code>ElementIdStrategy</code> 提供了元素标识ID的控制能力。比如有些图实现，比如TinkerGraph，允许用户在创建元素时指定其ID：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>g = TinkerGraph.open().traversal()
v = g.addV().property(id,'42a').next()
g.V('42a')</pre>
</div>
</div>
<div class="paragraph">
<p>其他的图实现如Neo4j，自动生成元素ID且不能被指定。<code>ElementIdStrategy</code> 可以用于帮助用于按照边和定点的索引来分配标识ID</p>
</div>
<div class="listingblock">
<div class="content">
<pre>graph = Neo4jGraph.open('/tmp/neo4j')
strategy = ElementIdStrategy.build().create()
g = graph.traversal().withStrategies(strategy)
g.addV().property(id, '42a').id()</pre>
</div>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
在图底层的存储系统里，用于存储标识ID的key应该有索引。如果没有的话，那么所有元素的查找都会变成全量扫描操作
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="eventstrategy"><a class="anchor" href="#eventstrategy"></a>EventStrategy</h3>
<div class="paragraph">
<p><code>EventStrategy</code> 策略的目的是在在遍历时，当图底层变化时一个或者多个 <code>MutationListener</code> 对象发送事件通知。
这种策略用于记录变化，根据变化触发特定的行为，或者在遍历变化时通知相关应用。当操作事务被回滚时，通知事件队列也被清空。</p>
</div>
<div class="paragraph">
<p><code>MutationListener</code> 将发送下列通知：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>新顶点创建</p>
</li>
<li>
<p>新边创建</p>
</li>
<li>
<p>顶点属性变化</p>
</li>
<li>
<p>边属性变化</p>
</li>
<li>
<p>移除顶点属性</p>
</li>
<li>
<p>移除边属性</p>
</li>
<li>
<p>移除顶点</p>
</li>
<li>
<p>移除边</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><code>Traversal</code> 要处理事件，首先就要实现 <code>MutationListener</code> 接口。一个实现的例子是  <code>ConsoleMutationListener</code>，
它在控制台上输出这些事件。下面控制台输出是一些基本使用方法</p>
</div>
<div class="listingblock">
<div class="content">
<pre>import org.apache.tinkerpop.gremlin.process.traversal.step.util.event.*
graph = TinkerFactory.createModern()
l = new ConsoleMutationListener(graph)
strategy = EventStrategy.build().addListener(l).create()
g = graph.traversal().withStrategies(strategy)
g.addV().property('name','stephen')
g.E().drop()</pre>
</div>
</div>
<div class="paragraph">
<p><code>EventStrategy</code> 默认的配置了一个 <code>EventQueue</code>，用于在执行单步时可能生成通知事件。
因此，在Gremlin执行最后一行，来删掉所有的边的时候有一些数字不一致的情况，因为删掉边的总数是在消息发出后统计的。
策略也可以配置一个 <code>TransactionalEventQueue</code> 队列，它会将所有的变化存下来，直到提交阶段才发出所有的通知。</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
<code>EventStrategy</code> 不适用于追踪跨进程的全局变化。换句话说，一个JVM进程中的变化不会发送到另一个JVM进程。
实际上，变化的通知消息的发送不会超出 <code>Traversal</code> 的上下文。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>另外一个 <code>EventStrategy</code> 的默认配置是围绕着“分离”的概念展开的。图元素作为通知事件的相关引用，是作为拷贝分理出图的。
所以当在TinkerGraph中增加一个新顶点，通知事件不是包含一个 <code>TinkerVertex</code>，而是一个 <code>DetachedVertex</code>。
这种行为，可以修改 <code>EventStrategy.Builder</code> 中的 <code>detach()</code> 方法，它可以接受一个 <code>null</code> 输入来表明不需要分离，那么就返回原始的元素。
<code>DetachedFactory</code> 是默认配置行为，而 <code>ReferenceFactory</code> 将返回引用，但只对没有属性的元素生效。</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
如果设置 <code>detach()</code> 配置为 <code>null</code>，要小心事务性的图会在提交后立即创建一个新的事务用于生成通知事件。
通知事件里面的图元素并不是一个事件发生时实际数据的“快照”，而是一个“现场”的数据库元素的引用
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="partitionstrategy"><a class="anchor" href="#partitionstrategy"></a>PartitionStrategy</h3>
<div class="imageblock">
<div class="content">
<img src="./images/partition-graph.png" alt="partition graph" width="325">
</div>
</div>
<div class="paragraph">
<p><code>PartitionStrategy</code> 将图的诸多顶点和边分区成以 <code>String</code> 字符串命名的分区（比如bucket，子图等）
在上图中，每个元素都有颜色的意义就是 <code>PartitionStrategy</code> 背后所描述的意义。
可以进行跨分区读写，也可以按边将其合并，或者分裂成两个新分区（比如一个头顶点在一个分区里，一个尾顶点在另一个）</p>
</div>
<div class="paragraph">
<p><code>PartitionStrategy</code> 有三个主要配置项：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>分区Key - 标识分区String字符串值的属性key</p>
</li>
<li>
<p>写分区 - 一个 <code>String</code> 字符串，表明未来写入的元素在哪个分区</p>
</li>
<li>
<p>读分区 - <code>Set&lt;String&gt;</code> 集合的可读到数据的分区</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>下例可以更好的理解 <code>PartitionStrategy</code> 分区策略</p>
</div>
<div class="listingblock">
<div class="content">
<pre>graph = TinkerFactory.createModern()
strategyA = PartitionStrategy.build().partitionKey("_partition").writePartition("a").readPartitions("a").create()
strategyB = PartitionStrategy.build().partitionKey("_partition").writePartition("b").readPartitions("b").create()
gA = graph.traversal().withStrategies(strategyA)
gA.addV() // this vertex has a property of {_partition:"a"}
gB = graph.traversal().withStrategies(strategyB)
gB.addV() // this vertex has a property of {_partition:"b"}
gA.V()
gB.V()</pre>
</div>
</div>
<div class="paragraph">
<p>如果图支持元属性（meta-properties）且当构建 <code>PartitionStrategy</code> 时，将 <code>includeMetaProperties</code> 设置为 <code>true</code>，
那么分区可以扩展 <code>VertexProperty</code> 元素。<code>partitionKey</code> 会被存在 <code>VertexProperty</code> 的元属性内，并无条件遍历这些属性。
请注意 <code>VertexProperty</code> 只在 <code>Traversal</code> 自己内封闭。比如调用 <code>Vertex.property(k)</code> 可以绕过 <code>PartitionStrategy</code> 的
上下文，所以可以直接访问所有属性</p>
</div>
<div class="paragraph">
<p>将图元素写入特殊的分区，然后指定好读分区，开发者就能在一个空间里创建多张图。
另外，为了支持跨单元引用，也可以合并多张图（合并分区）</p>
</div>
</div>
<div class="sect2">
<h3 id="readonlystrategy"><a class="anchor" href="#readonlystrategy"></a>ReadOnlyStrategy</h3>
<div class="paragraph">
<p><code>ReadOnlyStrategy</code> 是很容易理解的策略。如果遍历内部有步骤做了任何改动，那么使用了这个策略的遍历器就会抛出 <code>IllegalStateException</code> 异常</p>
</div>
</div>
<div class="sect2">
<h3 id="subgraphstrategy"><a class="anchor" href="#subgraphstrategy"></a>SubgraphStrategy</h3>
<div class="paragraph">
<p><code>SubgraphStrategy</code> 和 <code>PartitionStrategy</code> 很相似，它将遍历约束到某些顶点和边、和顶点属性。
这个范围由每个单独的基于遍历的条件决定</p>
</div>
<div class="listingblock">
<div class="content">
<pre>graph = TinkerFactory.createTheCrew()
g = graph.traversal()
g.V().as('a').values('location').as('b').  <i class="conum" data-value="1"></i><b>(1)</b>
  select('a','b').by('name').by()
g = g.withStrategies(SubgraphStrategy.build().vertexProperties(hasNot('endTime')).create()) <i class="conum" data-value="2"></i><b>(2)</b>
g.V().as('a').values('location').as('b').  <i class="conum" data-value="3"></i><b>(3)</b>
  select('a','b').by('name').by()
g.V().as('a').values('location').as('b').
  select('a','b').by('name').by().explain()</pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>获取所有的顶点和location顶点属性</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>创建一个 <code>SubgraphStrategy</code>，每个顶点都不能含有 <code>endTime</code> 属性 （所以，当前位置）</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>获取所有顶点和当前的locations顶点属性</td>
</tr>
</table>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
这个策略的实现是将附加到边的顶点都必须符合顶点标准（如果存在），这样边本身也能够作为子图的一部分而存在
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>下例使用所有的三种过滤器，顶点，边，和顶点属性。people的顶点必须曾经在三个location出现过，边必须含有"develops"，
并且顶点属性必须是person当前的位置，或者一个非location属性</p>
</div>
<div class="listingblock">
<div class="content">
<pre>graph = TinkerFactory.createTheCrew()
g = graph.traversal().withStrategies(SubgraphStrategy.build().
  vertices(or(hasNot('location'),properties('location').count().is(gt(3)))).
  edges(hasLabel('develops')).
  vertexProperties(or(hasLabel(neq('location')),hasNot('endTime'))).create())
g.V().valueMap().with(WithOptions.tokens)
g.E().valueMap().with(WithOptions.tokens)
g.V().outE().inV().
  path().
    by('name').
    by().
    by('name')</pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="dsl"><a class="anchor" href="#dsl"></a>Domain Specific Languages</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Gremlin是遍历图的一种<a href="http://en.wikipedia.org/wiki/Domain-specific_language">DSL</a>
在语言里他用来操作顶点，边，和属性。典型地说，应用Gremlin的应用并不是整个图域，而是它将自己的数据域在图内进行建模。
举例说，<a href="http://tinkerpop.apache.org/docs/current/images/tinkerpop-modern.png">"modern" toy graph</a> 将“软件”和“人”
的想换关系的对象域建模成了图。（比如一个人“认识”另外一个人，而一个人“创建”了软件，之类的关系）</p>
</div>
<div class="paragraph">
<p>如果要分析出"marko"是否认识"josh"可以写以下的Gremlin：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">g.V().hasLabel(<span class="string"><span class="delimiter">'</span><span class="content">person</span><span class="delimiter">'</span></span>).has(<span class="string"><span class="delimiter">'</span><span class="content">name</span><span class="delimiter">'</span></span>,<span class="string"><span class="delimiter">'</span><span class="content">marko</span><span class="delimiter">'</span></span>).
  out(<span class="string"><span class="delimiter">'</span><span class="content">knows</span><span class="delimiter">'</span></span>).hasLabel(<span class="string"><span class="delimiter">'</span><span class="content">person</span><span class="delimiter">'</span></span>).has(<span class="string"><span class="delimiter">'</span><span class="content">name</span><span class="delimiter">'</span></span>,<span class="string"><span class="delimiter">'</span><span class="content">josh</span><span class="delimiter">'</span></span>).hasNext()</code></pre>
</div>
</div>
<div class="paragraph">
<p>这样的方法可以达到目的，它要求大家来图上写DSL语句，而不是用社交网络的语言来描述。如果更自然的语句表达，那就应该这样写：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">g.persons(<span class="string"><span class="delimiter">'</span><span class="content">marko</span><span class="delimiter">'</span></span>).knows(<span class="string"><span class="delimiter">'</span><span class="content">josh</span><span class="delimiter">'</span></span>).hasNext()</code></pre>
</div>
</div>
<div class="paragraph">
<p>在上述描述中，遍历写成的DSL语句都是在不同域定义的，从底层抽象出图结构。
这两个遍历的结果是等同的，实际上这个“社交DSL”与“图DSL”生成相同的结果，从而产生等效的策略应用和动态性能</p>
</div>
<div class="paragraph">
<p>下列是一些社交DSL更深层的例子</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="comment">// Graph DSL - find the number of persons who created at least 2 projects</span>
g.V().hasLabel(<span class="string"><span class="delimiter">'</span><span class="content">person</span><span class="delimiter">'</span></span>).
  where(outE(<span class="string"><span class="delimiter">&quot;</span><span class="content">created</span><span class="delimiter">&quot;</span></span>).count().is(P.gte(<span class="integer">2</span>))).count()

<span class="comment">// Social DSL - find the number of persons who created at least 2 projects</span>
social.persons().where(createdAtLeast(<span class="integer">2</span>)).count()

<span class="comment">// Graph DSL - determine the age of the youngest friend &quot;marko&quot; has</span>
g.V().hasLabel(<span class="string"><span class="delimiter">'</span><span class="content">person</span><span class="delimiter">'</span></span>).has(<span class="string"><span class="delimiter">'</span><span class="content">name</span><span class="delimiter">'</span></span>,<span class="string"><span class="delimiter">'</span><span class="content">marko</span><span class="delimiter">'</span></span>).
  out(<span class="string"><span class="delimiter">&quot;</span><span class="content">knows</span><span class="delimiter">&quot;</span></span>).hasLabel(<span class="string"><span class="delimiter">&quot;</span><span class="content">person</span><span class="delimiter">&quot;</span></span>).values(<span class="string"><span class="delimiter">&quot;</span><span class="content">age</span><span class="delimiter">&quot;</span></span>).min()

<span class="comment">// Social DSL - determine the age of the youngest friend &quot;marko&quot; has</span>
social.persons(<span class="string"><span class="delimiter">&quot;</span><span class="content">marko</span><span class="delimiter">&quot;</span></span>).youngestFriendsAge()</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果对编程语言有兴趣，可以在 <a href="#gremlin-drivers-variants">Gremlin Language Variants</a> 章节学到如何实现这些DSL</p>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Last updated 2019-06-25 16:27:52 +0800
</div>
</div>
</body>
</html>